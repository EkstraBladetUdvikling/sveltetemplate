
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35730/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
    'use strict';

    function _mergeNamespaces(n, m) {
        m.forEach(function (e) {
            e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {
                if (k !== 'default' && !(k in n)) {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () { return e[k]; }
                    });
                }
            });
        });
        return Object.freeze(n);
    }

    function noop() { }
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    let src_url_equal_anchor;
    function src_url_equal(element_src, url) {
        if (!src_url_equal_anchor) {
            src_url_equal_anchor = document.createElement('a');
        }
        src_url_equal_anchor.href = url;
        return element_src === src_url_equal_anchor.href;
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function get_all_dirty_from_scope($$scope) {
        if ($$scope.ctx.length > 32) {
            const dirty = [];
            const length = $$scope.ctx.length / 32;
            for (let i = 0; i < length; i++) {
                dirty[i] = -1;
            }
            return dirty;
        }
        return -1;
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }
    function compute_slots(slots) {
        const result = {};
        for (const key in slots) {
            result[key] = true;
        }
        return result;
    }
    function set_store_value(store, ret, value) {
        store.set(value);
        return ret;
    }
    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function stop_propagation(fn) {
        return function (event) {
            event.stopPropagation();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_attributes(node, attributes) {
        // @ts-ignore
        const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
        for (const key in attributes) {
            if (attributes[key] == null) {
                node.removeAttribute(key);
            }
            else if (key === 'style') {
                node.style.cssText = attributes[key];
            }
            else if (key === '__value') {
                node.value = node[key] = attributes[key];
            }
            else if (descriptors[key] && descriptors[key].set) {
                node[key] = attributes[key];
            }
            else {
                attr(node, key, attributes[key]);
            }
        }
    }
    function set_svg_attributes(node, attributes) {
        for (const key in attributes) {
            attr(node, key, attributes[key]);
        }
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_style(node, key, value, important) {
        if (value === null) {
            node.style.removeProperty(key);
        }
        else {
            node.style.setProperty(key, value, important ? 'important' : '');
        }
    }
    function select_option(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            if (option.__value === value) {
                option.selected = true;
                return;
            }
        }
        select.selectedIndex = -1; // no option should be selected
    }
    function select_value(select) {
        const selected_option = select.querySelector(':checked') || select.options[0];
        return selected_option && selected_option.__value;
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail, bubbles = false) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, false, detail);
        return e;
    }
    class HtmlTag {
        constructor() {
            this.e = this.n = null;
        }
        c(html) {
            this.h(html);
        }
        m(html, target, anchor = null) {
            if (!this.e) {
                this.e = element(target.nodeName);
                this.t = target;
                this.c(html);
            }
            this.i(anchor);
        }
        h(html) {
            this.e.innerHTML = html;
            this.n = Array.from(this.e.childNodes);
        }
        i(anchor) {
            for (let i = 0; i < this.n.length; i += 1) {
                insert(this.t, this.n[i], anchor);
            }
        }
        p(html) {
            this.d();
            this.h(html);
            this.i(this.a);
        }
        d() {
            this.n.forEach(detach);
        }
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    function setContext(key, context) {
        get_current_component().$$.context.set(key, context);
    }
    function getContext(key) {
        return get_current_component().$$.context.get(key);
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            // @ts-ignore
            callbacks.slice().forEach(fn => fn.call(this, event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    // flush() calls callbacks in this order:
    // 1. All beforeUpdate callbacks, in order: parents before children
    // 2. All bind:this callbacks, in reverse order: children before parents.
    // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
    //    for afterUpdates called during the initial onMount, which are called in
    //    reverse order: children before parents.
    // Since callbacks might update component values, which could trigger another
    // call to flush(), the following steps guard against this:
    // 1. During beforeUpdate, any updated components will be added to the
    //    dirty_components array and will cause a reentrant call to flush(). Because
    //    the flush index is kept outside the function, the reentrant call will pick
    //    up where the earlier call left off and go through all dirty components. The
    //    current_component value is saved and restored so that the reentrant call will
    //    not interfere with the "parent" flush() call.
    // 2. bind:this callbacks cannot trigger new flush() calls.
    // 3. During afterUpdate, any updated components will NOT have their afterUpdate
    //    callback called a second time; the seen_callbacks set, outside the flush()
    //    function, guarantees this behavior.
    const seen_callbacks = new Set();
    let flushidx = 0; // Do *not* move this inside the flush() function
    function flush() {
        const saved_component = current_component;
        do {
            // first, call beforeUpdate functions
            // and update components
            while (flushidx < dirty_components.length) {
                const component = dirty_components[flushidx];
                flushidx++;
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            flushidx = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        seen_callbacks.clear();
        set_current_component(saved_component);
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.46.4' }, detail), true));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getDefaultExportFromCjs (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function getAugmentedNamespace(n) {
    	if (n.__esModule) return n;
    	var a = Object.defineProperty({}, '__esModule', {value: true});
    	Object.keys(n).forEach(function (k) {
    		var d = Object.getOwnPropertyDescriptor(n, k);
    		Object.defineProperty(a, k, d.get ? d : {
    			enumerable: true,
    			get: function () {
    				return n[k];
    			}
    		});
    	});
    	return a;
    }

    var dist = {};

    const subscriber_queue = [];
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (const subscriber of subscribers) {
                        subscriber[1]();
                        subscriber_queue.push(subscriber, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                subscribers.delete(subscriber);
                if (subscribers.size === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }

    var IconComponents$1 = {};

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/angle-down.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$20 = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/angle-down.svg.rollup-plugin.svelte";

    function create_fragment$22(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "chevron-down" },
    		{
    			class: "svg-inline--fa fa-chevron-down fa-w-14"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 448 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M443.5 162.6l-7.1-7.1c-4.7-4.7-12.3-4.7-17 0L224 351 28.5 155.5c-4.7-4.7-12.3-4.7-17 0l-7.1 7.1c-4.7 4.7-4.7 12.3 0 17l211 211.1c4.7 4.7 12.3 4.7 17 0l211-211.1c4.8-4.7 4.8-12.3.1-17z");
    			add_location(path, file$20, 0, 214, 214);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$20, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "chevron-down" },
    				{
    					class: "svg-inline--fa fa-chevron-down fa-w-14"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 448 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$22.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$21($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Angle_down_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Angle_down_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$21, create_fragment$22, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Angle_down_svg_rollup_plugin",
    			options,
    			id: create_fragment$22.name
    		});
    	}
    }

    var angleDown_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Angle_down_svg_rollup_plugin
    });

    var require$$0$4 = /*@__PURE__*/getAugmentedNamespace(angleDown_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/angle-left.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1$ = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/angle-left.svg.rollup-plugin.svelte";

    function create_fragment$21(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "chevron-left" },
    		{
    			class: "svg-inline--fa fa-chevron-left fa-w-8"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 256 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M238.475 475.535l7.071-7.07c4.686-4.686 4.686-12.284 0-16.971L50.053 256 245.546 60.506c4.686-4.686 4.686-12.284 0-16.971l-7.071-7.07c-4.686-4.686-12.284-4.686-16.97 0L10.454 247.515c-4.686 4.686-4.686 12.284 0 16.971l211.051 211.05c4.686 4.686 12.284 4.686 16.97-.001z");
    			add_location(path, file$1$, 0, 213, 213);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1$, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "chevron-left" },
    				{
    					class: "svg-inline--fa fa-chevron-left fa-w-8"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 256 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$21.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$20($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Angle_left_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Angle_left_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$20, create_fragment$21, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Angle_left_svg_rollup_plugin",
    			options,
    			id: create_fragment$21.name
    		});
    	}
    }

    var angleLeft_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Angle_left_svg_rollup_plugin
    });

    var require$$1$1 = /*@__PURE__*/getAugmentedNamespace(angleLeft_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/angle-right.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1_ = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/angle-right.svg.rollup-plugin.svelte";

    function create_fragment$20(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "chevron-right" },
    		{
    			class: "svg-inline--fa fa-chevron-right fa-w-8"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 256 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M17.525 36.465l-7.071 7.07c-4.686 4.686-4.686 12.284 0 16.971L205.947 256 10.454 451.494c-4.686 4.686-4.686 12.284 0 16.971l7.071 7.07c4.686 4.686 12.284 4.686 16.97 0l211.051-211.05c4.686-4.686 4.686-12.284 0-16.971L34.495 36.465c-4.686-4.687-12.284-4.687-16.97 0z");
    			add_location(path, file$1_, 0, 215, 215);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1_, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "chevron-right" },
    				{
    					class: "svg-inline--fa fa-chevron-right fa-w-8"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 256 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$20.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1$($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Angle_right_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Angle_right_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1$, create_fragment$20, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Angle_right_svg_rollup_plugin",
    			options,
    			id: create_fragment$20.name
    		});
    	}
    }

    var angleRight_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Angle_right_svg_rollup_plugin
    });

    var require$$2$1 = /*@__PURE__*/getAugmentedNamespace(angleRight_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/angle-up.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1Z = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/angle-up.svg.rollup-plugin.svelte";

    function create_fragment$1$(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "chevron-up" },
    		{
    			class: "svg-inline--fa fa-chevron-up fa-w-14"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 448 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M4.465 366.475l7.07 7.071c4.686 4.686 12.284 4.686 16.971 0L224 178.053l195.494 195.493c4.686 4.686 12.284 4.686 16.971 0l7.07-7.071c4.686-4.686 4.686-12.284 0-16.97l-211.05-211.051c-4.686-4.686-12.284-4.686-16.971 0L4.465 349.505c-4.687 4.686-4.687 12.284 0 16.97z");
    			add_location(path, file$1Z, 0, 210, 210);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1Z, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "chevron-up" },
    				{
    					class: "svg-inline--fa fa-chevron-up fa-w-14"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 448 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1$.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1_($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Angle_up_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Angle_up_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1_, create_fragment$1$, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Angle_up_svg_rollup_plugin",
    			options,
    			id: create_fragment$1$.name
    		});
    	}
    }

    var angleUp_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Angle_up_svg_rollup_plugin
    });

    var require$$3$1 = /*@__PURE__*/getAugmentedNamespace(angleUp_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/arrow-down.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1Y = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/arrow-down.svg.rollup-plugin.svelte";

    function create_fragment$1_(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "arrow-down" },
    		{
    			class: "svg-inline--fa fa-arrow-down fa-w-14"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 448 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M443.5 248.5l-7.1-7.1c-4.7-4.7-12.3-4.7-17 0L241 419.9V44c0-6.6-5.4-12-12-12h-10c-6.6 0-12 5.4-12 12v375.9L28.5 241.4c-4.7-4.7-12.3-4.7-17 0l-7.1 7.1c-4.7 4.7-4.7 12.3 0 17l211 211.1c4.7 4.7 12.3 4.7 17 0l211-211.1c4.8-4.8 4.8-12.3.1-17z");
    			add_location(path, file$1Y, 0, 210, 210);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1Y, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "arrow-down" },
    				{
    					class: "svg-inline--fa fa-arrow-down fa-w-14"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 448 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1_.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1Z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Arrow_down_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Arrow_down_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1Z, create_fragment$1_, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Arrow_down_svg_rollup_plugin",
    			options,
    			id: create_fragment$1_.name
    		});
    	}
    }

    var arrowDown_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Arrow_down_svg_rollup_plugin
    });

    var require$$4$1 = /*@__PURE__*/getAugmentedNamespace(arrowDown_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/arrow-left.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1X = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/arrow-left.svg.rollup-plugin.svelte";

    function create_fragment$1Z(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "arrow-left" },
    		{
    			class: "svg-inline--fa fa-arrow-left fa-w-14"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 448 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M231.536 475.535l7.071-7.07c4.686-4.686 4.686-12.284 0-16.971L60.113 273H436c6.627 0 12-5.373 12-12v-10c0-6.627-5.373-12-12-12H60.113L238.607 60.506c4.686-4.686 4.686-12.284 0-16.971l-7.071-7.07c-4.686-4.686-12.284-4.686-16.97 0L3.515 247.515c-4.686 4.686-4.686 12.284 0 16.971l211.051 211.05c4.686 4.686 12.284 4.686 16.97-.001z");
    			add_location(path, file$1X, 0, 210, 210);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1X, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "arrow-left" },
    				{
    					class: "svg-inline--fa fa-arrow-left fa-w-14"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 448 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1Z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1Y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Arrow_left_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Arrow_left_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1Y, create_fragment$1Z, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Arrow_left_svg_rollup_plugin",
    			options,
    			id: create_fragment$1Z.name
    		});
    	}
    }

    var arrowLeft_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Arrow_left_svg_rollup_plugin
    });

    var require$$5$1 = /*@__PURE__*/getAugmentedNamespace(arrowLeft_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/arrow-right.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1W = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/arrow-right.svg.rollup-plugin.svelte";

    function create_fragment$1Y(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "arrow-right" },
    		{
    			class: "svg-inline--fa fa-arrow-right fa-w-14"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 448 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M216.464 36.465l-7.071 7.07c-4.686 4.686-4.686 12.284 0 16.971L387.887 239H12c-6.627 0-12 5.373-12 12v10c0 6.627 5.373 12 12 12h375.887L209.393 451.494c-4.686 4.686-4.686 12.284 0 16.971l7.071 7.07c4.686 4.686 12.284 4.686 16.97 0l211.051-211.05c4.686-4.686 4.686-12.284 0-16.971L233.434 36.465c-4.686-4.687-12.284-4.687-16.97 0z");
    			add_location(path, file$1W, 0, 212, 212);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1W, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "arrow-right" },
    				{
    					class: "svg-inline--fa fa-arrow-right fa-w-14"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 448 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1Y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1X($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Arrow_right_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Arrow_right_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1X, create_fragment$1Y, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Arrow_right_svg_rollup_plugin",
    			options,
    			id: create_fragment$1Y.name
    		});
    	}
    }

    var arrowRight_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Arrow_right_svg_rollup_plugin
    });

    var require$$6$1 = /*@__PURE__*/getAugmentedNamespace(arrowRight_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/arrow-up.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1V = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/arrow-up.svg.rollup-plugin.svelte";

    function create_fragment$1X(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "arrow-up" },
    		{
    			class: "svg-inline--fa fa-arrow-up fa-w-14"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 448 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M4.465 263.536l7.07 7.071c4.686 4.686 12.284 4.686 16.971 0L207 92.113V468c0 6.627 5.373 12 12 12h10c6.627 0 12-5.373 12-12V92.113l178.494 178.493c4.686 4.686 12.284 4.686 16.971 0l7.07-7.071c4.686-4.686 4.686-12.284 0-16.97l-211.05-211.05c-4.686-4.686-12.284-4.686-16.971 0L4.465 246.566c-4.687 4.686-4.687 12.284 0 16.97z");
    			add_location(path, file$1V, 0, 206, 206);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1V, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "arrow-up" },
    				{
    					class: "svg-inline--fa fa-arrow-up fa-w-14"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 448 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1X.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1W($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Arrow_up_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Arrow_up_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1W, create_fragment$1X, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Arrow_up_svg_rollup_plugin",
    			options,
    			id: create_fragment$1X.name
    		});
    	}
    }

    var arrowUp_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Arrow_up_svg_rollup_plugin
    });

    var require$$7$1 = /*@__PURE__*/getAugmentedNamespace(arrowUp_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/article.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1U = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/article.svg.rollup-plugin.svelte";

    function create_fragment$1W(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ version: "1.1" },
    		{ id: "Layer_1" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{
    			"xmlns:xlink": "http://www.w3.org/1999/xlink"
    		},
    		{ x: "0px" },
    		{ y: "0px" },
    		{ viewBox: "0 0 51 47" },
    		{
    			style: "enable-background:new 0 0 51 47;"
    		},
    		{ "xml:space": "preserve" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M27,46.5h-4.5c-0.8,0-1.5-0.7-1.5-1.5s0.7-1.5,1.5-1.5H27c0.8,0,1.5,0.7,1.5,1.5S27.8,46.5,27,46.5z M15,46.5H2\n\tc-0.8,0-1.5-0.7-1.5-1.5s0.7-1.5,1.5-1.5h13c0.8,0,1.5,0.7,1.5,1.5S15.8,46.5,15,46.5z M49,35.4H2c-0.8,0-1.5-0.7-1.5-1.5\n\ts0.7-1.5,1.5-1.5h47c0.8,0,1.5,0.7,1.5,1.5S49.8,35.4,49,35.4z M49,24.3H33.5c-0.8,0-1.5-0.7-1.5-1.5s0.7-1.5,1.5-1.5H49\n\tc0.8,0,1.5,0.7,1.5,1.5S49.8,24.3,49,24.3z M22.7,24.3H3.3c-1.6,0-2.8-1.2-2.8-2.8V3c0-1.6,1.2-2.8,2.8-2.8h19.4\n\tc1.6,0,2.8,1.2,2.8,2.8v18.5C25.4,23.1,24.3,24.3,22.7,24.3z M3.5,21.3l18.9,0V3.3l-18.9,0L3.5,21.3z M49,13.2H33.5\n\tc-0.8,0-1.5-0.7-1.5-1.5s0.7-1.5,1.5-1.5H49c0.8,0,1.5,0.7,1.5,1.5S49.8,13.2,49,13.2z M49,3.3H33.5c-0.8,0-1.5-0.7-1.5-1.5\n\ts0.7-1.5,1.5-1.5H49c0.8,0,1.5,0.7,1.5,1.5S49.8,3.3,49,3.3z");
    			add_location(path, file$1U, 11, 2, 244);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1U, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ version: "1.1" },
    				{ id: "Layer_1" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{
    					"xmlns:xlink": "http://www.w3.org/1999/xlink"
    				},
    				{ x: "0px" },
    				{ y: "0px" },
    				{ viewBox: "0 0 51 47" },
    				{
    					style: "enable-background:new 0 0 51 47;"
    				},
    				{ "xml:space": "preserve" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1W.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1V($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Article_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Article_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1V, create_fragment$1W, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Article_svg_rollup_plugin",
    			options,
    			id: create_fragment$1W.name
    		});
    	}
    }

    var article_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Article_svg_rollup_plugin
    });

    var require$$8$1 = /*@__PURE__*/getAugmentedNamespace(article_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/at.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1T = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/at.svg.rollup-plugin.svelte";

    function create_fragment$1V(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ version: "1.1" },
    		{ id: "Layer_1" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{
    			"xmlns:xlink": "http://www.w3.org/1999/xlink"
    		},
    		{ x: "0px" },
    		{ y: "0px" },
    		{ viewBox: "0 0 16 16" },
    		{
    			style: "enable-background:new 0 0 16 16;"
    		},
    		{ "xml:space": "preserve" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "class", "st0");
    			attr_dev(path, "d", "M8,15.6c-4.2,0-7.6-3.4-7.6-7.6S3.8,0.4,8,0.4s7.6,3.4,7.6,7.6v1.3c0,1.3-1.1,2.4-2.4,2.4c-1,0-1.8-0.6-2.2-1.4\n\tc-0.7,0.9-1.7,1.4-2.9,1.4C6,11.7,4.3,10,4.3,8C4.3,6,6,4.3,8,4.3c1.1,0,2,0.5,2.7,1.2V4.8h1v4.5c0,0.8,0.6,1.4,1.4,1.4\n\ts1.4-0.6,1.4-1.4V8c0-3.6-2.9-6.6-6.6-6.6C4.4,1.4,1.4,4.4,1.4,8c0,3.6,2.9,6.6,6.6,6.6V15.6z M8,5.3C6.5,5.3,5.3,6.5,5.3,8\n\tc0,1.5,1.2,2.7,2.7,2.7c1.5,0,2.7-1.2,2.7-2.7C10.7,6.5,9.5,5.3,8,5.3z");
    			add_location(path, file$1T, 3, 0, 226);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1T, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ version: "1.1" },
    				{ id: "Layer_1" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{
    					"xmlns:xlink": "http://www.w3.org/1999/xlink"
    				},
    				{ x: "0px" },
    				{ y: "0px" },
    				{ viewBox: "0 0 16 16" },
    				{
    					style: "enable-background:new 0 0 16 16;"
    				},
    				{ "xml:space": "preserve" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1V.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1U($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('At_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class At_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1U, create_fragment$1V, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "At_svg_rollup_plugin",
    			options,
    			id: create_fragment$1V.name
    		});
    	}
    }

    var at_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': At_svg_rollup_plugin
    });

    var require$$9$1 = /*@__PURE__*/getAugmentedNamespace(at_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/bell.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1S = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/bell.svg.rollup-plugin.svelte";

    function create_fragment$1U(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "bell" },
    		{ class: "svg-inline--fa fa-bell fa-w-14" },
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 448 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M224 480c-17.66 0-32-14.38-32-32.03h-32c0 35.31 28.72 64.03 64 64.03s64-28.72 64-64.03h-32c0 17.65-14.34 32.03-32 32.03zm209.38-145.19c-27.96-26.62-49.34-54.48-49.34-148.91 0-79.59-63.39-144.5-144.04-152.35V16c0-8.84-7.16-16-16-16s-16 7.16-16 16v17.56C127.35 41.41 63.96 106.31 63.96 185.9c0 94.42-21.39 122.29-49.35 148.91-13.97 13.3-18.38 33.41-11.25 51.23C10.64 404.24 28.16 416 48 416h352c19.84 0 37.36-11.77 44.64-29.97 7.13-17.82 2.71-37.92-11.26-51.22zM400 384H48c-14.23 0-21.34-16.47-11.32-26.01 34.86-33.19 59.28-70.34 59.28-172.08C95.96 118.53 153.23 64 224 64c70.76 0 128.04 54.52 128.04 121.9 0 101.35 24.21 138.7 59.28 172.08C421.38 367.57 414.17 384 400 384z");
    			add_location(path, file$1S, 0, 198, 198);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1S, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "bell" },
    				{ class: "svg-inline--fa fa-bell fa-w-14" },
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 448 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1U.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1T($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Bell_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Bell_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1T, create_fragment$1U, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Bell_svg_rollup_plugin",
    			options,
    			id: create_fragment$1U.name
    		});
    	}
    }

    var bell_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Bell_svg_rollup_plugin
    });

    var require$$10$1 = /*@__PURE__*/getAugmentedNamespace(bell_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/bookmark-solid.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1R = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/bookmark-solid.svg.rollup-plugin.svelte";

    function create_fragment$1T(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fas" },
    		{ "data-icon": "bookmark" },
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 384 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M0 512V48C0 21.49 21.49 0 48 0h288c26.51 0 48 21.49 48 48v464L192 400 0 512z");
    			add_location(path, file$1R, 0, 163, 163);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1R, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fas" },
    				{ "data-icon": "bookmark" },
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 384 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1T.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1S($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Bookmark_solid_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Bookmark_solid_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1S, create_fragment$1T, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Bookmark_solid_svg_rollup_plugin",
    			options,
    			id: create_fragment$1T.name
    		});
    	}
    }

    var bookmarkSolid_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Bookmark_solid_svg_rollup_plugin
    });

    var require$$11$1 = /*@__PURE__*/getAugmentedNamespace(bookmarkSolid_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/bookmark.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1Q = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/bookmark.svg.rollup-plugin.svelte";

    function create_fragment$1S(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "bookmark" },
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 384 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M336 0H48C21.49 0 0 21.49 0 48v464l192-112 192 112V48c0-26.51-21.49-48-48-48zm16 456.287l-160-93.333-160 93.333V48c0-8.822 7.178-16 16-16h288c8.822 0 16 7.178 16 16v408.287z");
    			add_location(path, file$1Q, 0, 163, 163);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1Q, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "bookmark" },
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 384 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1S.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1R($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Bookmark_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Bookmark_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1R, create_fragment$1S, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Bookmark_svg_rollup_plugin",
    			options,
    			id: create_fragment$1S.name
    		});
    	}
    }

    var bookmark_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Bookmark_svg_rollup_plugin
    });

    var require$$12$1 = /*@__PURE__*/getAugmentedNamespace(bookmark_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/calendar.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1P = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/calendar.svg.rollup-plugin.svelte";

    function create_fragment$1R(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "calendar" },
    		{
    			class: "svg-inline--fa fa-calendar fa-w-14"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 448 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M400 64h-48V12c0-6.627-5.373-12-12-12h-8c-6.627 0-12 5.373-12 12v52H128V12c0-6.627-5.373-12-12-12h-8c-6.627 0-12 5.373-12 12v52H48C21.49 64 0 85.49 0 112v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zM48 96h352c8.822 0 16 7.178 16 16v48H32v-48c0-8.822 7.178-16 16-16zm352 384H48c-8.822 0-16-7.178-16-16V192h384v272c0 8.822-7.178 16-16 16z");
    			add_location(path, file$1P, 0, 206, 206);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1P, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "calendar" },
    				{
    					class: "svg-inline--fa fa-calendar fa-w-14"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 448 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1R.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1Q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Calendar_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Calendar_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1Q, create_fragment$1R, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Calendar_svg_rollup_plugin",
    			options,
    			id: create_fragment$1R.name
    		});
    	}
    }

    var calendar_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Calendar_svg_rollup_plugin
    });

    var require$$13$1 = /*@__PURE__*/getAugmentedNamespace(calendar_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/camera-solid.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1O = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/camera-solid.svg.rollup-plugin.svelte";

    function create_fragment$1Q(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fas" },
    		{ "data-icon": "camera" },
    		{
    			class: "svg-inline--fa fa-camera fa-w-16"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M512 144v288c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V144c0-26.5 21.5-48 48-48h88l12.3-32.9c7-18.7 24.9-31.1 44.9-31.1h125.5c20 0 37.9 12.4 44.9 31.1L376 96h88c26.5 0 48 21.5 48 48zM376 288c0-66.2-53.8-120-120-120s-120 53.8-120 120 53.8 120 120 120 120-53.8 120-120zm-32 0c0 48.5-39.5 88-88 88s-88-39.5-88-88 39.5-88 88-88 88 39.5 88 88z");
    			add_location(path, file$1O, 0, 202, 202);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1O, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fas" },
    				{ "data-icon": "camera" },
    				{
    					class: "svg-inline--fa fa-camera fa-w-16"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1Q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1P($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Camera_solid_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Camera_solid_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1P, create_fragment$1Q, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Camera_solid_svg_rollup_plugin",
    			options,
    			id: create_fragment$1Q.name
    		});
    	}
    }

    var cameraSolid_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Camera_solid_svg_rollup_plugin
    });

    var require$$14$1 = /*@__PURE__*/getAugmentedNamespace(cameraSolid_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/camera.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1N = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/camera.svg.rollup-plugin.svelte";

    function create_fragment$1P(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "camera" },
    		{
    			class: "svg-inline--fa fa-camera fa-w-16"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M324.3 64c3.3 0 6.3 2.1 7.5 5.2l22.1 58.8H464c8.8 0 16 7.2 16 16v288c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V144c0-8.8 7.2-16 16-16h110.2l20.1-53.6c2.3-6.2 8.3-10.4 15-10.4h131m0-32h-131c-20 0-37.9 12.4-44.9 31.1L136 96H48c-26.5 0-48 21.5-48 48v288c0 26.5 21.5 48 48 48h416c26.5 0 48-21.5 48-48V144c0-26.5-21.5-48-48-48h-88l-14.3-38c-5.8-15.7-20.7-26-37.4-26zM256 408c-66.2 0-120-53.8-120-120s53.8-120 120-120 120 53.8 120 120-53.8 120-120 120zm0-208c-48.5 0-88 39.5-88 88s39.5 88 88 88 88-39.5 88-88-39.5-88-88-88z");
    			add_location(path, file$1N, 0, 202, 202);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1N, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "camera" },
    				{
    					class: "svg-inline--fa fa-camera fa-w-16"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1P.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1O($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Camera_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Camera_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1O, create_fragment$1P, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Camera_svg_rollup_plugin",
    			options,
    			id: create_fragment$1P.name
    		});
    	}
    }

    var camera_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Camera_svg_rollup_plugin
    });

    var require$$15$1 = /*@__PURE__*/getAugmentedNamespace(camera_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/chart-bar.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1M = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/chart-bar.svg.rollup-plugin.svelte";

    function create_fragment$1O(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M424 352h16c4.4 0 8-3.6 8-8V104c0-4.4-3.6-8-8-8h-16c-4.4 0-8 3.6-8 8v240c0 4.4 3.6 8 8 8zm-96 0h16c4.4 0 8-3.6 8-8V200c0-4.4-3.6-8-8-8h-16c-4.4 0-8 3.6-8 8v144c0 4.4 3.6 8 8 8zm-192 0h16c4.4 0 8-3.6 8-8v-80c0-4.4-3.6-8-8-8h-16c-4.4 0-8 3.6-8 8v80c0 4.4 3.6 8 8 8zm96 0h16c4.4 0 8-3.6 8-8V136c0-4.4-3.6-8-8-8h-16c-4.4 0-8 3.6-8 8v208c0 4.4 3.6 8 8 8zm272 64H32V72c0-4.42-3.58-8-8-8H8c-4.42 0-8 3.58-8 8v360c0 8.84 7.16 16 16 16h488c4.42 0 8-3.58 8-8v-16c0-4.42-3.58-8-8-8z");
    			add_location(path, file$1M, 0, 95, 95);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1M, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1O.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1N($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Chart_bar_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Chart_bar_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1N, create_fragment$1O, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Chart_bar_svg_rollup_plugin",
    			options,
    			id: create_fragment$1O.name
    		});
    	}
    }

    var chartBar_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Chart_bar_svg_rollup_plugin
    });

    var require$$16$1 = /*@__PURE__*/getAugmentedNamespace(chartBar_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/check-circle-solid.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1L = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/check-circle-solid.svg.rollup-plugin.svelte";

    function create_fragment$1N(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fas" },
    		{ "data-icon": "check-circle" },
    		{
    			class: "svg-inline--fa fa-check-circle fa-w-16"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z");
    			add_location(path, file$1L, 0, 214, 214);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1L, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fas" },
    				{ "data-icon": "check-circle" },
    				{
    					class: "svg-inline--fa fa-check-circle fa-w-16"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1N.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1M($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Check_circle_solid_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Check_circle_solid_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1M, create_fragment$1N, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Check_circle_solid_svg_rollup_plugin",
    			options,
    			id: create_fragment$1N.name
    		});
    	}
    }

    var checkCircleSolid_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Check_circle_solid_svg_rollup_plugin
    });

    var require$$17$1 = /*@__PURE__*/getAugmentedNamespace(checkCircleSolid_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/check-circle.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1K = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/check-circle.svg.rollup-plugin.svelte";

    function create_fragment$1M(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "check-circle" },
    		{
    			class: "svg-inline--fa fa-check-circle fa-w-16"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M256 8C119.033 8 8 119.033 8 256s111.033 248 248 248 248-111.033 248-248S392.967 8 256 8zm0 464c-118.664 0-216-96.055-216-216 0-118.663 96.055-216 216-216 118.664 0 216 96.055 216 216 0 118.663-96.055 216-216 216zm141.63-274.961L217.15 376.071c-4.705 4.667-12.303 4.637-16.97-.068l-85.878-86.572c-4.667-4.705-4.637-12.303.068-16.97l8.52-8.451c4.705-4.667 12.303-4.637 16.97.068l68.976 69.533 163.441-162.13c4.705-4.667 12.303-4.637 16.97.068l8.451 8.52c4.668 4.705 4.637 12.303-.068 16.97z");
    			add_location(path, file$1K, 0, 214, 214);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1K, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "check-circle" },
    				{
    					class: "svg-inline--fa fa-check-circle fa-w-16"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1M.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1L($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Check_circle_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Check_circle_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1L, create_fragment$1M, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Check_circle_svg_rollup_plugin",
    			options,
    			id: create_fragment$1M.name
    		});
    	}
    }

    var checkCircle_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Check_circle_svg_rollup_plugin
    });

    var require$$18$1 = /*@__PURE__*/getAugmentedNamespace(checkCircle_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/check-square-solid.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1J = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/check-square-solid.svg.rollup-plugin.svelte";

    function create_fragment$1L(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fas" },
    		{ "data-icon": "check-square" },
    		{
    			class: "svg-inline--fa fa-check-square fa-w-14"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 448 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M400 480H48c-26.51 0-48-21.49-48-48V80c0-26.51 21.49-48 48-48h352c26.51 0 48 21.49 48 48v352c0 26.51-21.49 48-48 48zm-204.686-98.059l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.248-16.379-6.249-22.628 0L184 302.745l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.25 16.379 6.25 22.628.001z");
    			add_location(path, file$1J, 0, 214, 214);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1J, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fas" },
    				{ "data-icon": "check-square" },
    				{
    					class: "svg-inline--fa fa-check-square fa-w-14"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 448 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1K($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Check_square_solid_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Check_square_solid_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1K, create_fragment$1L, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Check_square_solid_svg_rollup_plugin",
    			options,
    			id: create_fragment$1L.name
    		});
    	}
    }

    var checkSquareSolid_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Check_square_solid_svg_rollup_plugin
    });

    var require$$19$1 = /*@__PURE__*/getAugmentedNamespace(checkSquareSolid_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/check-square.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1I = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/check-square.svg.rollup-plugin.svelte";

    function create_fragment$1K(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "check-square" },
    		{
    			class: "svg-inline--fa fa-check-square fa-w-14"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 448 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M400 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V80c0-26.51-21.49-48-48-48zm0 32c8.823 0 16 7.178 16 16v352c0 8.822-7.177 16-16 16H48c-8.822 0-16-7.178-16-16V80c0-8.822 7.178-16 16-16h352m-34.301 98.293l-8.451-8.52c-4.667-4.705-12.265-4.736-16.97-.068l-163.441 162.13-68.976-69.533c-4.667-4.705-12.265-4.736-16.97-.068l-8.52 8.451c-4.705 4.667-4.736 12.265-.068 16.97l85.878 86.572c4.667 4.705 12.265 4.736 16.97.068l180.48-179.032c4.704-4.667 4.735-12.265.068-16.97z");
    			add_location(path, file$1I, 0, 214, 214);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1I, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "check-square" },
    				{
    					class: "svg-inline--fa fa-check-square fa-w-14"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 448 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1J($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Check_square_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Check_square_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1J, create_fragment$1K, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Check_square_svg_rollup_plugin",
    			options,
    			id: create_fragment$1K.name
    		});
    	}
    }

    var checkSquare_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Check_square_svg_rollup_plugin
    });

    var require$$20 = /*@__PURE__*/getAugmentedNamespace(checkSquare_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/check.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1H = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/check.svg.rollup-plugin.svelte";

    function create_fragment$1J(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "check" },
    		{ class: "svg-inline--fa fa-check fa-w-14" },
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 448 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M413.505 91.951L133.49 371.966l-98.995-98.995c-4.686-4.686-12.284-4.686-16.971 0L6.211 284.284c-4.686 4.686-4.686 12.284 0 16.971l118.794 118.794c4.686 4.686 12.284 4.686 16.971 0l299.813-299.813c4.686-4.686 4.686-12.284 0-16.971l-11.314-11.314c-4.686-4.686-12.284-4.686-16.97 0z");
    			add_location(path, file$1H, 0, 200, 200);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1H, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "check" },
    				{ class: "svg-inline--fa fa-check fa-w-14" },
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 448 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1I($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Check_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Check_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1I, create_fragment$1J, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Check_svg_rollup_plugin",
    			options,
    			id: create_fragment$1J.name
    		});
    	}
    }

    var check_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Check_svg_rollup_plugin
    });

    var require$$21 = /*@__PURE__*/getAugmentedNamespace(check_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/circle-notch.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1G = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/circle-notch.svg.rollup-plugin.svelte";

    function create_fragment$1I(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "circle-notch" },
    		{
    			class: "svg-inline--fa fa-circle-notch fa-w-16"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M288 24.103v8.169a11.995 11.995 0 0 0 9.698 11.768C396.638 63.425 472 150.461 472 256c0 118.663-96.055 216-216 216-118.663 0-216-96.055-216-216 0-104.534 74.546-192.509 174.297-211.978A11.993 11.993 0 0 0 224 32.253v-8.147c0-7.523-6.845-13.193-14.237-11.798C94.472 34.048 7.364 135.575 8.004 257.332c.72 137.052 111.477 246.956 248.531 246.667C393.255 503.711 504 392.789 504 256c0-121.187-86.924-222.067-201.824-243.704C294.807 10.908 288 16.604 288 24.103z");
    			add_location(path, file$1G, 0, 214, 214);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1G, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "circle-notch" },
    				{
    					class: "svg-inline--fa fa-circle-notch fa-w-16"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1H($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Circle_notch_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Circle_notch_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1H, create_fragment$1I, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Circle_notch_svg_rollup_plugin",
    			options,
    			id: create_fragment$1I.name
    		});
    	}
    }

    var circleNotch_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Circle_notch_svg_rollup_plugin
    });

    var require$$22 = /*@__PURE__*/getAugmentedNamespace(circleNotch_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/circle-solid.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1F = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/circle-solid.svg.rollup-plugin.svelte";

    function create_fragment$1H(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fas" },
    		{ "data-icon": "circle" },
    		{
    			class: "svg-inline--fa fa-circle fa-w-16"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8z");
    			add_location(path, file$1F, 0, 202, 202);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1F, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fas" },
    				{ "data-icon": "circle" },
    				{
    					class: "svg-inline--fa fa-circle fa-w-16"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1G($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Circle_solid_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Circle_solid_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1G, create_fragment$1H, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Circle_solid_svg_rollup_plugin",
    			options,
    			id: create_fragment$1H.name
    		});
    	}
    }

    var circleSolid_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Circle_solid_svg_rollup_plugin
    });

    var require$$23 = /*@__PURE__*/getAugmentedNamespace(circleSolid_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/circle.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1E = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/circle.svg.rollup-plugin.svelte";

    function create_fragment$1G(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "circle" },
    		{
    			class: "svg-inline--fa fa-circle fa-w-16"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm216 248c0 118.7-96.1 216-216 216-118.7 0-216-96.1-216-216 0-118.7 96.1-216 216-216 118.7 0 216 96.1 216 216z");
    			add_location(path, file$1E, 0, 202, 202);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1E, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "circle" },
    				{
    					class: "svg-inline--fa fa-circle fa-w-16"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1F($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Circle_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Circle_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1F, create_fragment$1G, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Circle_svg_rollup_plugin",
    			options,
    			id: create_fragment$1G.name
    		});
    	}
    }

    var circle_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Circle_svg_rollup_plugin
    });

    var require$$24 = /*@__PURE__*/getAugmentedNamespace(circle_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/clock.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1D = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/clock.svg.rollup-plugin.svelte";

    function create_fragment$1F(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "clock" },
    		{ class: "svg-inline--fa fa-clock fa-w-16" },
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm216 248c0 118.7-96.1 216-216 216-118.7 0-216-96.1-216-216 0-118.7 96.1-216 216-216 118.7 0 216 96.1 216 216zm-148.9 88.3l-81.2-59c-3.1-2.3-4.9-5.9-4.9-9.7V116c0-6.6 5.4-12 12-12h14c6.6 0 12 5.4 12 12v146.3l70.5 51.3c5.4 3.9 6.5 11.4 2.6 16.8l-8.2 11.3c-3.9 5.3-11.4 6.5-16.8 2.6z");
    			add_location(path, file$1D, 0, 200, 200);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1D, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "clock" },
    				{ class: "svg-inline--fa fa-clock fa-w-16" },
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1E($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Clock_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Clock_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1E, create_fragment$1F, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Clock_svg_rollup_plugin",
    			options,
    			id: create_fragment$1F.name
    		});
    	}
    }

    var clock_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Clock_svg_rollup_plugin
    });

    var require$$25 = /*@__PURE__*/getAugmentedNamespace(clock_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/cog-solid.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1C = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/cog-solid.svg.rollup-plugin.svelte";

    function create_fragment$1E(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fas" },
    		{ "data-icon": "cog" },
    		{ class: "svg-inline--fa fa-cog fa-w-16" },
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M487.4 315.7l-42.6-24.6c4.3-23.2 4.3-47 0-70.2l42.6-24.6c4.9-2.8 7.1-8.6 5.5-14-11.1-35.6-30-67.8-54.7-94.6-3.8-4.1-10-5.1-14.8-2.3L380.8 110c-17.9-15.4-38.5-27.3-60.8-35.1V25.8c0-5.6-3.9-10.5-9.4-11.7-36.7-8.2-74.3-7.8-109.2 0-5.5 1.2-9.4 6.1-9.4 11.7V75c-22.2 7.9-42.8 19.8-60.8 35.1L88.7 85.5c-4.9-2.8-11-1.9-14.8 2.3-24.7 26.7-43.6 58.9-54.7 94.6-1.7 5.4.6 11.2 5.5 14L67.3 221c-4.3 23.2-4.3 47 0 70.2l-42.6 24.6c-4.9 2.8-7.1 8.6-5.5 14 11.1 35.6 30 67.8 54.7 94.6 3.8 4.1 10 5.1 14.8 2.3l42.6-24.6c17.9 15.4 38.5 27.3 60.8 35.1v49.2c0 5.6 3.9 10.5 9.4 11.7 36.7 8.2 74.3 7.8 109.2 0 5.5-1.2 9.4-6.1 9.4-11.7v-49.2c22.2-7.9 42.8-19.8 60.8-35.1l42.6 24.6c4.9 2.8 11 1.9 14.8-2.3 24.7-26.7 43.6-58.9 54.7-94.6 1.5-5.5-.7-11.3-5.6-14.1zM256 336c-44.1 0-80-35.9-80-80s35.9-80 80-80 80 35.9 80 80-35.9 80-80 80z");
    			add_location(path, file$1C, 0, 196, 196);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1C, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fas" },
    				{ "data-icon": "cog" },
    				{ class: "svg-inline--fa fa-cog fa-w-16" },
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1D($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Cog_solid_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Cog_solid_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1D, create_fragment$1E, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Cog_solid_svg_rollup_plugin",
    			options,
    			id: create_fragment$1E.name
    		});
    	}
    }

    var cogSolid_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Cog_solid_svg_rollup_plugin
    });

    var require$$26 = /*@__PURE__*/getAugmentedNamespace(cogSolid_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/cog.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1B = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/cog.svg.rollup-plugin.svelte";

    function create_fragment$1D(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "cog" },
    		{ class: "svg-inline--fa fa-cog fa-w-16" },
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M482.696 299.276l-32.61-18.827a195.168 195.168 0 0 0 0-48.899l32.61-18.827c9.576-5.528 14.195-16.902 11.046-27.501-11.214-37.749-31.175-71.728-57.535-99.595-7.634-8.07-19.817-9.836-29.437-4.282l-32.562 18.798a194.125 194.125 0 0 0-42.339-24.48V38.049c0-11.13-7.652-20.804-18.484-23.367-37.644-8.909-77.118-8.91-114.77 0-10.831 2.563-18.484 12.236-18.484 23.367v37.614a194.101 194.101 0 0 0-42.339 24.48L105.23 81.345c-9.621-5.554-21.804-3.788-29.437 4.282-26.36 27.867-46.321 61.847-57.535 99.595-3.149 10.599 1.47 21.972 11.046 27.501l32.61 18.827a195.168 195.168 0 0 0 0 48.899l-32.61 18.827c-9.576 5.528-14.195 16.902-11.046 27.501 11.214 37.748 31.175 71.728 57.535 99.595 7.634 8.07 19.817 9.836 29.437 4.283l32.562-18.798a194.08 194.08 0 0 0 42.339 24.479v37.614c0 11.13 7.652 20.804 18.484 23.367 37.645 8.909 77.118 8.91 114.77 0 10.831-2.563 18.484-12.236 18.484-23.367v-37.614a194.138 194.138 0 0 0 42.339-24.479l32.562 18.798c9.62 5.554 21.803 3.788 29.437-4.283 26.36-27.867 46.321-61.847 57.535-99.595 3.149-10.599-1.47-21.972-11.046-27.501zm-65.479 100.461l-46.309-26.74c-26.988 23.071-36.559 28.876-71.039 41.059v53.479a217.145 217.145 0 0 1-87.738 0v-53.479c-33.621-11.879-43.355-17.395-71.039-41.059l-46.309 26.74c-19.71-22.09-34.689-47.989-43.929-75.958l46.329-26.74c-6.535-35.417-6.538-46.644 0-82.079l-46.329-26.74c9.24-27.969 24.22-53.869 43.929-75.969l46.309 26.76c27.377-23.434 37.063-29.065 71.039-41.069V44.464a216.79 216.79 0 0 1 87.738 0v53.479c33.978 12.005 43.665 17.637 71.039 41.069l46.309-26.76c19.709 22.099 34.689 47.999 43.929 75.969l-46.329 26.74c6.536 35.426 6.538 46.644 0 82.079l46.329 26.74c-9.24 27.968-24.219 53.868-43.929 75.957zM256 160c-52.935 0-96 43.065-96 96s43.065 96 96 96 96-43.065 96-96-43.065-96-96-96zm0 160c-35.29 0-64-28.71-64-64s28.71-64 64-64 64 28.71 64 64-28.71 64-64 64z");
    			add_location(path, file$1B, 0, 196, 196);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1B, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "cog" },
    				{ class: "svg-inline--fa fa-cog fa-w-16" },
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1C($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Cog_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Cog_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1C, create_fragment$1D, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Cog_svg_rollup_plugin",
    			options,
    			id: create_fragment$1D.name
    		});
    	}
    }

    var cog_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Cog_svg_rollup_plugin
    });

    var require$$27 = /*@__PURE__*/getAugmentedNamespace(cog_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/comment-solid.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1A = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/comment-solid.svg.rollup-plugin.svelte";

    function create_fragment$1C(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fas" },
    		{ "data-icon": "comment" },
    		{
    			class: "svg-inline--fa fa-comment fa-w-16"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M256 32C114.6 32 0 125.1 0 240c0 49.6 21.4 95 57 130.7C44.5 421.1 2.7 466 2.2 466.5c-2.2 2.3-2.8 5.7-1.5 8.7S4.8 480 8 480c66.3 0 116-31.8 140.6-51.4 32.7 12.3 69 19.4 107.4 19.4 141.4 0 256-93.1 256-208S397.4 32 256 32z");
    			add_location(path, file$1A, 0, 204, 204);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1A, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fas" },
    				{ "data-icon": "comment" },
    				{
    					class: "svg-inline--fa fa-comment fa-w-16"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1B($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Comment_solid_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Comment_solid_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1B, create_fragment$1C, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Comment_solid_svg_rollup_plugin",
    			options,
    			id: create_fragment$1C.name
    		});
    	}
    }

    var commentSolid_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Comment_solid_svg_rollup_plugin
    });

    var require$$28 = /*@__PURE__*/getAugmentedNamespace(commentSolid_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/comment.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1z = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/comment.svg.rollup-plugin.svelte";

    function create_fragment$1B(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "comment" },
    		{
    			class: "svg-inline--fa fa-comment fa-w-16"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M256 64c123.5 0 224 79 224 176S379.5 416 256 416c-28.3 0-56.3-4.3-83.2-12.8l-15.2-4.8-13 9.2c-23 16.3-58.5 35.3-102.6 39.6 12-15.1 29.8-40.4 40.8-69.6l7.1-18.7-13.7-14.6C47.3 313.7 32 277.6 32 240c0-97 100.5-176 224-176m0-32C114.6 32 0 125.1 0 240c0 47.6 19.9 91.2 52.9 126.3C38 405.7 7 439.1 6.5 439.5c-6.6 7-8.4 17.2-4.6 26 3.8 8.8 12.4 14.5 22 14.5 61.5 0 110-25.7 139.1-46.3 29 9.1 60.2 14.3 93 14.3 141.4 0 256-93.1 256-208S397.4 32 256 32z");
    			add_location(path, file$1z, 0, 204, 204);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1z, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "comment" },
    				{
    					class: "svg-inline--fa fa-comment fa-w-16"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1A($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Comment_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Comment_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1A, create_fragment$1B, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Comment_svg_rollup_plugin",
    			options,
    			id: create_fragment$1B.name
    		});
    	}
    }

    var comment_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Comment_svg_rollup_plugin
    });

    var require$$29 = /*@__PURE__*/getAugmentedNamespace(comment_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/comments-solid.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1y = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/comments-solid.svg.rollup-plugin.svelte";

    function create_fragment$1A(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fas" },
    		{ "data-icon": "comments" },
    		{
    			class: "svg-inline--fa fa-comments fa-w-18"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 576 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M416 192c0-88.4-93.1-160-208-160S0 103.6 0 192c0 34.3 14.1 65.9 38 92-13.4 30.2-35.5 54.2-35.8 54.5-2.2 2.3-2.8 5.7-1.5 8.7S4.8 352 8 352c36.6 0 66.9-12.3 88.7-25 32.2 15.7 70.3 25 111.3 25 114.9 0 208-71.6 208-160zm122 220c23.9-26 38-57.7 38-92 0-66.9-53.5-124.2-129.3-148.1.9 6.6 1.3 13.3 1.3 20.1 0 105.9-107.7 192-240 192-10.8 0-21.3-.8-31.7-1.9C207.8 439.6 281.8 480 368 480c41 0 79.1-9.2 111.3-25 21.8 12.7 52.1 25 88.7 25 3.2 0 6.1-1.9 7.3-4.8 1.3-2.9.7-6.3-1.5-8.7-.3-.3-22.4-24.2-35.8-54.5z");
    			add_location(path, file$1y, 0, 206, 206);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1y, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fas" },
    				{ "data-icon": "comments" },
    				{
    					class: "svg-inline--fa fa-comments fa-w-18"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 576 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Comments_solid_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Comments_solid_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1z, create_fragment$1A, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Comments_solid_svg_rollup_plugin",
    			options,
    			id: create_fragment$1A.name
    		});
    	}
    }

    var commentsSolid_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Comments_solid_svg_rollup_plugin
    });

    var require$$30 = /*@__PURE__*/getAugmentedNamespace(commentsSolid_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/creditcard-solid.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1x = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/creditcard-solid.svg.rollup-plugin.svelte";

    function create_fragment$1z(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fas" },
    		{ "data-icon": "credit-card" },
    		{
    			class: "svg-inline--fa fa-credit-card fa-w-18"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 576 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M0 432c0 26.5 21.5 48 48 48h480c26.5 0 48-21.5 48-48V256H0v176zm192-68c0-6.6 5.4-12 12-12h136c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12H204c-6.6 0-12-5.4-12-12v-40zm-128 0c0-6.6 5.4-12 12-12h72c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12H76c-6.6 0-12-5.4-12-12v-40zM576 80v48H0V80c0-26.5 21.5-48 48-48h480c26.5 0 48 21.5 48 48z");
    			add_location(path, file$1x, 0, 212, 212);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1x, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fas" },
    				{ "data-icon": "credit-card" },
    				{
    					class: "svg-inline--fa fa-credit-card fa-w-18"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 576 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Creditcard_solid_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Creditcard_solid_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1y, create_fragment$1z, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Creditcard_solid_svg_rollup_plugin",
    			options,
    			id: create_fragment$1z.name
    		});
    	}
    }

    var creditcardSolid_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Creditcard_solid_svg_rollup_plugin
    });

    var require$$31 = /*@__PURE__*/getAugmentedNamespace(creditcardSolid_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/creditcard.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1w = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/creditcard.svg.rollup-plugin.svelte";

    function create_fragment$1y(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "credit-card" },
    		{
    			class: "svg-inline--fa fa-credit-card fa-w-18"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 576 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M528 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h480c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zM48 64h480c8.8 0 16 7.2 16 16v48H32V80c0-8.8 7.2-16 16-16zm480 384H48c-8.8 0-16-7.2-16-16V224h512v208c0 8.8-7.2 16-16 16zm-336-84v8c0 6.6-5.4 12-12 12h-72c-6.6 0-12-5.4-12-12v-8c0-6.6 5.4-12 12-12h72c6.6 0 12 5.4 12 12zm192 0v8c0 6.6-5.4 12-12 12H236c-6.6 0-12-5.4-12-12v-8c0-6.6 5.4-12 12-12h136c6.6 0 12 5.4 12 12z");
    			add_location(path, file$1w, 0, 212, 212);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1w, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "credit-card" },
    				{
    					class: "svg-inline--fa fa-credit-card fa-w-18"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 576 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1x($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Creditcard_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Creditcard_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1x, create_fragment$1y, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Creditcard_svg_rollup_plugin",
    			options,
    			id: create_fragment$1y.name
    		});
    	}
    }

    var creditcard_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Creditcard_svg_rollup_plugin
    });

    var require$$32 = /*@__PURE__*/getAugmentedNamespace(creditcard_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/desktop.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1v = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/desktop.svg.rollup-plugin.svelte";

    function create_fragment$1x(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "desktop" },
    		{
    			class: "svg-inline--fa fa-desktop fa-w-18"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 576 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M528 0H48C21.5 0 0 21.5 0 48v288c0 26.5 21.5 48 48 48h192l-24 96h-72c-8.8 0-16 7.2-16 16s7.2 16 16 16h288c8.8 0 16-7.2 16-16s-7.2-16-16-16h-72l-24-96h192c26.5 0 48-21.5 48-48V48c0-26.5-21.5-48-48-48zM249 480l16-64h46l16 64h-78zm295-144c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V48c0-8.8 7.2-16 16-16h480c8.8 0 16 7.2 16 16v288z");
    			add_location(path, file$1v, 0, 204, 204);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1v, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "desktop" },
    				{
    					class: "svg-inline--fa fa-desktop fa-w-18"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 576 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1w($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Desktop_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Desktop_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1w, create_fragment$1x, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Desktop_svg_rollup_plugin",
    			options,
    			id: create_fragment$1x.name
    		});
    	}
    }

    var desktop_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Desktop_svg_rollup_plugin
    });

    var require$$33 = /*@__PURE__*/getAugmentedNamespace(desktop_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/dot-circle.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1u = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/dot-circle.svg.rollup-plugin.svelte";

    function create_fragment$1w(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ version: "1.1" },
    		{ id: "Lag_1" },
    		{ focusable: "false" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{
    			"xmlns:xlink": "http://www.w3.org/1999/xlink"
    		},
    		{ x: "0px" },
    		{ y: "0px" },
    		{ viewBox: "0 0 512 512" },
    		{
    			style: "enable-background:new 0 0 512 512;"
    		},
    		{ "xml:space": "preserve" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M256,8C119,8,8,119,8,256s111,248,248,248s248-111,248-248S393,8,256,8z M256,472c-118.7,0-216-96.1-216-216\n\tc0-118.7,96.1-216,216-216c118.7,0,216,96.1,216,216C472,374.7,375.9,472,256,472z M256,176c-44.2,0-80,35.8-80,80s35.8,80,80,80\n\ts80-35.8,80-80S300.2,176,256,176z");
    			add_location(path, file$1u, 2, 0, 245);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1u, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ version: "1.1" },
    				{ id: "Lag_1" },
    				{ focusable: "false" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{
    					"xmlns:xlink": "http://www.w3.org/1999/xlink"
    				},
    				{ x: "0px" },
    				{ y: "0px" },
    				{ viewBox: "0 0 512 512" },
    				{
    					style: "enable-background:new 0 0 512 512;"
    				},
    				{ "xml:space": "preserve" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1v($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Dot_circle_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Dot_circle_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1v, create_fragment$1w, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Dot_circle_svg_rollup_plugin",
    			options,
    			id: create_fragment$1w.name
    		});
    	}
    }

    var dotCircle_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Dot_circle_svg_rollup_plugin
    });

    var require$$34 = /*@__PURE__*/getAugmentedNamespace(dotCircle_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/ebplus-circle-solid.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1t = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/ebplus-circle-solid.svg.rollup-plugin.svelte";

    function create_fragment$1v(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ version: "1.1" },
    		{ id: "Layer_1" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{
    			"xmlns:xlink": "http://www.w3.org/1999/xlink"
    		},
    		{ x: "0px" },
    		{ y: "0px" },
    		{ viewBox: "0 0 72.8 72.8" },
    		{
    			style: "enable-background:new 0 0 72.8 72.8;"
    		},
    		{ "xml:space": "preserve" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M36.4,0C16.3,0,0,16.3,0,36.4s16.3,36.4,36.4,36.4s36.4-16.3,36.4-36.4S56.5,0,36.4,0z M56.5,41.9H42.2v14.2\n\tH30.6V41.9H16.3V31.4h14.2V17.2h11.7v14.1h14.2V41.9z");
    			add_location(path, file$1t, 11, 2, 252);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1t, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ version: "1.1" },
    				{ id: "Layer_1" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{
    					"xmlns:xlink": "http://www.w3.org/1999/xlink"
    				},
    				{ x: "0px" },
    				{ y: "0px" },
    				{ viewBox: "0 0 72.8 72.8" },
    				{
    					style: "enable-background:new 0 0 72.8 72.8;"
    				},
    				{ "xml:space": "preserve" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1u($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Ebplus_circle_solid_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Ebplus_circle_solid_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1u, create_fragment$1v, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Ebplus_circle_solid_svg_rollup_plugin",
    			options,
    			id: create_fragment$1v.name
    		});
    	}
    }

    var ebplusCircleSolid_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Ebplus_circle_solid_svg_rollup_plugin
    });

    var require$$35 = /*@__PURE__*/getAugmentedNamespace(ebplusCircleSolid_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/ebplus.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1s = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/ebplus.svg.rollup-plugin.svelte";

    function create_fragment$1u(ctx) {
    	let svg;
    	let g1;
    	let g0;
    	let path;

    	let svg_levels = [
    		{ version: "1.1" },
    		{ id: "Layer_1" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{
    			"xmlns:xlink": "http://www.w3.org/1999/xlink"
    		},
    		{ x: "0px" },
    		{ y: "0px" },
    		{ viewBox: "0 122.1 595.3 597.4" },
    		{
    			"enable-background": "new 0 122.1 595.3 597.4"
    		},
    		{ "xml:space": "preserve" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			g1 = svg_element("g");
    			g0 = svg_element("g");
    			path = svg_element("path");
    			attr_dev(path, "d", "M237.4,122.1h120.5v238.5h237.4V481H357.9v238.5H237.4V481H0V360.5h237.4V122.1z");
    			add_location(path, file$1s, 13, 6, 275);
    			add_location(g0, file$1s, 12, 4, 265);
    			add_location(g1, file$1s, 11, 2, 257);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1s, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, g1);
    			append_dev(g1, g0);
    			append_dev(g0, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ version: "1.1" },
    				{ id: "Layer_1" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{
    					"xmlns:xlink": "http://www.w3.org/1999/xlink"
    				},
    				{ x: "0px" },
    				{ y: "0px" },
    				{ viewBox: "0 122.1 595.3 597.4" },
    				{
    					"enable-background": "new 0 122.1 595.3 597.4"
    				},
    				{ "xml:space": "preserve" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1t($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Ebplus_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Ebplus_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1t, create_fragment$1u, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Ebplus_svg_rollup_plugin",
    			options,
    			id: create_fragment$1u.name
    		});
    	}
    }

    var ebplus_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Ebplus_svg_rollup_plugin
    });

    var require$$36 = /*@__PURE__*/getAugmentedNamespace(ebplus_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/edit.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1r = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/edit.svg.rollup-plugin.svelte";

    function create_fragment$1t(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "edit" },
    		{ class: "svg-inline--fa fa-edit fa-w-18" },
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 576 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M417.8 315.5l20-20c3.8-3.8 10.2-1.1 10.2 4.2V464c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h292.3c5.3 0 8 6.5 4.2 10.2l-20 20c-1.1 1.1-2.7 1.8-4.2 1.8H48c-8.8 0-16 7.2-16 16v352c0 8.8 7.2 16 16 16h352c8.8 0 16-7.2 16-16V319.7c0-1.6.6-3.1 1.8-4.2zm145.9-191.2L251.2 436.8l-99.9 11.1c-13.4 1.5-24.7-9.8-23.2-23.2l11.1-99.9L451.7 12.3c16.4-16.4 43-16.4 59.4 0l52.6 52.6c16.4 16.4 16.4 43 0 59.4zm-93.6 48.4L403.4 106 169.8 339.5l-8.3 75.1 75.1-8.3 233.5-233.6zm71-85.2l-52.6-52.6c-3.8-3.8-10.2-4-14.1 0L426 83.3l66.7 66.7 48.4-48.4c3.9-3.8 3.9-10.2 0-14.1z");
    			add_location(path, file$1r, 0, 198, 198);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1r, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "edit" },
    				{ class: "svg-inline--fa fa-edit fa-w-18" },
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 576 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1s($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Edit_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Edit_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1s, create_fragment$1t, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Edit_svg_rollup_plugin",
    			options,
    			id: create_fragment$1t.name
    		});
    	}
    }

    var edit_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Edit_svg_rollup_plugin
    });

    var require$$37 = /*@__PURE__*/getAugmentedNamespace(edit_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/envelope.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1q = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/envelope.svg.rollup-plugin.svelte";

    function create_fragment$1s(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "envelope" },
    		{
    			class: "svg-inline--fa fa-envelope fa-w-16"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M464 64H48C21.5 64 0 85.5 0 112v288c0 26.5 21.5 48 48 48h416c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM48 96h416c8.8 0 16 7.2 16 16v41.4c-21.9 18.5-53.2 44-150.6 121.3-16.9 13.4-50.2 45.7-73.4 45.3-23.2.4-56.6-31.9-73.4-45.3C85.2 197.4 53.9 171.9 32 153.4V112c0-8.8 7.2-16 16-16zm416 320H48c-8.8 0-16-7.2-16-16V195c22.8 18.7 58.8 47.6 130.7 104.7 20.5 16.4 56.7 52.5 93.3 52.3 36.4.3 72.3-35.5 93.3-52.3 71.9-57.1 107.9-86 130.7-104.7v205c0 8.8-7.2 16-16 16z");
    			add_location(path, file$1q, 0, 206, 206);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1q, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "envelope" },
    				{
    					class: "svg-inline--fa fa-envelope fa-w-16"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1r($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Envelope_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Envelope_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1r, create_fragment$1s, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Envelope_svg_rollup_plugin",
    			options,
    			id: create_fragment$1s.name
    		});
    	}
    }

    var envelope_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Envelope_svg_rollup_plugin
    });

    var require$$38 = /*@__PURE__*/getAugmentedNamespace(envelope_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/exclamation-circle-solid.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1p = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/exclamation-circle-solid.svg.rollup-plugin.svelte";

    function create_fragment$1r(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fas" },
    		{ "data-icon": "exclamation-circle" },
    		{
    			class: "svg-inline--fa fa-exclamation-circle fa-w-16"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z");
    			add_location(path, file$1p, 0, 226, 226);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1p, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fas" },
    				{ "data-icon": "exclamation-circle" },
    				{
    					class: "svg-inline--fa fa-exclamation-circle fa-w-16"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Exclamation_circle_solid_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Exclamation_circle_solid_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1q, create_fragment$1r, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Exclamation_circle_solid_svg_rollup_plugin",
    			options,
    			id: create_fragment$1r.name
    		});
    	}
    }

    var exclamationCircleSolid_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Exclamation_circle_solid_svg_rollup_plugin
    });

    var require$$39 = /*@__PURE__*/getAugmentedNamespace(exclamationCircleSolid_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/exclamation-circle.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1o = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/exclamation-circle.svg.rollup-plugin.svelte";

    function create_fragment$1q(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "exclamation-circle" },
    		{
    			class: "svg-inline--fa fa-exclamation-circle fa-w-16"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M256 40c118.621 0 216 96.075 216 216 0 119.291-96.61 216-216 216-119.244 0-216-96.562-216-216 0-119.203 96.602-216 216-216m0-32C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm-11.49 120h22.979c6.823 0 12.274 5.682 11.99 12.5l-7 168c-.268 6.428-5.556 11.5-11.99 11.5h-8.979c-6.433 0-11.722-5.073-11.99-11.5l-7-168c-.283-6.818 5.167-12.5 11.99-12.5zM256 340c-15.464 0-28 12.536-28 28s12.536 28 28 28 28-12.536 28-28-12.536-28-28-28z");
    			add_location(path, file$1o, 0, 226, 226);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1o, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "exclamation-circle" },
    				{
    					class: "svg-inline--fa fa-exclamation-circle fa-w-16"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1p($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Exclamation_circle_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Exclamation_circle_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1p, create_fragment$1q, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Exclamation_circle_svg_rollup_plugin",
    			options,
    			id: create_fragment$1q.name
    		});
    	}
    }

    var exclamationCircle_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Exclamation_circle_svg_rollup_plugin
    });

    var require$$40 = /*@__PURE__*/getAugmentedNamespace(exclamationCircle_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/exclamation-triangle-solid.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1n = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/exclamation-triangle-solid.svg.rollup-plugin.svelte";

    function create_fragment$1p(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fas" },
    		{ "data-icon": "exclamation-triangle" },
    		{
    			class: "svg-inline--fa fa-exclamation-triangle fa-w-18"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 576 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z");
    			add_location(path, file$1n, 0, 230, 230);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1n, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fas" },
    				{ "data-icon": "exclamation-triangle" },
    				{
    					class: "svg-inline--fa fa-exclamation-triangle fa-w-18"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 576 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1o($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Exclamation_triangle_solid_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Exclamation_triangle_solid_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1o, create_fragment$1p, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Exclamation_triangle_solid_svg_rollup_plugin",
    			options,
    			id: create_fragment$1p.name
    		});
    	}
    }

    var exclamationTriangleSolid_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Exclamation_triangle_solid_svg_rollup_plugin
    });

    var require$$41 = /*@__PURE__*/getAugmentedNamespace(exclamationTriangleSolid_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/exclamation-triangle.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1m = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/exclamation-triangle.svg.rollup-plugin.svelte";

    function create_fragment$1o(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "exclamation-triangle" },
    		{
    			class: "svg-inline--fa fa-exclamation-triangle fa-w-18"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 576 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M270.2 160h35.5c3.4 0 6.1 2.8 6 6.2l-7.5 196c-.1 3.2-2.8 5.8-6 5.8h-20.5c-3.2 0-5.9-2.5-6-5.8l-7.5-196c-.1-3.4 2.6-6.2 6-6.2zM288 388c-15.5 0-28 12.5-28 28s12.5 28 28 28 28-12.5 28-28-12.5-28-28-28zm281.5 52L329.6 24c-18.4-32-64.7-32-83.2 0L6.5 440c-18.4 31.9 4.6 72 41.6 72H528c36.8 0 60-40 41.5-72zM528 480H48c-12.3 0-20-13.3-13.9-24l240-416c6.1-10.6 21.6-10.7 27.7 0l240 416c6.2 10.6-1.5 24-13.8 24z");
    			add_location(path, file$1m, 0, 230, 230);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1m, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "exclamation-triangle" },
    				{
    					class: "svg-inline--fa fa-exclamation-triangle fa-w-18"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 576 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1n($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Exclamation_triangle_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Exclamation_triangle_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1n, create_fragment$1o, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Exclamation_triangle_svg_rollup_plugin",
    			options,
    			id: create_fragment$1o.name
    		});
    	}
    }

    var exclamationTriangle_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Exclamation_triangle_svg_rollup_plugin
    });

    var require$$42 = /*@__PURE__*/getAugmentedNamespace(exclamationTriangle_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/expand.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1l = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/expand.svg.rollup-plugin.svelte";

    function create_fragment$1n(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "expand" },
    		{
    			class: "svg-inline--fa fa-expand fa-w-14"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 448 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M0 180V56c0-13.3 10.7-24 24-24h124c6.6 0 12 5.4 12 12v8c0 6.6-5.4 12-12 12H32v116c0 6.6-5.4 12-12 12h-8c-6.6 0-12-5.4-12-12zM300 32h124c13.3 0 24 10.7 24 24v124c0 6.6-5.4 12-12 12h-8c-6.6 0-12-5.4-12-12V64H300c-6.6 0-12-5.4-12-12v-8c0-6.6 5.4-12 12-12zm148 300v124c0 13.3-10.7 24-24 24H300c-6.6 0-12-5.4-12-12v-8c0-6.6 5.4-12 12-12h116V332c0-6.6 5.4-12 12-12h8c6.6 0 12 5.4 12 12zM148 480H24c-13.3 0-24-10.7-24-24V332c0-6.6 5.4-12 12-12h8c6.6 0 12 5.4 12 12v116h116c6.6 0 12 5.4 12 12v8c0 6.6-5.4 12-12 12z");
    			add_location(path, file$1l, 0, 202, 202);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1l, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "expand" },
    				{
    					class: "svg-inline--fa fa-expand fa-w-14"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 448 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1m($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Expand_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Expand_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1m, create_fragment$1n, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Expand_svg_rollup_plugin",
    			options,
    			id: create_fragment$1n.name
    		});
    	}
    }

    var expand_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Expand_svg_rollup_plugin
    });

    var require$$43 = /*@__PURE__*/getAugmentedNamespace(expand_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/external-link.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1k = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/external-link.svg.rollup-plugin.svelte";

    function create_fragment$1m(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "external-link-alt" },
    		{
    			class: "svg-inline--fa fa-external-link-alt fa-w-16"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M440,256H424a8,8,0,0,0-8,8V464a16,16,0,0,1-16,16H48a16,16,0,0,1-16-16V112A16,16,0,0,1,48,96H248a8,8,0,0,0,8-8V72a8,8,0,0,0-8-8H48A48,48,0,0,0,0,112V464a48,48,0,0,0,48,48H400a48,48,0,0,0,48-48V264A8,8,0,0,0,440,256ZM480,0h-.06L383.78.17c-28.45,0-42.66,34.54-22.58,54.62l35.28,35.28-265,265a12,12,0,0,0,0,17l8.49,8.49a12,12,0,0,0,17,0l265-265,35.28,35.27c20,20,54.57,6,54.62-22.57L512,32.05A32,32,0,0,0,480,0Zm-.17,128.17-96-96L480,32Z");
    			add_location(path, file$1k, 0, 224, 224);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1k, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "external-link-alt" },
    				{
    					class: "svg-inline--fa fa-external-link-alt fa-w-16"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1l($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('External_link_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class External_link_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1l, create_fragment$1m, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "External_link_svg_rollup_plugin",
    			options,
    			id: create_fragment$1m.name
    		});
    	}
    }

    var externalLink_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': External_link_svg_rollup_plugin
    });

    var require$$44 = /*@__PURE__*/getAugmentedNamespace(externalLink_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/facebook.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1j = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/facebook.svg.rollup-plugin.svelte";

    function create_fragment$1l(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fab" },
    		{ "data-icon": "facebook-f" },
    		{
    			class: "svg-inline--fa fa-facebook-f fa-w-10"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 320 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M279.14 288l14.22-92.66h-88.91v-60.13c0-25.35 12.42-50.06 52.24-50.06h40.42V6.26S260.43 0 225.36 0c-73.22 0-121.08 44.38-121.08 124.72v70.62H22.89V288h81.39v224h100.17V288z");
    			add_location(path, file$1j, 0, 210, 210);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1j, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fab" },
    				{ "data-icon": "facebook-f" },
    				{
    					class: "svg-inline--fa fa-facebook-f fa-w-10"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 320 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1k($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Facebook_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Facebook_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1k, create_fragment$1l, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Facebook_svg_rollup_plugin",
    			options,
    			id: create_fragment$1l.name
    		});
    	}
    }

    var facebook_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Facebook_svg_rollup_plugin
    });

    var require$$45 = /*@__PURE__*/getAugmentedNamespace(facebook_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/filter-solid.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1i = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/filter-solid.svg.rollup-plugin.svelte";

    function create_fragment$1k(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fas" },
    		{ "data-icon": "filter" },
    		{
    			class: "svg-inline--fa fa-filter fa-w-16"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M487.976 0H24.028C2.71 0-8.047 25.866 7.058 40.971L192 225.941V432c0 7.831 3.821 15.17 10.237 19.662l80 55.98C298.02 518.69 320 507.493 320 487.98V225.941l184.947-184.97C520.021 25.896 509.338 0 487.976 0z");
    			add_location(path, file$1i, 0, 202, 202);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1i, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fas" },
    				{ "data-icon": "filter" },
    				{
    					class: "svg-inline--fa fa-filter fa-w-16"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1j($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Filter_solid_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Filter_solid_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1j, create_fragment$1k, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Filter_solid_svg_rollup_plugin",
    			options,
    			id: create_fragment$1k.name
    		});
    	}
    }

    var filterSolid_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Filter_solid_svg_rollup_plugin
    });

    var require$$46 = /*@__PURE__*/getAugmentedNamespace(filterSolid_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/futbol.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1h = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/futbol.svg.rollup-plugin.svelte";

    function create_fragment$1j(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 496 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M483.7 179.4C449.7 74.6 352.5 8 248.1 8 81.2 8-40 171.4 12.3 332.6 46.3 437.4 143.7 504 248 504c166.9 0 288-163.4 235.7-324.6zm-43 173.7-94.3 11.6-17.8-24.9 33.7-104.1 28.9-9 69.6 65c-3.6 21.1-10.3 41.8-20.1 61.4zM35.6 291.5l69.4-64.9 28.9 9 33.9 103.7-18.1 25.2-94.2-11.6c-13-26-17.2-45.2-19.9-61.4zm196.5-180.7v32.9L146.2 206l-31.5-9.8-18-93.9c15.3-15.1 32.8-27.8 52-37.8l83.4 46.3zm149.4 85.4L350 206l-85.9-62.3v-32.9l83.6-46.4c19.1 10 36.7 22.7 52 37.9l-18.2 93.9zm-215.4 35 82-59.5 82.1 59.6-31.1 96H197.5l-31.4-96.1zm297.7 19.5L412.7 203l13.3-68.3c34.5 50.8 37.3 97.2 37.8 116zM309.2 49.2l-61.1 33.9-61-33.8c71.5-21.2 122-.1 122.1-.1zM70.3 134.1 83.5 203l-51.1 47.5c.8-31.8 8.7-63.4 23.6-92.6 4.2-8.3 9.1-16.2 14.3-23.8zm7.5 254 68.7 8.4 29.2 62.7c-38.8-13.8-72.7-38.5-97.9-71.1zm137.9 81.3-40.1-86 17.4-24.2h110.2l17.3 24.2-40.1 86c-22.7 3.5-42.4 3.4-64.7 0zm104.8-10.2 29.2-62.7 69-8.5c-25 32.6-58.8 57.1-98.2 71.2z");
    			add_location(path, file$1h, 0, 95, 95);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1h, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 496 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1i($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Futbol_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Futbol_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1i, create_fragment$1j, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Futbol_svg_rollup_plugin",
    			options,
    			id: create_fragment$1j.name
    		});
    	}
    }

    var futbol_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Futbol_svg_rollup_plugin
    });

    var require$$47 = /*@__PURE__*/getAugmentedNamespace(futbol_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/gallery.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1g = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/gallery.svg.rollup-plugin.svelte";

    function create_fragment$1i(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ version: "1.1" },
    		{ id: "Layer_1" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{
    			"xmlns:xlink": "http://www.w3.org/1999/xlink"
    		},
    		{ x: "0px" },
    		{ y: "0px" },
    		{ viewBox: "0 0 55 55" },
    		{
    			style: "enable-background:new 0 0 55 55;"
    		},
    		{ "xml:space": "preserve" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M43.7,54.5c-0.3,0-0.6,0-0.9-0.1l-32.7-6.6c-0.8-0.2-1.3-1-1.2-1.8c0.2-0.8,1-1.3,1.8-1.2l32.8,6.6c0.1,0,0.1,0,0.2,0\n\tc0.1,0,0.1,0,0.6-0.1l0.1,0c0,0,0-0.1,0.1-0.1c0-0.1,0-0.1,0-0.2l7.1-35c0-0.2,0-0.4-0.1-0.6c-0.1-0.1-0.2-0.2-0.4-0.3L46,14.3\n\tc-0.8-0.1-1.4-0.9-1.2-1.7c0.1-0.8,0.9-1.4,1.7-1.2l4.9,0.9c1,0.2,1.8,0.7,2.4,1.5c0.6,0.9,0.8,1.9,0.6,2.9l-7.1,34.9\n\tc-0.1,1-0.8,2-1.7,2.5c-0.1,0-0.1,0.1-0.2,0.1l-0.2,0.1C44.8,54.3,44.3,54.5,43.7,54.5z M39.6,43.3H4.2c-2.2,0-3.7-1.6-3.7-3.7V4.2\n\tc0-2.2,1.6-3.7,3.7-3.7h35.4c2.2,0,3.7,1.6,3.7,3.7v35.4C43.3,41.8,41.8,43.3,39.6,43.3z M3.5,36.7v2.9c0,0.5,0.2,0.7,0.7,0.7h35.4\n\tc0.5,0,0.7-0.2,0.7-0.7v-2.9H3.5z M37.7,33.7h2.6V4.2c0-0.5-0.2-0.7-0.7-0.7H4.2c-0.5,0-0.7,0.2-0.7,0.7v29.5h2.6\n\tc0.2-1.7,0.6-3.4,1.4-5.1c1.2-2.4,4.8-3.7,9.8-5.4c0.2-0.5,0.2-1.7,0-2.1c-2.1-2.4-3-5.2-2.8-8.1c0-2.2,0.6-4,1.9-5.5\n\tc1.4-1.6,3.3-2.5,5.6-2.5c2,0,3.9,0.9,5.5,2.4c0,0,0.1,0.1,0.1,0.1c1.3,1.6,1.9,3.5,1.7,5.6c0.2,3-0.8,5.9-2.7,7.9\n\tc-0.2,0.5-0.2,1.8,0,2.3c0.6,0.2,1.3,0.5,1.9,0.7c4,1.5,6.9,2.6,7.9,4.6C37.1,30.3,37.6,32,37.7,33.7z M9.1,33.7h25.6\n\tc-0.2-1.3-0.5-2.6-1.1-3.9c-0.4-0.9-3.4-2-6.2-3c-0.7-0.3-1.4-0.5-2.2-0.8c-0.5-0.2-1.2-0.7-1.5-1.8c-0.5-1.5-0.3-3.9,0.4-4.9\n\tc0.1-0.1,0.1-0.2,0.2-0.2c1.4-1.4,2.2-3.6,2-5.9c0-0.1,0-0.2,0-0.3c0.2-1.3-0.1-2.5-0.9-3.4c-0.6-0.6-1.8-1.5-3.3-1.5\n\tc-1.4,0-2.5,0.5-3.3,1.5c-0.8,1-1.2,2.2-1.2,3.7c0,0,0,0.1,0,0.1c-0.2,2.2,0.5,4.2,2.1,6c0.9,0.9,1.1,3.3,0.8,4.6\n\tc-0.4,1.6-1.3,2.1-1.8,2.3c-2.8,0.9-7.5,2.5-8.2,3.9C9.7,31.1,9.3,32.4,9.1,33.7z M17.3,21.1C17.3,21.2,17.3,21.2,17.3,21.1\n\tC17.3,21.2,17.3,21.2,17.3,21.1z");
    			add_location(path, file$1g, 11, 2, 244);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1g, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ version: "1.1" },
    				{ id: "Layer_1" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{
    					"xmlns:xlink": "http://www.w3.org/1999/xlink"
    				},
    				{ x: "0px" },
    				{ y: "0px" },
    				{ viewBox: "0 0 55 55" },
    				{
    					style: "enable-background:new 0 0 55 55;"
    				},
    				{ "xml:space": "preserve" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1h($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Gallery_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Gallery_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1h, create_fragment$1i, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Gallery_svg_rollup_plugin",
    			options,
    			id: create_fragment$1i.name
    		});
    	}
    }

    var gallery_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Gallery_svg_rollup_plugin
    });

    var require$$48 = /*@__PURE__*/getAugmentedNamespace(gallery_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/headphones.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1f = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/headphones.svg.rollup-plugin.svelte";

    function create_fragment$1h(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ version: "1.1" },
    		{ id: "Layer_1" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{
    			"xmlns:xlink": "http://www.w3.org/1999/xlink"
    		},
    		{ x: "0px" },
    		{ y: "0px" },
    		{ viewBox: "0 0 53 53" },
    		{
    			style: "enable-background:new 0 0 53 53;"
    		},
    		{ "xml:space": "preserve" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M14.9,52.7c-0.5,0-1.1-0.1-1.6-0.3c-0.9-0.4-1.6-1.2-2-2.3L6.7,38.3c-0.4-1-0.4-2.1,0.1-3c0.4-0.9,1.2-1.6,2.2-1.9l2-0.9\n\tc1-0.4,2.1-0.4,3.1,0c0.9,0.4,1.6,1.2,2,2.3l4.6,11.8c0.4,1,0.4,2.1-0.1,3c-0.4,0.9-1.2,1.6-2.2,1.9l-2,0.9\n\tC15.9,52.6,15.4,52.7,14.9,52.7z M12.5,35.1c-0.1,0-0.2,0-0.3,0.1l-2,0.9c0,0-0.1,0-0.1,0.1c-0.2,0.1-0.4,0.2-0.5,0.4\n\tc-0.1,0.2-0.1,0.4,0,0.7c0,0,0,0,0,0l4.7,11.9c0.1,0.3,0.2,0.5,0.4,0.6c0.2,0.1,0.4,0.1,0.7,0l2-0.9c0,0,0.1,0,0.1-0.1\n\tc0.2-0.1,0.4-0.2,0.5-0.4c0.1-0.2,0.1-0.4,0-0.7l-4.7-11.9c-0.1-0.3-0.2-0.5-0.4-0.6C12.7,35.1,12.6,35.1,12.5,35.1z M38,52.6\n\tc-0.5,0-0.9-0.1-1.3-0.3l-2.2-1c-1.9-0.8-2.9-3.1-2.2-5L37,34.6c0.8-2,3.1-3,5-2.2l2.2,1c0.9,0.3,1.6,1.1,2.1,2c0.5,1,0.5,2,0.1,3\n\tl-4.7,11.9c0,0,0,0,0,0c-0.4,0.9-1.1,1.7-2,2.1C39.1,52.5,38.6,52.6,38,52.6z M40.7,35.1c-0.3,0-0.7,0.3-0.9,0.6l-4.7,11.9\n\tc-0.2,0.4,0.1,0.9,0.6,1.1l2.2,1c0.3,0.1,0.9-0.2,1-0.6l4.7-11.9c0.1-0.2,0.1-0.4,0-0.6c-0.1-0.2-0.3-0.4-0.5-0.5l-2.2-1\n\tC40.8,35.1,40.7,35.1,40.7,35.1z M40.3,49.6L40.3,49.6L40.3,49.6z M44,52.5c-0.2,0-0.5-0.1-0.7-0.2c-0.7-0.4-1-1.3-0.6-2\n\tc0.1-0.1,6.8-12.6,6.8-23.8c0-12.7-10.3-23-23-23c-12.7,0-23,10.3-23,23c0,11.1,6.7,23.7,6.8,23.8c0.4,0.7,0.1,1.6-0.6,2\n\tc-0.7,0.4-1.6,0.1-2-0.6c-0.3-0.5-7.2-13.3-7.2-25.2c0-14.3,11.7-26,26-26c14.3,0,26,11.7,26,26c0,11.9-6.9,24.7-7.2,25.2\n\tC45,52.2,44.5,52.5,44,52.5z");
    			add_location(path, file$1f, 2, 0, 225);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1f, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ version: "1.1" },
    				{ id: "Layer_1" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{
    					"xmlns:xlink": "http://www.w3.org/1999/xlink"
    				},
    				{ x: "0px" },
    				{ y: "0px" },
    				{ viewBox: "0 0 53 53" },
    				{
    					style: "enable-background:new 0 0 53 53;"
    				},
    				{ "xml:space": "preserve" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1g($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Headphones_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Headphones_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1g, create_fragment$1h, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Headphones_svg_rollup_plugin",
    			options,
    			id: create_fragment$1h.name
    		});
    	}
    }

    var headphones_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Headphones_svg_rollup_plugin
    });

    var require$$49 = /*@__PURE__*/getAugmentedNamespace(headphones_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/headset.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1e = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/headset.svg.rollup-plugin.svelte";

    function create_fragment$1g(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M192 208c0-17.67-14.33-32-32-32h-16c-35.35 0-64 28.65-64 64v48c0 35.35 28.65 64 64 64h16c17.67 0 32-14.33 32-32V208zm176 144c35.35 0 64-28.65 64-64v-48c0-35.35-28.65-64-64-64h-16c-17.67 0-32 14.33-32 32v112c0 17.67 14.33 32 32 32h16zM256 0C113.18 0 4.58 118.83 0 256v16c0 8.84 7.16 16 16 16h16c8.84 0 16-7.16 16-16v-16c0-114.69 93.31-208 208-208s208 93.31 208 208h-.12c.08 2.43.12 165.72.12 165.72 0 23.35-18.93 42.28-42.28 42.28H320c0-26.51-21.49-48-48-48h-32c-26.51 0-48 21.49-48 48s21.49 48 48 48h181.72c49.86 0 90.28-40.42 90.28-90.28V256C507.42 118.83 398.82 0 256 0z");
    			add_location(path, file$1e, 0, 76, 76);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1e, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Headset_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Headset_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1f, create_fragment$1g, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Headset_svg_rollup_plugin",
    			options,
    			id: create_fragment$1g.name
    		});
    	}
    }

    var headset_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Headset_svg_rollup_plugin
    });

    var require$$50 = /*@__PURE__*/getAugmentedNamespace(headset_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/heart-half-solid.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1d = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/heart-half-solid.svg.rollup-plugin.svelte";

    function create_fragment$1f(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ version: "1.1" },
    		{ id: "Lag_1" },
    		{ focusable: "false" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{
    			"xmlns:xlink": "http://www.w3.org/1999/xlink"
    		},
    		{ x: "0px" },
    		{ y: "0px" },
    		{ viewBox: "0 0 512 512" },
    		{
    			style: "enable-background:new 0 0 512 512;"
    		},
    		{ "xml:space": "preserve" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M256,96.5l-19.7-20.3C186.1,24.3,104.5,15.9,49.7,62.6c-62.8,53.6-66.1,149.8-9.9,207.9l193.5,199.8\n\tc6.3,6.5,14.5,9.7,22.7,9.7V96.5z");
    			add_location(path, file$1d, 2, 0, 245);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1d, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ version: "1.1" },
    				{ id: "Lag_1" },
    				{ focusable: "false" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{
    					"xmlns:xlink": "http://www.w3.org/1999/xlink"
    				},
    				{ x: "0px" },
    				{ y: "0px" },
    				{ viewBox: "0 0 512 512" },
    				{
    					style: "enable-background:new 0 0 512 512;"
    				},
    				{ "xml:space": "preserve" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1e($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Heart_half_solid_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Heart_half_solid_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1e, create_fragment$1f, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Heart_half_solid_svg_rollup_plugin",
    			options,
    			id: create_fragment$1f.name
    		});
    	}
    }

    var heartHalfSolid_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Heart_half_solid_svg_rollup_plugin
    });

    var require$$51 = /*@__PURE__*/getAugmentedNamespace(heartHalfSolid_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/heart-solid.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1c = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/heart-solid.svg.rollup-plugin.svelte";

    function create_fragment$1e(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fas" },
    		{ "data-icon": "heart" },
    		{ class: "svg-inline--fa fa-heart fa-w-16" },
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M462.3 62.6C407.5 15.9 326 24.3 275.7 76.2L256 96.5l-19.7-20.3C186.1 24.3 104.5 15.9 49.7 62.6c-62.8 53.6-66.1 149.8-9.9 207.9l193.5 199.8c12.5 12.9 32.8 12.9 45.3 0l193.5-199.8c56.3-58.1 53-154.3-9.8-207.9z");
    			add_location(path, file$1c, 0, 200, 200);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1c, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fas" },
    				{ "data-icon": "heart" },
    				{ class: "svg-inline--fa fa-heart fa-w-16" },
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1d($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Heart_solid_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Heart_solid_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1d, create_fragment$1e, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Heart_solid_svg_rollup_plugin",
    			options,
    			id: create_fragment$1e.name
    		});
    	}
    }

    var heartSolid_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Heart_solid_svg_rollup_plugin
    });

    var require$$52 = /*@__PURE__*/getAugmentedNamespace(heartSolid_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/heart.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1b = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/heart.svg.rollup-plugin.svelte";

    function create_fragment$1d(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "heart" },
    		{ class: "svg-inline--fa fa-heart fa-w-16" },
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M462.3 62.7c-54.5-46.4-136-38.7-186.6 13.5L256 96.6l-19.7-20.3C195.5 34.1 113.2 8.7 49.7 62.7c-62.8 53.6-66.1 149.8-9.9 207.8l193.5 199.8c6.2 6.4 14.4 9.7 22.6 9.7 8.2 0 16.4-3.2 22.6-9.7L472 270.5c56.4-58 53.1-154.2-9.7-207.8zm-13.1 185.6L256.4 448.1 62.8 248.3c-38.4-39.6-46.4-115.1 7.7-161.2 54.8-46.8 119.2-12.9 142.8 11.5l42.7 44.1 42.7-44.1c23.2-24 88.2-58 142.8-11.5 54 46 46.1 121.5 7.7 161.2z");
    			add_location(path, file$1b, 0, 200, 200);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1b, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "heart" },
    				{ class: "svg-inline--fa fa-heart fa-w-16" },
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1c($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Heart_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Heart_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1c, create_fragment$1d, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Heart_svg_rollup_plugin",
    			options,
    			id: create_fragment$1d.name
    		});
    	}
    }

    var heart_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Heart_svg_rollup_plugin
    });

    var require$$53 = /*@__PURE__*/getAugmentedNamespace(heart_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/history.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$1a = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/history.svg.rollup-plugin.svelte";

    function create_fragment$1c(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "history" },
    		{
    			class: "svg-inline--fa fa-history fa-w-16"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M20 24h10c6.627 0 12 5.373 12 12v94.625C85.196 57.047 165.239 7.715 256.793 8.001 393.18 8.428 504.213 120.009 504 256.396 503.786 393.181 392.834 504 256 504c-63.926 0-122.202-24.187-166.178-63.908-5.113-4.618-5.354-12.561-.482-17.433l7.069-7.069c4.503-4.503 11.749-4.714 16.482-.454C150.782 449.238 200.935 470 256 470c117.744 0 214-95.331 214-214 0-117.744-95.331-214-214-214-82.862 0-154.737 47.077-190.289 116H164c6.627 0 12 5.373 12 12v10c0 6.627-5.373 12-12 12H20c-6.627 0-12-5.373-12-12V36c0-6.627 5.373-12 12-12zm321.647 315.235l4.706-6.47c3.898-5.36 2.713-12.865-2.647-16.763L272 263.853V116c0-6.627-5.373-12-12-12h-8c-6.627 0-12 5.373-12 12v164.147l84.884 61.734c5.36 3.899 12.865 2.714 16.763-2.646z");
    			add_location(path, file$1a, 0, 204, 204);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1a, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "history" },
    				{
    					class: "svg-inline--fa fa-history fa-w-16"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1b($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('History_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class History_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1b, create_fragment$1c, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "History_svg_rollup_plugin",
    			options,
    			id: create_fragment$1c.name
    		});
    	}
    }

    var history_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': History_svg_rollup_plugin
    });

    var require$$54 = /*@__PURE__*/getAugmentedNamespace(history_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/info-circle-solid.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$19 = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/info-circle-solid.svg.rollup-plugin.svelte";

    function create_fragment$1b(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fas" },
    		{ "data-icon": "info-circle" },
    		{
    			class: "svg-inline--fa fa-info-circle fa-w-16"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z");
    			add_location(path, file$19, 0, 212, 212);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$19, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fas" },
    				{ "data-icon": "info-circle" },
    				{
    					class: "svg-inline--fa fa-info-circle fa-w-16"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1a($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Info_circle_solid_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Info_circle_solid_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1a, create_fragment$1b, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Info_circle_solid_svg_rollup_plugin",
    			options,
    			id: create_fragment$1b.name
    		});
    	}
    }

    var infoCircleSolid_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Info_circle_solid_svg_rollup_plugin
    });

    var require$$55 = /*@__PURE__*/getAugmentedNamespace(infoCircleSolid_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/info-circle.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$18 = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/info-circle.svg.rollup-plugin.svelte";

    function create_fragment$1a(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "info-circle" },
    		{
    			class: "svg-inline--fa fa-info-circle fa-w-16"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M256 40c118.621 0 216 96.075 216 216 0 119.291-96.61 216-216 216-119.244 0-216-96.562-216-216 0-119.203 96.602-216 216-216m0-32C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm-36 344h12V232h-12c-6.627 0-12-5.373-12-12v-8c0-6.627 5.373-12 12-12h48c6.627 0 12 5.373 12 12v140h12c6.627 0 12 5.373 12 12v8c0 6.627-5.373 12-12 12h-72c-6.627 0-12-5.373-12-12v-8c0-6.627 5.373-12 12-12zm36-240c-17.673 0-32 14.327-32 32s14.327 32 32 32 32-14.327 32-32-14.327-32-32-32z");
    			add_location(path, file$18, 0, 212, 212);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$18, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "info-circle" },
    				{
    					class: "svg-inline--fa fa-info-circle fa-w-16"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$19($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Info_circle_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Info_circle_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$19, create_fragment$1a, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Info_circle_svg_rollup_plugin",
    			options,
    			id: create_fragment$1a.name
    		});
    	}
    }

    var infoCircle_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Info_circle_svg_rollup_plugin
    });

    var require$$56 = /*@__PURE__*/getAugmentedNamespace(infoCircle_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/instagram.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$17 = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/instagram.svg.rollup-plugin.svelte";

    function create_fragment$19(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fab" },
    		{ "data-icon": "instagram" },
    		{
    			class: "svg-inline--fa fa-instagram fa-w-14"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 448 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M224.1 141c-63.6 0-114.9 51.3-114.9 114.9s51.3 114.9 114.9 114.9S339 319.5 339 255.9 287.7 141 224.1 141zm0 189.6c-41.1 0-74.7-33.5-74.7-74.7s33.5-74.7 74.7-74.7 74.7 33.5 74.7 74.7-33.6 74.7-74.7 74.7zm146.4-194.3c0 14.9-12 26.8-26.8 26.8-14.9 0-26.8-12-26.8-26.8s12-26.8 26.8-26.8 26.8 12 26.8 26.8zm76.1 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9 0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9 0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9 0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8 0-184.8zM398.8 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1z");
    			add_location(path, file$17, 0, 208, 208);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$17, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fab" },
    				{ "data-icon": "instagram" },
    				{
    					class: "svg-inline--fa fa-instagram fa-w-14"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 448 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$19.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$18($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Instagram_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Instagram_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$18, create_fragment$19, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Instagram_svg_rollup_plugin",
    			options,
    			id: create_fragment$19.name
    		});
    	}
    }

    var instagram_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Instagram_svg_rollup_plugin
    });

    var require$$57 = /*@__PURE__*/getAugmentedNamespace(instagram_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/lightning.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$16 = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/lightning.svg.rollup-plugin.svelte";

    function create_fragment$18(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ viewBox: "0 0 10 16" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M3.3386 9.49129L0.487524 8.39426C-0.0111216 8.20239 -0.160746 7.59269 0.196055 7.20656L6.62062 0.25398C7.16186 -0.331744 8.15565 0.179283 7.95001 0.937577L6.43918 6.50871L9.29025 7.60574C9.7889 7.79761 9.93852 8.40731 9.58172 8.79344L3.15716 15.746C2.61592 16.3317 1.62213 15.8207 1.82777 15.0624L3.3386 9.49129Z");
    			add_location(path, file$16, 1, 0, 75);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$16, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ viewBox: "0 0 10 16" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$18.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$17($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Lightning_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Lightning_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$17, create_fragment$18, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Lightning_svg_rollup_plugin",
    			options,
    			id: create_fragment$18.name
    		});
    	}
    }

    var lightning_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Lightning_svg_rollup_plugin
    });

    var require$$58 = /*@__PURE__*/getAugmentedNamespace(lightning_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/linkedin.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$15 = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/linkedin.svg.rollup-plugin.svelte";

    function create_fragment$17(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fab" },
    		{ "data-icon": "linkedin-in" },
    		{
    			class: "svg-inline--fa fa-linkedin-in fa-w-14"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 448 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M100.28 448H7.4V148.9h92.88zM53.79 108.1C24.09 108.1 0 83.5 0 53.8a53.79 53.79 0 0 1 107.58 0c0 29.7-24.1 54.3-53.79 54.3zM447.9 448h-92.68V302.4c0-34.7-.7-79.2-48.29-79.2-48.29 0-55.69 37.7-55.69 76.7V448h-92.78V148.9h89.08v40.8h1.3c12.4-23.5 42.69-48.3 87.88-48.3 94 0 111.28 61.9 111.28 142.3V448z");
    			add_location(path, file$15, 0, 212, 212);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$15, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fab" },
    				{ "data-icon": "linkedin-in" },
    				{
    					class: "svg-inline--fa fa-linkedin-in fa-w-14"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 448 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$17.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$16($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Linkedin_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Linkedin_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$16, create_fragment$17, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Linkedin_svg_rollup_plugin",
    			options,
    			id: create_fragment$17.name
    		});
    	}
    }

    var linkedin_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Linkedin_svg_rollup_plugin
    });

    var require$$59 = /*@__PURE__*/getAugmentedNamespace(linkedin_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/list-ol.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$14 = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/list-ol.svg.rollup-plugin.svelte";

    function create_fragment$16(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "m61.77 401 17.5-20.15a19.92 19.92 0 0 0 5.07-14.19v-3.31C84.34 356 80.5 352 73 352H16a8 8 0 0 0-8 8v16a8 8 0 0 0 8 8h22.84a154.82 154.82 0 0 0-11 12.31l-5.61 7c-4 5.07-5.25 10.13-2.8 14.88l1.05 1.93c3 5.76 6.3 7.88 12.25 7.88h4.73c10.33 0 15.94 2.44 15.94 9.09 0 4.72-4.2 8.22-14.36 8.22a41.54 41.54 0 0 1-15.47-3.12c-6.49-3.88-11.74-3.5-15.6 3.12l-5.59 9.31c-3.73 6.13-3.2 11.72 2.62 15.94 7.71 4.69 20.39 9.44 37 9.44 34.16 0 48.5-22.75 48.5-44.12-.03-14.38-9.12-29.76-28.73-34.88zM12.1 320H80a8 8 0 0 0 8-8v-16a8 8 0 0 0-8-8H41.33c3.28-10.29 48.33-18.68 48.33-56.44 0-29.06-25-39.56-44.47-39.56-21.36 0-33.8 10-40.45 18.75-4.38 5.59-3 10.84 2.79 15.37l8.58 6.88c5.61 4.56 11 2.47 16.13-2.44a13.4 13.4 0 0 1 9.45-3.84c3.33 0 9.28 1.56 9.28 8.75C51 248.19 0 257.31 0 304.59v4C0 316 5.08 320 12.1 320zM16 160h64a8 8 0 0 0 8-8v-16a8 8 0 0 0-8-8H64V40a8 8 0 0 0-8-8H32a8 8 0 0 0-7.14 4.42l-8 16A8 8 0 0 0 24 64h8v64H16a8 8 0 0 0-8 8v16a8 8 0 0 0 8 8zm488-80H168a8 8 0 0 0-8 8v16a8 8 0 0 0 8 8h336a8 8 0 0 0 8-8V88a8 8 0 0 0-8-8zm0 320H168a8 8 0 0 0-8 8v16a8 8 0 0 0 8 8h336a8 8 0 0 0 8-8v-16a8 8 0 0 0-8-8zm0-160H168a8 8 0 0 0-8 8v16a8 8 0 0 0 8 8h336a8 8 0 0 0 8-8v-16a8 8 0 0 0-8-8z");
    			add_location(path, file$14, 0, 95, 95);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$14, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$16.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$15($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('List_ol_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class List_ol_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$15, create_fragment$16, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "List_ol_svg_rollup_plugin",
    			options,
    			id: create_fragment$16.name
    		});
    	}
    }

    var listOl_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': List_ol_svg_rollup_plugin
    });

    var require$$60 = /*@__PURE__*/getAugmentedNamespace(listOl_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/lock.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$13 = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/lock.svg.rollup-plugin.svelte";

    function create_fragment$15(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "lock" },
    		{ class: "svg-inline--fa fa-lock fa-w-14" },
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 448 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M400 224h-16v-62.5C384 73.1 312.9.3 224.5 0 136-.3 64 71.6 64 160v64H48c-26.5 0-48 21.5-48 48v192c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V272c0-26.5-21.5-48-48-48zM96 160c0-70.6 57.4-128 128-128s128 57.4 128 128v64H96v-64zm304 320H48c-8.8 0-16-7.2-16-16V272c0-8.8 7.2-16 16-16h352c8.8 0 16 7.2 16 16v192c0 8.8-7.2 16-16 16z");
    			add_location(path, file$13, 0, 198, 198);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$13, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "lock" },
    				{ class: "svg-inline--fa fa-lock fa-w-14" },
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 448 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$15.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$14($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Lock_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Lock_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$14, create_fragment$15, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Lock_svg_rollup_plugin",
    			options,
    			id: create_fragment$15.name
    		});
    	}
    }

    var lock_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Lock_svg_rollup_plugin
    });

    var require$$61 = /*@__PURE__*/getAugmentedNamespace(lock_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/mappin-solid.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$12 = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/mappin-solid.svg.rollup-plugin.svelte";

    function create_fragment$14(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fas" },
    		{ "data-icon": "map-marker-alt" },
    		{
    			class: "svg-inline--fa fa-map-marker-alt fa-w-12"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 384 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M172.268 501.67C26.97 291.031 0 269.413 0 192 0 85.961 85.961 0 192 0s192 85.961 192 192c0 77.413-26.97 99.031-172.268 309.67-9.535 13.774-29.93 13.773-39.464 0zM192 272c44.183 0 80-35.817 80-80s-35.817-80-80-80-80 35.817-80 80 35.817 80 80 80z");
    			add_location(path, file$12, 0, 218, 218);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$12, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fas" },
    				{ "data-icon": "map-marker-alt" },
    				{
    					class: "svg-inline--fa fa-map-marker-alt fa-w-12"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 384 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$14.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$13($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Mappin_solid_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Mappin_solid_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$13, create_fragment$14, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Mappin_solid_svg_rollup_plugin",
    			options,
    			id: create_fragment$14.name
    		});
    	}
    }

    var mappinSolid_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Mappin_solid_svg_rollup_plugin
    });

    var require$$62 = /*@__PURE__*/getAugmentedNamespace(mappinSolid_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/medielogin.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$11 = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/medielogin.svg.rollup-plugin.svelte";

    function create_fragment$13(ctx) {
    	let svg;
    	let g;
    	let rect;
    	let polygon0;
    	let path;
    	let polygon1;

    	let svg_levels = [
    		{ version: "1.1" },
    		{ id: "Layer_1" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{
    			"xmlns:xlink": "http://www.w3.org/1999/xlink"
    		},
    		{ x: "0px" },
    		{ y: "0px" },
    		{ viewBox: "0 0 63.6 81.5" },
    		{
    			style: "enable-background:new 0 0 63.6 81.5;"
    		},
    		{ "xml:space": "preserve" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			g = svg_element("g");
    			rect = svg_element("rect");
    			polygon0 = svg_element("polygon");
    			path = svg_element("path");
    			polygon1 = svg_element("polygon");
    			attr_dev(rect, "y", "70.7");
    			attr_dev(rect, "width", "63.3");
    			attr_dev(rect, "height", "10.9");
    			add_location(rect, file$11, 12, 4, 260);
    			attr_dev(polygon0, "points", "0,81.5 21.2,61.8 21.2,47.8 0,67.5 \t");
    			add_location(polygon0, file$11, 13, 4, 309);
    			attr_dev(path, "d", "M31.8,0C14.2,0,0,14.2,0,31.8c0,13.8,8.9,25.6,21.2,30v-14c-5.2-3.4-8.6-9.3-8.6-16c0-10.6,8.6-19.2,19.2-19.2\n\t\tS51,21.2,51,31.8c0,6.7-3.4,12.5-8.6,16v14c12.3-4.4,21.2-16.1,21.2-30C63.6,14.2,49.3,0,31.8,0z");
    			add_location(path, file$11, 14, 4, 370);
    			attr_dev(polygon1, "points", "63.6,81.5 42.4,61.7 42.4,47.8 63.6,67.5 \t");
    			add_location(polygon1, file$11, 18, 4, 600);
    			add_location(g, file$11, 11, 2, 252);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$11, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, g);
    			append_dev(g, rect);
    			append_dev(g, polygon0);
    			append_dev(g, path);
    			append_dev(g, polygon1);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ version: "1.1" },
    				{ id: "Layer_1" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{
    					"xmlns:xlink": "http://www.w3.org/1999/xlink"
    				},
    				{ x: "0px" },
    				{ y: "0px" },
    				{ viewBox: "0 0 63.6 81.5" },
    				{
    					style: "enable-background:new 0 0 63.6 81.5;"
    				},
    				{ "xml:space": "preserve" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$13.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$12($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Medielogin_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Medielogin_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$12, create_fragment$13, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Medielogin_svg_rollup_plugin",
    			options,
    			id: create_fragment$13.name
    		});
    	}
    }

    var medielogin_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Medielogin_svg_rollup_plugin
    });

    var require$$63 = /*@__PURE__*/getAugmentedNamespace(medielogin_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/menubars-solid.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$10 = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/menubars-solid.svg.rollup-plugin.svelte";

    function create_fragment$12(ctx) {
    	let svg;
    	let g1;
    	let g0;
    	let rect0;
    	let g3;
    	let g2;
    	let rect1;
    	let g5;
    	let g4;
    	let rect2;

    	let svg_levels = [
    		{ version: "1.1" },
    		{ id: "Lag_1" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{
    			"xmlns:xlink": "http://www.w3.org/1999/xlink"
    		},
    		{ x: "0px" },
    		{ y: "0px" },
    		{ viewBox: "0 0 30 30" },
    		{ "enable-background": "new 0 0 30 30" },
    		{ "xml:space": "preserve" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			g1 = svg_element("g");
    			g0 = svg_element("g");
    			rect0 = svg_element("rect");
    			g3 = svg_element("g");
    			g2 = svg_element("g");
    			rect1 = svg_element("rect");
    			g5 = svg_element("g");
    			g4 = svg_element("g");
    			rect2 = svg_element("rect");
    			attr_dev(rect0, "y", "4.3");
    			attr_dev(rect0, "width", "30");
    			attr_dev(rect0, "height", "4");
    			add_location(rect0, file$10, 13, 6, 253);
    			add_location(g0, file$10, 12, 4, 243);
    			add_location(g1, file$10, 11, 2, 235);
    			attr_dev(rect1, "y", "12.3");
    			attr_dev(rect1, "width", "30");
    			attr_dev(rect1, "height", "4");
    			add_location(rect1, file$10, 18, 6, 328);
    			add_location(g2, file$10, 17, 4, 318);
    			add_location(g3, file$10, 16, 2, 310);
    			attr_dev(rect2, "y", "20.3");
    			attr_dev(rect2, "width", "30");
    			attr_dev(rect2, "height", "4");
    			add_location(rect2, file$10, 23, 6, 404);
    			add_location(g4, file$10, 22, 4, 394);
    			add_location(g5, file$10, 21, 2, 386);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$10, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, g1);
    			append_dev(g1, g0);
    			append_dev(g0, rect0);
    			append_dev(svg, g3);
    			append_dev(g3, g2);
    			append_dev(g2, rect1);
    			append_dev(svg, g5);
    			append_dev(g5, g4);
    			append_dev(g4, rect2);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ version: "1.1" },
    				{ id: "Lag_1" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{
    					"xmlns:xlink": "http://www.w3.org/1999/xlink"
    				},
    				{ x: "0px" },
    				{ y: "0px" },
    				{ viewBox: "0 0 30 30" },
    				{ "enable-background": "new 0 0 30 30" },
    				{ "xml:space": "preserve" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$12.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$11($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Menubars_solid_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Menubars_solid_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$11, create_fragment$12, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Menubars_solid_svg_rollup_plugin",
    			options,
    			id: create_fragment$12.name
    		});
    	}
    }

    var menubarsSolid_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Menubars_solid_svg_rollup_plugin
    });

    var require$$64 = /*@__PURE__*/getAugmentedNamespace(menubarsSolid_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/menubars.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$$ = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/menubars.svg.rollup-plugin.svelte";

    function create_fragment$11(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "bars" },
    		{ class: "svg-inline--fa fa-bars fa-w-14" },
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 448 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M442 114H6a6 6 0 0 1-6-6V84a6 6 0 0 1 6-6h436a6 6 0 0 1 6 6v24a6 6 0 0 1-6 6zm0 160H6a6 6 0 0 1-6-6v-24a6 6 0 0 1 6-6h436a6 6 0 0 1 6 6v24a6 6 0 0 1-6 6zm0 160H6a6 6 0 0 1-6-6v-24a6 6 0 0 1 6-6h436a6 6 0 0 1 6 6v24a6 6 0 0 1-6 6z");
    			add_location(path, file$$, 0, 198, 198);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$$, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "bars" },
    				{ class: "svg-inline--fa fa-bars fa-w-14" },
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 448 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$11.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$10($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Menubars_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Menubars_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$10, create_fragment$11, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Menubars_svg_rollup_plugin",
    			options,
    			id: create_fragment$11.name
    		});
    	}
    }

    var menubars_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Menubars_svg_rollup_plugin
    });

    var require$$65 = /*@__PURE__*/getAugmentedNamespace(menubars_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/miteb-solid.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$_ = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/miteb-solid.svg.rollup-plugin.svelte";

    function create_fragment$10(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ version: "1.1" },
    		{ id: "miteb-solid" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{
    			"xmlns:xlink": "http://www.w3.org/1999/xlink"
    		},
    		{ x: "0" },
    		{ y: "0" },
    		{ viewBox: "0 0 512 512" },
    		{ "xml:space": "preserve" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M210.3 26.5H22.5C10 26.5-.1 36.5-.1 48.8v115.4c0 12.3 10.1 22.3 22.6 22.3h187.8c12.5 0 22.6-10 22.6-22.3V48.8c.1-12.3-10.1-22.3-22.6-22.3zM489.4 26.5H301.6c-12.5 0-22.6 10-22.6 22.3v231.1c0 12.3 10.1 22.3 22.6 22.3h187.8c12.5 0 22.6-10 22.6-22.3V48.8c0-12.3-10.1-22.3-22.6-22.3zM210.3 235.3H22.5c-12.5 0-22.6 10-22.6 22.3v205.6c0 12.3 10.1 22.3 22.6 22.3h187.8c12.5 0 22.6-10 22.6-22.3V257.6c.1-12.3-10.1-22.3-22.6-22.3zM489.4 350.1H301.6c-12.5 0-22.6 10-22.6 22.3v90.8c0 12.3 10.1 22.3 22.6 22.3h187.8c12.5 0 22.6-10 22.6-22.3v-90.8c0-12.3-10.1-22.3-22.6-22.3z");
    			add_location(path, file$_, 0, 183, 183);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$_, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ version: "1.1" },
    				{ id: "miteb-solid" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{
    					"xmlns:xlink": "http://www.w3.org/1999/xlink"
    				},
    				{ x: "0" },
    				{ y: "0" },
    				{ viewBox: "0 0 512 512" },
    				{ "xml:space": "preserve" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$10.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$$($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Miteb_solid_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Miteb_solid_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$$, create_fragment$10, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Miteb_solid_svg_rollup_plugin",
    			options,
    			id: create_fragment$10.name
    		});
    	}
    }

    var mitebSolid_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Miteb_solid_svg_rollup_plugin
    });

    var require$$66 = /*@__PURE__*/getAugmentedNamespace(mitebSolid_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/miteb.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$Z = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/miteb.svg.rollup-plugin.svelte";

    function create_fragment$$(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ version: "1.1" },
    		{ id: "miteb" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{
    			"xmlns:xlink": "http://www.w3.org/1999/xlink"
    		},
    		{ x: "0px" },
    		{ y: "0px" },
    		{ viewBox: "0 0 512 512" },
    		{
    			style: "enable-background:new 0 0 512 512;"
    		},
    		{ "xml:space": "preserve" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M475,63.5v201.7H316V63.5H475 M195.9,63.5v86h-159v-86H195.9 M195.9,272.3v176.2h-159V272.3H195.9 M475,387.1v61.4H316\n\tv-61.4H475 M489.4,26.5H301.6c-12.5,0-22.6,10-22.6,22.3v231.1c0,12.3,10.1,22.3,22.6,22.3h187.8c12.5,0,22.6-10,22.6-22.3V48.8\n\tC512,36.5,501.9,26.5,489.4,26.5L489.4,26.5z M210.3,26.5H22.5c-12.5,0-22.6,10-22.6,22.3v115.4c0,12.3,10.1,22.3,22.6,22.3h187.8\n\tc12.5,0,22.6-10,22.6-22.3V48.8C233,36.5,222.8,26.5,210.3,26.5L210.3,26.5z M210.3,235.3H22.5c-12.5,0-22.6,10-22.6,22.3v205.6\n\tc0,12.3,10.1,22.3,22.6,22.3h187.8c12.5,0,22.6-10,22.6-22.3V257.6C233,245.3,222.8,235.3,210.3,235.3L210.3,235.3z M489.4,350.1\n\tH301.6c-12.5,0-22.6,10-22.6,22.3v90.8c0,12.3,10.1,22.3,22.6,22.3h187.8c12.5,0,22.6-10,22.6-22.3v-90.8\n\tC512,360.1,501.9,350.1,489.4,350.1L489.4,350.1z");
    			add_location(path, file$Z, 2, 0, 227);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$Z, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ version: "1.1" },
    				{ id: "miteb" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{
    					"xmlns:xlink": "http://www.w3.org/1999/xlink"
    				},
    				{ x: "0px" },
    				{ y: "0px" },
    				{ viewBox: "0 0 512 512" },
    				{
    					style: "enable-background:new 0 0 512 512;"
    				},
    				{ "xml:space": "preserve" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$$.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$_($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Miteb_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Miteb_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$_, create_fragment$$, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Miteb_svg_rollup_plugin",
    			options,
    			id: create_fragment$$.name
    		});
    	}
    }

    var miteb_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Miteb_svg_rollup_plugin
    });

    var require$$67 = /*@__PURE__*/getAugmentedNamespace(miteb_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/newspaper.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$Y = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/newspaper.svg.rollup-plugin.svelte";

    function create_fragment$_(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ version: "1.1" },
    		{ id: "Layer_1" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{
    			"xmlns:xlink": "http://www.w3.org/1999/xlink"
    		},
    		{ x: "0px" },
    		{ y: "0px" },
    		{ viewBox: "0 0 42 39" },
    		{
    			style: "enable-background:new 0 0 42 39;"
    		},
    		{ "xml:space": "preserve" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M35.8,38.5H6.2c-3.5,0-6.2-2.7-6.2-6.2V2.7C0,1.2,1.2,0,2.7,0h26.1c1.6,0,2.7,1.2,2.7,2.7v29.6c0,2.4,1.8,4.2,4.2,4.2\n\ts4.2-1.8,4.2-4.2V6.2c0-0.6,0.4-1,1-1s1,0.4,1,1v26.1C42,35.8,39.3,38.5,35.8,38.5z M2.7,2C2.2,2,2,2.2,2,2.7v29.6\n\tc0,2.4,1.8,4.2,4.2,4.2h25c-1-1.1-1.6-2.6-1.6-4.2V2.7c0-0.5-0.2-0.7-0.7-0.7H2.7z M35.8,33.8c-0.6,0-1-0.4-1-1V6.2c0-0.6,0.4-1,1-1\n\ts1,0.4,1,1v26.5C36.8,33.3,36.3,33.8,35.8,33.8z M25.3,29.8H6.2c-0.6,0-1-0.4-1-1s0.4-1,1-1h19.1c0.6,0,1,0.4,1,1\n\tS25.9,29.8,25.3,29.8z M25.3,24.6H6.2c-0.6,0-1-0.4-1-1s0.4-1,1-1h19.1c0.6,0,1,0.4,1,1S25.9,24.6,25.3,24.6z M25.3,19.4h-4.9\n\tc-0.6,0-1-0.4-1-1s0.4-1,1-1h4.9c0.6,0,1,0.4,1,1S25.9,19.4,25.3,19.4z M15.8,19.4H7.1c-1.1,0-1.9-0.8-1.9-1.9V8.8\n\tC5.2,7.8,6,7,7.1,7h8.7c1.1,0,1.9,0.8,1.9,1.9v8.7C17.7,18.6,16.8,19.4,15.8,19.4z M7.2,17.4l8.4,0V9L7.2,9L7.2,17.4z M25.3,14.2\n\th-4.9c-0.6,0-1-0.4-1-1s0.4-1,1-1h4.9c0.6,0,1,0.4,1,1S25.9,14.2,25.3,14.2z M25.3,9h-4.9c-0.6,0-1-0.4-1-1s0.4-1,1-1h4.9\n\tc0.6,0,1,0.4,1,1S25.9,9,25.3,9z");
    			add_location(path, file$Y, 11, 2, 244);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$Y, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ version: "1.1" },
    				{ id: "Layer_1" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{
    					"xmlns:xlink": "http://www.w3.org/1999/xlink"
    				},
    				{ x: "0px" },
    				{ y: "0px" },
    				{ viewBox: "0 0 42 39" },
    				{
    					style: "enable-background:new 0 0 42 39;"
    				},
    				{ "xml:space": "preserve" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$_.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Newspaper_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Newspaper_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Z, create_fragment$_, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Newspaper_svg_rollup_plugin",
    			options,
    			id: create_fragment$_.name
    		});
    	}
    }

    var newspaper_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Newspaper_svg_rollup_plugin
    });

    var require$$68 = /*@__PURE__*/getAugmentedNamespace(newspaper_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/phone.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$X = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/phone.svg.rollup-plugin.svelte";

    function create_fragment$Z(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ version: "1.1" },
    		{ id: "Layer_1" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{
    			"xmlns:xlink": "http://www.w3.org/1999/xlink"
    		},
    		{ x: "0px" },
    		{ y: "0px" },
    		{ viewBox: "0 0 15 15" },
    		{
    			style: "enable-background:new 0 0 15 15;"
    		},
    		{ "xml:space": "preserve" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M12.9,14.2c-0.1,0-0.1,0-0.2,0v0c-6.3-0.6-11.3-5.7-12-12c0-0.5,0.1-0.9,0.4-1.3C1.5,0.6,2,0.4,2.5,0.4h2.3\n\tc0.8,0,1.5,0.5,1.7,1.2l0.7,2.2c0.2,0.6,0,1.3-0.4,1.8L6.4,6c0,0-0.1,0.1,0,0.2c0.7,1,1.3,1.6,2.4,2.4c0.1,0,0.1,0,0.2,0l0.4-0.4\n\tc0.5-0.5,1.2-0.6,1.8-0.4l2.2,0.7c0.7,0.2,1.2,0.9,1.2,1.7v2.3c0,0.5-0.2,1-0.6,1.3C13.7,14,13.3,14.2,12.9,14.2z M2.5,1.4\n\tc-0.2,0-0.4,0.1-0.6,0.2C1.8,1.8,1.7,1.9,1.8,2.1C2.3,8,7,12.6,12.8,13.2l0,0c0.2,0,0.4,0,0.5-0.2c0.2-0.1,0.2-0.3,0.2-0.6v-2.3\n\tc0-0.3-0.2-0.6-0.5-0.7l-2.2-0.7c-0.3-0.1-0.6,0-0.8,0.2L9.6,9.2c-0.4,0.4-1,0.4-1.4,0.1C7,8.5,6.3,7.9,5.6,6.7\n\tc-0.3-0.4-0.2-1,0.1-1.4L6.1,5c0.2-0.2,0.3-0.5,0.2-0.8L5.5,1.9C5.4,1.6,5.1,1.4,4.8,1.4H2.5z M14,5.2c-0.3,0-0.5-0.2-0.5-0.5\n\tc0-1.9-1.5-3.4-3.4-3.4c-0.3,0-0.5-0.2-0.5-0.5s0.2-0.5,0.5-0.5c2.4,0,4.4,2,4.4,4.4C14.5,5,14.3,5.2,14,5.2z M11.5,5.2\n\tC11.2,5.2,11,5,11,4.8C11,4.3,10.6,4,10.2,4C9.9,4,9.7,3.7,9.7,3.5S9.9,3,10.2,3c1,0,1.8,0.8,1.8,1.8C12,5,11.8,5.2,11.5,5.2z");
    			add_location(path, file$X, 2, 0, 225);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$X, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ version: "1.1" },
    				{ id: "Layer_1" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{
    					"xmlns:xlink": "http://www.w3.org/1999/xlink"
    				},
    				{ x: "0px" },
    				{ y: "0px" },
    				{ viewBox: "0 0 15 15" },
    				{
    					style: "enable-background:new 0 0 15 15;"
    				},
    				{ "xml:space": "preserve" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Phone_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Phone_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Y, create_fragment$Z, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Phone_svg_rollup_plugin",
    			options,
    			id: create_fragment$Z.name
    		});
    	}
    }

    var phone_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Phone_svg_rollup_plugin
    });

    var require$$69 = /*@__PURE__*/getAugmentedNamespace(phone_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/pin-solid.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$W = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/pin-solid.svg.rollup-plugin.svelte";

    function create_fragment$Y(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fas" },
    		{ "data-icon": "map-marker" },
    		{
    			class: "svg-inline--fa fa-map-marker fa-w-12"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 384 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M172.268 501.67C26.97 291.031 0 269.413 0 192 0 85.961 85.961 0 192 0s192 85.961 192 192c0 77.413-26.97 99.031-172.268 309.67-9.535 13.774-29.93 13.773-39.464 0z");
    			add_location(path, file$W, 0, 210, 210);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$W, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fas" },
    				{ "data-icon": "map-marker" },
    				{
    					class: "svg-inline--fa fa-map-marker fa-w-12"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 384 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$X($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Pin_solid_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Pin_solid_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$X, create_fragment$Y, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Pin_solid_svg_rollup_plugin",
    			options,
    			id: create_fragment$Y.name
    		});
    	}
    }

    var pinSolid_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Pin_solid_svg_rollup_plugin
    });

    var require$$70 = /*@__PURE__*/getAugmentedNamespace(pinSolid_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/play-circle.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$V = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/play-circle.svg.rollup-plugin.svelte";

    function create_fragment$X(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "play-circle" },
    		{
    			class: "svg-inline--fa fa-play-circle fa-w-16"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M256 504c137 0 248-111 248-248S393 8 256 8 8 119 8 256s111 248 248 248zM40 256c0-118.7 96.1-216 216-216 118.7 0 216 96.1 216 216 0 118.7-96.1 216-216 216-118.7 0-216-96.1-216-216zm331.7-18l-176-107c-15.8-8.8-35.7 2.5-35.7 21v208c0 18.4 19.8 29.8 35.7 21l176-101c16.4-9.1 16.4-32.8 0-42zM192 335.8V176.9c0-4.7 5.1-7.6 9.1-5.1l134.5 81.7c3.9 2.4 3.8 8.1-.1 10.3L201 341c-4 2.3-9-.6-9-5.2z");
    			add_location(path, file$V, 0, 212, 212);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$V, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "play-circle" },
    				{
    					class: "svg-inline--fa fa-play-circle fa-w-16"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$X.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$W($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Play_circle_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Play_circle_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$W, create_fragment$X, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Play_circle_svg_rollup_plugin",
    			options,
    			id: create_fragment$X.name
    		});
    	}
    }

    var playCircle_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Play_circle_svg_rollup_plugin
    });

    var require$$71 = /*@__PURE__*/getAugmentedNamespace(playCircle_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/question-circle.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$U = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/question-circle.svg.rollup-plugin.svelte";

    function create_fragment$W(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "question-circle" },
    		{
    			class: "svg-inline--fa fa-question-circle fa-w-16"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M256 340c-15.464 0-28 12.536-28 28s12.536 28 28 28 28-12.536 28-28-12.536-28-28-28zm7.67-24h-16c-6.627 0-12-5.373-12-12v-.381c0-70.343 77.44-63.619 77.44-107.408 0-20.016-17.761-40.211-57.44-40.211-29.144 0-44.265 9.649-59.211 28.692-3.908 4.98-11.054 5.995-16.248 2.376l-13.134-9.15c-5.625-3.919-6.86-11.771-2.645-17.177C185.658 133.514 210.842 116 255.67 116c52.32 0 97.44 29.751 97.44 80.211 0 67.414-77.44 63.849-77.44 107.408V304c0 6.627-5.373 12-12 12zM256 40c118.621 0 216 96.075 216 216 0 119.291-96.61 216-216 216-119.244 0-216-96.562-216-216 0-119.203 96.602-216 216-216m0-32C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8z");
    			add_location(path, file$U, 0, 220, 220);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$U, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "question-circle" },
    				{
    					class: "svg-inline--fa fa-question-circle fa-w-16"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$W.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$V($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Question_circle_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Question_circle_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$V, create_fragment$W, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Question_circle_svg_rollup_plugin",
    			options,
    			id: create_fragment$W.name
    		});
    	}
    }

    var questionCircle_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Question_circle_svg_rollup_plugin
    });

    var require$$72 = /*@__PURE__*/getAugmentedNamespace(questionCircle_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/rss-symbol.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$T = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/rss-symbol.svg.rollup-plugin.svelte";

    function create_fragment$V(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "rss" },
    		{ class: "svg-inline--fa fa-rss fa-w-14" },
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 448 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M80 352c26.467 0 48 21.533 48 48s-21.533 48-48 48-48-21.533-48-48 21.533-48 48-48m0-32c-44.183 0-80 35.817-80 80s35.817 80 80 80 80-35.817 80-80-35.817-80-80-80zm367.996 147.615c-6.448-237.848-198.06-429.164-435.61-435.61C5.609 31.821 0 37.229 0 44.007v8.006c0 6.482 5.146 11.816 11.626 11.994 220.81 6.05 398.319 183.913 404.367 404.367.178 6.48 5.512 11.626 11.994 11.626h8.007c6.778 0 12.185-5.609 12.002-12.385zm-144.245-.05c-6.347-158.132-133.207-284.97-291.316-291.316C5.643 175.976 0 181.45 0 188.247v8.005c0 6.459 5.114 11.72 11.567 11.989 141.134 5.891 254.301 119.079 260.192 260.192.269 6.453 5.531 11.567 11.989 11.567h8.005c6.798 0 12.271-5.643 11.998-12.435z");
    			add_location(path, file$T, 0, 196, 196);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$T, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "rss" },
    				{ class: "svg-inline--fa fa-rss fa-w-14" },
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 448 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$V.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$U($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Rss_symbol_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Rss_symbol_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$U, create_fragment$V, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Rss_symbol_svg_rollup_plugin",
    			options,
    			id: create_fragment$V.name
    		});
    	}
    }

    var rssSymbol_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Rss_symbol_svg_rollup_plugin
    });

    var require$$73 = /*@__PURE__*/getAugmentedNamespace(rssSymbol_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/rss.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$S = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/rss.svg.rollup-plugin.svelte";

    function create_fragment$U(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let path2;

    	let svg_levels = [
    		{ version: "1.1" },
    		{ id: "Layer_1" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{
    			"xmlns:xlink": "http://www.w3.org/1999/xlink"
    		},
    		{ x: "0px" },
    		{ y: "0px" },
    		{ viewBox: "0 0 24 10" },
    		{
    			style: "enable-background:new 0 0 24 10;"
    		},
    		{ "xml:space": "preserve" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			attr_dev(path0, "d", "M0,9V0.4h3.7c0.9,0,1.6,0.1,2,0.2c0.4,0.2,0.8,0.4,1,0.8C6.9,1.9,7,2.3,7,2.8C7,3.5,6.8,4,6.5,4.4C6.1,4.8,5.5,5.1,4.8,5.2\n\tc0.4,0.2,0.7,0.5,0.9,0.7c0.2,0.3,0.6,0.7,1,1.4l1,1.7H5.6L4.4,7.1C3.9,6.5,3.6,6,3.5,5.9C3.3,5.7,3.1,5.6,3,5.5\n\tC2.8,5.4,2.5,5.4,2.1,5.4H1.7V9H0z M1.7,4H3c0.8,0,1.4,0,1.6-0.1s0.4-0.2,0.5-0.4c0.1-0.2,0.2-0.4,0.2-0.6c0-0.3-0.1-0.5-0.2-0.7\n\tC4.9,2.1,4.6,1.9,4.4,1.9c-0.1,0-0.6,0-1.3,0H1.7V4z");
    			add_location(path0, file$S, 2, 0, 225);
    			attr_dev(path1, "d", "M8.2,6.2L9.9,6c0.1,0.6,0.3,1,0.6,1.2c0.3,0.3,0.7,0.4,1.3,0.4c0.6,0,1-0.1,1.3-0.4c0.3-0.2,0.4-0.5,0.4-0.8\n\tc0-0.2-0.1-0.4-0.2-0.5c-0.1-0.1-0.3-0.3-0.6-0.4c-0.2-0.1-0.7-0.2-1.4-0.4c-0.9-0.2-1.6-0.5-2-0.8c-0.5-0.5-0.8-1-0.8-1.7\n\tc0-0.4,0.1-0.8,0.4-1.2C9.2,1.1,9.5,0.8,10,0.6c0.5-0.2,1-0.3,1.7-0.3c1.1,0,1.9,0.2,2.4,0.7c0.5,0.5,0.8,1.1,0.9,1.9l-1.7,0.1\n\tC13.2,2.5,13,2.2,12.8,2c-0.2-0.2-0.6-0.3-1.1-0.3c-0.5,0-0.9,0.1-1.2,0.3c-0.2,0.1-0.3,0.3-0.3,0.5c0,0.2,0.1,0.4,0.3,0.5\n\tc0.2,0.2,0.8,0.4,1.6,0.6c0.8,0.2,1.5,0.4,1.9,0.6c0.4,0.2,0.7,0.5,0.9,0.9c0.2,0.4,0.3,0.8,0.3,1.4c0,0.5-0.1,1-0.4,1.4\n\tc-0.3,0.4-0.7,0.8-1.2,1c-0.5,0.2-1.1,0.3-1.9,0.3c-1.1,0-1.9-0.2-2.5-0.8C8.7,7.9,8.3,7.2,8.2,6.2z");
    			add_location(path1, file$S, 6, 0, 644);
    			attr_dev(path2, "d", "M16.2,6.2L17.9,6c0.1,0.6,0.3,1,0.6,1.2c0.3,0.3,0.7,0.4,1.3,0.4c0.6,0,1-0.1,1.3-0.4c0.3-0.2,0.4-0.5,0.4-0.8\n\tc0-0.2-0.1-0.4-0.2-0.5c-0.1-0.1-0.3-0.3-0.6-0.4c-0.2-0.1-0.7-0.2-1.4-0.4c-0.9-0.2-1.6-0.5-2-0.8c-0.5-0.5-0.8-1-0.8-1.7\n\tc0-0.4,0.1-0.8,0.4-1.2c0.2-0.4,0.6-0.7,1.1-0.9c0.5-0.2,1-0.3,1.7-0.3c1.1,0,1.9,0.2,2.4,0.7c0.5,0.5,0.8,1.1,0.9,1.9l-1.7,0.1\n\tC21.2,2.5,21,2.2,20.8,2c-0.2-0.2-0.6-0.3-1.1-0.3c-0.5,0-0.9,0.1-1.2,0.3c-0.2,0.1-0.3,0.3-0.3,0.5c0,0.2,0.1,0.4,0.3,0.5\n\tc0.2,0.2,0.8,0.4,1.6,0.6c0.8,0.2,1.5,0.4,1.9,0.6c0.4,0.2,0.7,0.5,0.9,0.9c0.2,0.4,0.3,0.8,0.3,1.4c0,0.5-0.1,1-0.4,1.4\n\tc-0.3,0.4-0.7,0.8-1.2,1c-0.5,0.2-1.1,0.3-1.9,0.3c-1.1,0-1.9-0.2-2.5-0.8C16.7,7.9,16.3,7.2,16.2,6.2z");
    			add_location(path2, file$S, 12, 0, 1341);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$S, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    			append_dev(svg, path2);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ version: "1.1" },
    				{ id: "Layer_1" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{
    					"xmlns:xlink": "http://www.w3.org/1999/xlink"
    				},
    				{ x: "0px" },
    				{ y: "0px" },
    				{ viewBox: "0 0 24 10" },
    				{
    					style: "enable-background:new 0 0 24 10;"
    				},
    				{ "xml:space": "preserve" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$U.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$T($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Rss_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Rss_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$T, create_fragment$U, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Rss_svg_rollup_plugin",
    			options,
    			id: create_fragment$U.name
    		});
    	}
    }

    var rss_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Rss_svg_rollup_plugin
    });

    var require$$74 = /*@__PURE__*/getAugmentedNamespace(rss_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/search.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$R = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/search.svg.rollup-plugin.svelte";

    function create_fragment$T(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "search" },
    		{
    			class: "svg-inline--fa fa-search fa-w-16"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395 312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5 0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17 0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208 32s176 78.7 176 176-78.7 176-176 176z");
    			add_location(path, file$R, 0, 202, 202);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$R, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "search" },
    				{
    					class: "svg-inline--fa fa-search fa-w-16"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$T.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$S($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Search_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Search_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$S, create_fragment$T, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Search_svg_rollup_plugin",
    			options,
    			id: create_fragment$T.name
    		});
    	}
    }

    var search_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Search_svg_rollup_plugin
    });

    var require$$75 = /*@__PURE__*/getAugmentedNamespace(search_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/smartphone.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$Q = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/smartphone.svg.rollup-plugin.svelte";

    function create_fragment$S(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 320 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M272 0H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h224c26.5 0 48-21.5 48-48V48c0-26.5-21.5-48-48-48zM160 480c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm112-108c0 6.6-5.4 12-12 12H60c-6.6 0-12-5.4-12-12V60c0-6.6 5.4-12 12-12h200c6.6 0 12 5.4 12 12v312z");
    			add_location(path, file$Q, 0, 76, 76);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$Q, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 320 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$S.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$R($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Smartphone_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Smartphone_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$R, create_fragment$S, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Smartphone_svg_rollup_plugin",
    			options,
    			id: create_fragment$S.name
    		});
    	}
    }

    var smartphone_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Smartphone_svg_rollup_plugin
    });

    var require$$76 = /*@__PURE__*/getAugmentedNamespace(smartphone_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/square.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$P = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/square.svg.rollup-plugin.svelte";

    function create_fragment$R(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "square" },
    		{
    			class: "svg-inline--fa fa-square fa-w-14"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 448 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm16 400c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V80c0-8.8 7.2-16 16-16h352c8.8 0 16 7.2 16 16v352z");
    			add_location(path, file$P, 0, 202, 202);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$P, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "square" },
    				{
    					class: "svg-inline--fa fa-square fa-w-14"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 448 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$R.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Square_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Square_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Q, create_fragment$R, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Square_svg_rollup_plugin",
    			options,
    			id: create_fragment$R.name
    		});
    	}
    }

    var square_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Square_svg_rollup_plugin
    });

    var require$$77 = /*@__PURE__*/getAugmentedNamespace(square_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/star-half-solid.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$O = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/star-half-solid.svg.rollup-plugin.svelte";

    function create_fragment$Q(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fas" },
    		{ "data-icon": "star-half" },
    		{
    			class: "svg-inline--fa fa-star-half fa-w-18"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 576 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M288 0c-11.4 0-22.8 5.9-28.7 17.8L194 150.2 47.9 171.4c-26.2 3.8-36.7 36.1-17.7 54.6l105.7 103-25 145.5c-4.5 26.1 23 46 46.4 33.7L288 439.6V0z");
    			add_location(path, file$O, 0, 208, 208);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$O, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fas" },
    				{ "data-icon": "star-half" },
    				{
    					class: "svg-inline--fa fa-star-half fa-w-18"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 576 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$P($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Star_half_solid_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Star_half_solid_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$P, create_fragment$Q, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Star_half_solid_svg_rollup_plugin",
    			options,
    			id: create_fragment$Q.name
    		});
    	}
    }

    var starHalfSolid_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Star_half_solid_svg_rollup_plugin
    });

    var require$$78 = /*@__PURE__*/getAugmentedNamespace(starHalfSolid_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/star-solid.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$N = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/star-solid.svg.rollup-plugin.svelte";

    function create_fragment$P(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fas" },
    		{ "data-icon": "star" },
    		{ class: "svg-inline--fa fa-star fa-w-18" },
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 576 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M259.3 17.8L194 150.2 47.9 171.5c-26.2 3.8-36.7 36.1-17.7 54.6l105.7 103-25 145.5c-4.5 26.3 23.2 46 46.4 33.7L288 439.6l130.7 68.7c23.2 12.2 50.9-7.4 46.4-33.7l-25-145.5 105.7-103c19-18.5 8.5-50.8-17.7-54.6L382 150.2 316.7 17.8c-11.7-23.6-45.6-23.9-57.4 0z");
    			add_location(path, file$N, 0, 198, 198);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$N, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fas" },
    				{ "data-icon": "star" },
    				{ class: "svg-inline--fa fa-star fa-w-18" },
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 576 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$P.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$O($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Star_solid_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Star_solid_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$O, create_fragment$P, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Star_solid_svg_rollup_plugin",
    			options,
    			id: create_fragment$P.name
    		});
    	}
    }

    var starSolid_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Star_solid_svg_rollup_plugin
    });

    var require$$79 = /*@__PURE__*/getAugmentedNamespace(starSolid_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/star.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$M = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/star.svg.rollup-plugin.svelte";

    function create_fragment$O(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "star" },
    		{ class: "svg-inline--fa fa-star fa-w-18" },
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 576 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M528.1 171.5L382 150.2 316.7 17.8c-11.7-23.6-45.6-23.9-57.4 0L194 150.2 47.9 171.5c-26.2 3.8-36.7 36.1-17.7 54.6l105.7 103-25 145.5c-4.5 26.3 23.2 46 46.4 33.7L288 439.6l130.7 68.7c23.2 12.2 50.9-7.4 46.4-33.7l-25-145.5 105.7-103c19-18.5 8.5-50.8-17.7-54.6zM405.8 317.9l27.8 162L288 403.5 142.5 480l27.8-162L52.5 203.1l162.7-23.6L288 32l72.8 147.5 162.7 23.6-117.7 114.8z");
    			add_location(path, file$M, 0, 198, 198);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$M, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "star" },
    				{ class: "svg-inline--fa fa-star fa-w-18" },
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 576 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$O.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$N($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Star_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Star_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$N, create_fragment$O, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Star_svg_rollup_plugin",
    			options,
    			id: create_fragment$O.name
    		});
    	}
    }

    var star_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Star_svg_rollup_plugin
    });

    var require$$80 = /*@__PURE__*/getAugmentedNamespace(star_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/sync.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$L = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/sync.svg.rollup-plugin.svelte";

    function create_fragment$N(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "sync-alt" },
    		{
    			class: "svg-inline--fa fa-sync-alt fa-w-16"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M457.373 9.387l-50.095 50.102C365.411 27.211 312.953 8 256 8 123.228 8 14.824 112.338 8.31 243.493 7.971 250.311 13.475 256 20.301 256h10.015c6.352 0 11.647-4.949 11.977-11.293C48.159 131.913 141.389 42 256 42c47.554 0 91.487 15.512 127.02 41.75l-53.615 53.622c-20.1 20.1-5.855 54.628 22.627 54.628H480c17.673 0 32-14.327 32-32V32.015c0-28.475-34.564-42.691-54.627-22.628zM480 160H352L480 32v128zm11.699 96h-10.014c-6.353 0-11.647 4.949-11.977 11.293C463.84 380.203 370.504 470 256 470c-47.525 0-91.468-15.509-127.016-41.757l53.612-53.616c20.099-20.1 5.855-54.627-22.627-54.627H32c-17.673 0-32 14.327-32 32v127.978c0 28.614 34.615 42.641 54.627 22.627l50.092-50.096C146.587 484.788 199.046 504 256 504c132.773 0 241.176-104.338 247.69-235.493.339-6.818-5.165-12.507-11.991-12.507zM32 480V352h128L32 480z");
    			add_location(path, file$L, 0, 206, 206);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$L, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "sync-alt" },
    				{
    					class: "svg-inline--fa fa-sync-alt fa-w-16"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$N.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$M($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Sync_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Sync_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$M, create_fragment$N, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Sync_svg_rollup_plugin",
    			options,
    			id: create_fragment$N.name
    		});
    	}
    }

    var sync_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Sync_svg_rollup_plugin
    });

    var require$$81 = /*@__PURE__*/getAugmentedNamespace(sync_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/tablet.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$K = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/tablet.svg.rollup-plugin.svelte";

    function create_fragment$M(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fas" },
    		{ "data-icon": "tablet-alt" },
    		{
    			class: "svg-inline--fa fa-tablet-alt fa-w-14"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 448 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M400 0H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V48c0-26.5-21.5-48-48-48zM224 480c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm176-108c0 6.6-5.4 12-12 12H60c-6.6 0-12-5.4-12-12V60c0-6.6 5.4-12 12-12h328c6.6 0 12 5.4 12 12v312z");
    			add_location(path, file$K, 0, 210, 210);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$K, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fas" },
    				{ "data-icon": "tablet-alt" },
    				{
    					class: "svg-inline--fa fa-tablet-alt fa-w-14"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 448 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$M.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$L($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Tablet_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Tablet_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$L, create_fragment$M, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tablet_svg_rollup_plugin",
    			options,
    			id: create_fragment$M.name
    		});
    	}
    }

    var tablet_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Tablet_svg_rollup_plugin
    });

    var require$$82 = /*@__PURE__*/getAugmentedNamespace(tablet_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/tag-solid.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$J = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/tag-solid.svg.rollup-plugin.svelte";

    function create_fragment$L(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ id: "tag-solid" },
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fas" },
    		{ "data-icon": "tag" },
    		{ class: "svg-inline--fa fa-tag fa-w-16" },
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M0 252.118V48C0 21.49 21.49 0 48 0h204.118a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882 0L14.059 286.059A48 48 0 0 1 0 252.118zM112 64c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z");
    			add_location(path, file$J, 0, 211, 211);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$J, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ id: "tag-solid" },
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fas" },
    				{ "data-icon": "tag" },
    				{ class: "svg-inline--fa fa-tag fa-w-16" },
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$K($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Tag_solid_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Tag_solid_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$K, create_fragment$L, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tag_solid_svg_rollup_plugin",
    			options,
    			id: create_fragment$L.name
    		});
    	}
    }

    var tagSolid_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Tag_solid_svg_rollup_plugin
    });

    var require$$83 = /*@__PURE__*/getAugmentedNamespace(tagSolid_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/tag.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$I = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/tag.svg.rollup-plugin.svelte";

    function create_fragment$K(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "tag" },
    		{ class: "svg-inline--fa fa-tag fa-w-16" },
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M497.941 225.941L286.059 14.059A48 48 0 0 0 252.118 0H48C21.49 0 0 21.49 0 48v204.118a48 48 0 0 0 14.059 33.941l211.882 211.882c18.745 18.745 49.137 18.746 67.882 0l204.118-204.118c18.745-18.745 18.745-49.137 0-67.882zm-22.627 45.255L271.196 475.314c-6.243 6.243-16.375 6.253-22.627 0L36.686 263.431A15.895 15.895 0 0 1 32 252.117V48c0-8.822 7.178-16 16-16h204.118c4.274 0 8.292 1.664 11.314 4.686l211.882 211.882c6.238 6.239 6.238 16.39 0 22.628zM144 124c11.028 0 20 8.972 20 20s-8.972 20-20 20-20-8.972-20-20 8.972-20 20-20m0-28c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z");
    			add_location(path, file$I, 0, 196, 196);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$I, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "tag" },
    				{ class: "svg-inline--fa fa-tag fa-w-16" },
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$J($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Tag_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Tag_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$J, create_fragment$K, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tag_svg_rollup_plugin",
    			options,
    			id: create_fragment$K.name
    		});
    	}
    }

    var tag_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Tag_svg_rollup_plugin
    });

    var require$$84 = /*@__PURE__*/getAugmentedNamespace(tag_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/tags-solid.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$H = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/tags-solid.svg.rollup-plugin.svelte";

    function create_fragment$J(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ id: "tags-solid" },
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fas" },
    		{ "data-icon": "tags" },
    		{ class: "svg-inline--fa fa-tags fa-w-20" },
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 640 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M497.941 225.941L286.059 14.059A48 48 0 0 0 252.118 0H48C21.49 0 0 21.49 0 48v204.118a48 48 0 0 0 14.059 33.941l211.882 211.882c18.744 18.745 49.136 18.746 67.882 0l204.118-204.118c18.745-18.745 18.745-49.137 0-67.882zM112 160c-26.51 0-48-21.49-48-48s21.49-48 48-48 48 21.49 48 48-21.49 48-48 48zm513.941 133.823L421.823 497.941c-18.745 18.745-49.137 18.745-67.882 0l-.36-.36L527.64 323.522c16.999-16.999 26.36-39.6 26.36-63.64s-9.362-46.641-26.36-63.64L331.397 0h48.721a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882z");
    			add_location(path, file$H, 0, 214, 214);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$H, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ id: "tags-solid" },
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fas" },
    				{ "data-icon": "tags" },
    				{ class: "svg-inline--fa fa-tags fa-w-20" },
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 640 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$I($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Tags_solid_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Tags_solid_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$I, create_fragment$J, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tags_solid_svg_rollup_plugin",
    			options,
    			id: create_fragment$J.name
    		});
    	}
    }

    var tagsSolid_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Tags_solid_svg_rollup_plugin
    });

    var require$$85 = /*@__PURE__*/getAugmentedNamespace(tagsSolid_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/tags.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$G = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/tags.svg.rollup-plugin.svelte";

    function create_fragment$I(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "tags" },
    		{ class: "svg-inline--fa fa-tags fa-w-20" },
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 640 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M625.941 293.823L421.823 497.941c-18.746 18.746-49.138 18.745-67.882 0l-1.775-1.775 22.627-22.627 1.775 1.775c6.253 6.253 16.384 6.243 22.627 0l204.118-204.118c6.238-6.239 6.238-16.389 0-22.627L391.431 36.686A15.895 15.895 0 0 0 380.117 32h-19.549l-32-32h51.549a48 48 0 0 1 33.941 14.059L625.94 225.941c18.746 18.745 18.746 49.137.001 67.882zM252.118 32H48c-8.822 0-16 7.178-16 16v204.118c0 4.274 1.664 8.292 4.686 11.314l211.882 211.882c6.253 6.253 16.384 6.243 22.627 0l204.118-204.118c6.238-6.239 6.238-16.389 0-22.627L263.431 36.686A15.895 15.895 0 0 0 252.118 32m0-32a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.746 18.746-49.138 18.745-67.882 0L14.059 286.059A48 48 0 0 1 0 252.118V48C0 21.49 21.49 0 48 0h204.118zM144 124c-11.028 0-20 8.972-20 20s8.972 20 20 20 20-8.972 20-20-8.972-20-20-20m0-28c26.51 0 48 21.49 48 48s-21.49 48-48 48-48-21.49-48-48 21.49-48 48-48z");
    			add_location(path, file$G, 0, 198, 198);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$G, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "tags" },
    				{ class: "svg-inline--fa fa-tags fa-w-20" },
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 640 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$H($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Tags_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Tags_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$H, create_fragment$I, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tags_svg_rollup_plugin",
    			options,
    			id: create_fragment$I.name
    		});
    	}
    }

    var tags_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Tags_svg_rollup_plugin
    });

    var require$$86 = /*@__PURE__*/getAugmentedNamespace(tags_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/times-circle-solid.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$F = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/times-circle-solid.svg.rollup-plugin.svelte";

    function create_fragment$H(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fas" },
    		{ "data-icon": "times-circle" },
    		{
    			class: "svg-inline--fa fa-times-circle fa-w-16"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm121.6 313.1c4.7 4.7 4.7 12.3 0 17L338 377.6c-4.7 4.7-12.3 4.7-17 0L256 312l-65.1 65.6c-4.7 4.7-12.3 4.7-17 0L134.4 338c-4.7-4.7-4.7-12.3 0-17l65.6-65-65.6-65.1c-4.7-4.7-4.7-12.3 0-17l39.6-39.6c4.7-4.7 12.3-4.7 17 0l65 65.7 65.1-65.6c4.7-4.7 12.3-4.7 17 0l39.6 39.6c4.7 4.7 4.7 12.3 0 17L312 256l65.6 65.1z");
    			add_location(path, file$F, 0, 214, 214);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$F, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fas" },
    				{ "data-icon": "times-circle" },
    				{
    					class: "svg-inline--fa fa-times-circle fa-w-16"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$G($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Times_circle_solid_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Times_circle_solid_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$G, create_fragment$H, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Times_circle_solid_svg_rollup_plugin",
    			options,
    			id: create_fragment$H.name
    		});
    	}
    }

    var timesCircleSolid_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Times_circle_solid_svg_rollup_plugin
    });

    var require$$87 = /*@__PURE__*/getAugmentedNamespace(timesCircleSolid_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/times-circle.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$E = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/times-circle.svg.rollup-plugin.svelte";

    function create_fragment$G(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "times-circle" },
    		{
    			class: "svg-inline--fa fa-times-circle fa-w-16"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm0 464c-118.7 0-216-96.1-216-216 0-118.7 96.1-216 216-216 118.7 0 216 96.1 216 216 0 118.7-96.1 216-216 216zm94.8-285.3L281.5 256l69.3 69.3c4.7 4.7 4.7 12.3 0 17l-8.5 8.5c-4.7 4.7-12.3 4.7-17 0L256 281.5l-69.3 69.3c-4.7 4.7-12.3 4.7-17 0l-8.5-8.5c-4.7-4.7-4.7-12.3 0-17l69.3-69.3-69.3-69.3c-4.7-4.7-4.7-12.3 0-17l8.5-8.5c4.7-4.7 12.3-4.7 17 0l69.3 69.3 69.3-69.3c4.7-4.7 12.3-4.7 17 0l8.5 8.5c4.6 4.7 4.6 12.3 0 17z");
    			add_location(path, file$E, 0, 214, 214);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$E, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "times-circle" },
    				{
    					class: "svg-inline--fa fa-times-circle fa-w-16"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$F($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Times_circle_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Times_circle_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$F, create_fragment$G, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Times_circle_svg_rollup_plugin",
    			options,
    			id: create_fragment$G.name
    		});
    	}
    }

    var timesCircle_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Times_circle_svg_rollup_plugin
    });

    var require$$88 = /*@__PURE__*/getAugmentedNamespace(timesCircle_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/times.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$D = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/times.svg.rollup-plugin.svelte";

    function create_fragment$F(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "times" },
    		{ class: "svg-inline--fa fa-times fa-w-10" },
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 320 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M193.94 256L296.5 153.44l21.15-21.15c3.12-3.12 3.12-8.19 0-11.31l-22.63-22.63c-3.12-3.12-8.19-3.12-11.31 0L160 222.06 36.29 98.34c-3.12-3.12-8.19-3.12-11.31 0L2.34 120.97c-3.12 3.12-3.12 8.19 0 11.31L126.06 256 2.34 379.71c-3.12 3.12-3.12 8.19 0 11.31l22.63 22.63c3.12 3.12 8.19 3.12 11.31 0L160 289.94 262.56 392.5l21.15 21.15c3.12 3.12 8.19 3.12 11.31 0l22.63-22.63c3.12-3.12 3.12-8.19 0-11.31L193.94 256z");
    			add_location(path, file$D, 0, 200, 200);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$D, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "times" },
    				{ class: "svg-inline--fa fa-times fa-w-10" },
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 320 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$E($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Times_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Times_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$E, create_fragment$F, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Times_svg_rollup_plugin",
    			options,
    			id: create_fragment$F.name
    		});
    	}
    }

    var times_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Times_svg_rollup_plugin
    });

    var require$$89 = /*@__PURE__*/getAugmentedNamespace(times_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/toggle-off.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$C = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/toggle-off.svg.rollup-plugin.svelte";

    function create_fragment$E(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "toggle-off" },
    		{
    			class: "svg-inline--fa fa-toggle-off fa-w-18"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 576 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M384 96c42.738 0 82.917 16.643 113.137 46.863S544 213.262 544 256s-16.643 82.917-46.863 113.137S426.738 416 384 416H192c-42.738 0-82.917-16.643-113.137-46.863S32 298.738 32 256s16.643-82.917 46.863-113.137S149.262 96 192 96h192m0-32H192C85.961 64 0 149.961 0 256s85.961 192 192 192h192c106.039 0 192-85.961 192-192S490.039 64 384 64zm-192 96c52.935 0 96 43.065 96 96s-43.065 96-96 96-96-43.065-96-96 43.065-96 96-96m0-32c-70.692 0-128 57.307-128 128s57.308 128 128 128 128-57.307 128-128-57.308-128-128-128z");
    			add_location(path, file$C, 0, 210, 210);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$C, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "toggle-off" },
    				{
    					class: "svg-inline--fa fa-toggle-off fa-w-18"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 576 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$D($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Toggle_off_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Toggle_off_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$D, create_fragment$E, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Toggle_off_svg_rollup_plugin",
    			options,
    			id: create_fragment$E.name
    		});
    	}
    }

    var toggleOff_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Toggle_off_svg_rollup_plugin
    });

    var require$$90 = /*@__PURE__*/getAugmentedNamespace(toggleOff_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/toggle-on.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$B = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/toggle-on.svg.rollup-plugin.svelte";

    function create_fragment$D(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fas" },
    		{ "data-icon": "toggle-on" },
    		{
    			class: "svg-inline--fa fa-toggle-on fa-w-18"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 576 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M384 64H192C86 64 0 150 0 256s86 192 192 192h192c106 0 192-86 192-192S490 64 384 64zm0 320c-70.8 0-128-57.3-128-128 0-70.8 57.3-128 128-128 70.8 0 128 57.3 128 128 0 70.8-57.3 128-128 128z");
    			add_location(path, file$B, 0, 208, 208);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$B, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fas" },
    				{ "data-icon": "toggle-on" },
    				{
    					class: "svg-inline--fa fa-toggle-on fa-w-18"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 576 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$C($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Toggle_on_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Toggle_on_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$C, create_fragment$D, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Toggle_on_svg_rollup_plugin",
    			options,
    			id: create_fragment$D.name
    		});
    	}
    }

    var toggleOn_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Toggle_on_svg_rollup_plugin
    });

    var require$$91 = /*@__PURE__*/getAugmentedNamespace(toggleOn_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/trash-solid.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$A = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/trash-solid.svg.rollup-plugin.svelte";

    function create_fragment$C(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fas" },
    		{ "data-icon": "trash-alt" },
    		{
    			class: "svg-inline--fa fa-trash-alt fa-w-14"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 448 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M32 464a48 48 0 0 0 48 48h288a48 48 0 0 0 48-48V128H32zm272-256a16 16 0 0 1 32 0v224a16 16 0 0 1-32 0zm-96 0a16 16 0 0 1 32 0v224a16 16 0 0 1-32 0zm-96 0a16 16 0 0 1 32 0v224a16 16 0 0 1-32 0zM432 32H312l-9.4-18.7A24 24 0 0 0 281.1 0H166.8a23.72 23.72 0 0 0-21.4 13.3L136 32H16A16 16 0 0 0 0 48v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16z");
    			add_location(path, file$A, 0, 208, 208);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$A, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fas" },
    				{ "data-icon": "trash-alt" },
    				{
    					class: "svg-inline--fa fa-trash-alt fa-w-14"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 448 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$B($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Trash_solid_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Trash_solid_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$B, create_fragment$C, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Trash_solid_svg_rollup_plugin",
    			options,
    			id: create_fragment$C.name
    		});
    	}
    }

    var trashSolid_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Trash_solid_svg_rollup_plugin
    });

    var require$$92 = /*@__PURE__*/getAugmentedNamespace(trashSolid_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/trash.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$z = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/trash.svg.rollup-plugin.svelte";

    function create_fragment$B(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "trash-alt" },
    		{
    			class: "svg-inline--fa fa-trash-alt fa-w-14"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 448 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M296 432h16a8 8 0 0 0 8-8V152a8 8 0 0 0-8-8h-16a8 8 0 0 0-8 8v272a8 8 0 0 0 8 8zm-160 0h16a8 8 0 0 0 8-8V152a8 8 0 0 0-8-8h-16a8 8 0 0 0-8 8v272a8 8 0 0 0 8 8zM440 64H336l-33.6-44.8A48 48 0 0 0 264 0h-80a48 48 0 0 0-38.4 19.2L112 64H8a8 8 0 0 0-8 8v16a8 8 0 0 0 8 8h24v368a48 48 0 0 0 48 48h288a48 48 0 0 0 48-48V96h24a8 8 0 0 0 8-8V72a8 8 0 0 0-8-8zM171.2 38.4A16.1 16.1 0 0 1 184 32h80a16.1 16.1 0 0 1 12.8 6.4L296 64H152zM384 464a16 16 0 0 1-16 16H80a16 16 0 0 1-16-16V96h320zm-168-32h16a8 8 0 0 0 8-8V152a8 8 0 0 0-8-8h-16a8 8 0 0 0-8 8v272a8 8 0 0 0 8 8z");
    			add_location(path, file$z, 0, 208, 208);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$z, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "trash-alt" },
    				{
    					class: "svg-inline--fa fa-trash-alt fa-w-14"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 448 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$A($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Trash_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Trash_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$A, create_fragment$B, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Trash_svg_rollup_plugin",
    			options,
    			id: create_fragment$B.name
    		});
    	}
    }

    var trash_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Trash_svg_rollup_plugin
    });

    var require$$93 = /*@__PURE__*/getAugmentedNamespace(trash_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/twitter.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$y = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/twitter.svg.rollup-plugin.svelte";

    function create_fragment$A(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fab" },
    		{ "data-icon": "twitter" },
    		{
    			class: "svg-inline--fa fa-twitter fa-w-16"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z");
    			add_location(path, file$y, 0, 204, 204);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$y, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fab" },
    				{ "data-icon": "twitter" },
    				{
    					class: "svg-inline--fa fa-twitter fa-w-16"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Twitter_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Twitter_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$z, create_fragment$A, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Twitter_svg_rollup_plugin",
    			options,
    			id: create_fragment$A.name
    		});
    	}
    }

    var twitter_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Twitter_svg_rollup_plugin
    });

    var require$$94 = /*@__PURE__*/getAugmentedNamespace(twitter_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/user-circle-solid.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$x = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/user-circle-solid.svg.rollup-plugin.svelte";

    function create_fragment$z(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fas" },
    		{ "data-icon": "user-circle" },
    		{
    			class: "svg-inline--fa fa-user-circle fa-w-16"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 496 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm0 96c48.6 0 88 39.4 88 88s-39.4 88-88 88-88-39.4-88-88 39.4-88 88-88zm0 344c-58.7 0-111.3-26.6-146.5-68.2 18.8-35.4 55.6-59.8 98.5-59.8 2.4 0 4.8.4 7.1 1.1 13 4.2 26.6 6.9 40.9 6.9 14.3 0 28-2.7 40.9-6.9 2.3-.7 4.7-1.1 7.1-1.1 42.9 0 79.7 24.4 98.5 59.8C359.3 421.4 306.7 448 248 448z");
    			add_location(path, file$x, 0, 212, 212);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$x, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fas" },
    				{ "data-icon": "user-circle" },
    				{
    					class: "svg-inline--fa fa-user-circle fa-w-16"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 496 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('User_circle_solid_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class User_circle_solid_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$y, create_fragment$z, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "User_circle_solid_svg_rollup_plugin",
    			options,
    			id: create_fragment$z.name
    		});
    	}
    }

    var userCircleSolid_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': User_circle_solid_svg_rollup_plugin
    });

    var require$$95 = /*@__PURE__*/getAugmentedNamespace(userCircleSolid_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/user-circle.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$w = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/user-circle.svg.rollup-plugin.svelte";

    function create_fragment$y(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "user-circle" },
    		{
    			class: "svg-inline--fa fa-user-circle fa-w-16"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 496 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm128 421.6c-35.9 26.5-80.1 42.4-128 42.4s-92.1-15.9-128-42.4V416c0-35.3 28.7-64 64-64 11.1 0 27.5 11.4 64 11.4 36.6 0 52.8-11.4 64-11.4 35.3 0 64 28.7 64 64v13.6zm30.6-27.5c-6.8-46.4-46.3-82.1-94.6-82.1-20.5 0-30.4 11.4-64 11.4S204.6 320 184 320c-48.3 0-87.8 35.7-94.6 82.1C53.9 363.6 32 312.4 32 256c0-119.1 96.9-216 216-216s216 96.9 216 216c0 56.4-21.9 107.6-57.4 146.1zM248 120c-48.6 0-88 39.4-88 88s39.4 88 88 88 88-39.4 88-88-39.4-88-88-88zm0 144c-30.9 0-56-25.1-56-56s25.1-56 56-56 56 25.1 56 56-25.1 56-56 56z");
    			add_location(path, file$w, 0, 212, 212);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$w, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "user-circle" },
    				{
    					class: "svg-inline--fa fa-user-circle fa-w-16"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 496 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$x($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('User_circle_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class User_circle_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$x, create_fragment$y, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "User_circle_svg_rollup_plugin",
    			options,
    			id: create_fragment$y.name
    		});
    	}
    }

    var userCircle_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': User_circle_svg_rollup_plugin
    });

    var require$$96 = /*@__PURE__*/getAugmentedNamespace(userCircle_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/user-solid.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$v = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/user-solid.svg.rollup-plugin.svelte";

    function create_fragment$x(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fas" },
    		{ "data-icon": "user" },
    		{ class: "svg-inline--fa fa-user fa-w-14" },
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 448 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M224 256c70.7 0 128-57.3 128-128S294.7 0 224 0 96 57.3 96 128s57.3 128 128 128zm89.6 32h-16.7c-22.2 10.2-46.9 16-72.9 16s-50.6-5.8-72.9-16h-16.7C60.2 288 0 348.2 0 422.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-41.6c0-74.2-60.2-134.4-134.4-134.4z");
    			add_location(path, file$v, 0, 198, 198);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$v, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fas" },
    				{ "data-icon": "user" },
    				{ class: "svg-inline--fa fa-user fa-w-14" },
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 448 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('User_solid_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class User_solid_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$w, create_fragment$x, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "User_solid_svg_rollup_plugin",
    			options,
    			id: create_fragment$x.name
    		});
    	}
    }

    var userSolid_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': User_solid_svg_rollup_plugin
    });

    var require$$97 = /*@__PURE__*/getAugmentedNamespace(userSolid_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/users.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$u = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/users.svg.rollup-plugin.svelte";

    function create_fragment$w(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 640 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M544 224c44.2 0 80-35.8 80-80s-35.8-80-80-80-80 35.8-80 80 35.8 80 80 80zm0-128c26.5 0 48 21.5 48 48s-21.5 48-48 48-48-21.5-48-48 21.5-48 48-48zM320 256c61.9 0 112-50.1 112-112S381.9 32 320 32 208 82.1 208 144s50.1 112 112 112zm0-192c44.1 0 80 35.9 80 80s-35.9 80-80 80-80-35.9-80-80 35.9-80 80-80zm244 192h-40c-15.2 0-29.3 4.8-41.1 12.9 9.4 6.4 17.9 13.9 25.4 22.4 4.9-2.1 10.2-3.3 15.7-3.3h40c24.2 0 44 21.5 44 48 0 8.8 7.2 16 16 16s16-7.2 16-16c0-44.1-34.1-80-76-80zM96 224c44.2 0 80-35.8 80-80s-35.8-80-80-80-80 35.8-80 80 35.8 80 80 80zm0-128c26.5 0 48 21.5 48 48s-21.5 48-48 48-48-21.5-48-48 21.5-48 48-48zm304.1 180c-33.4 0-41.7 12-80.1 12-38.4 0-46.7-12-80.1-12-36.3 0-71.6 16.2-92.3 46.9-12.4 18.4-19.6 40.5-19.6 64.3V432c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48v-44.8c0-23.8-7.2-45.9-19.6-64.3-20.7-30.7-56-46.9-92.3-46.9zM480 432c0 8.8-7.2 16-16 16H176c-8.8 0-16-7.2-16-16v-44.8c0-16.6 4.9-32.7 14.1-46.4 13.8-20.5 38.4-32.8 65.7-32.8 27.4 0 37.2 12 80.2 12s52.8-12 80.1-12c27.3 0 51.9 12.3 65.7 32.8 9.2 13.7 14.1 29.8 14.1 46.4V432zM157.1 268.9c-11.9-8.1-26-12.9-41.1-12.9H76c-41.9 0-76 35.9-76 80 0 8.8 7.2 16 16 16s16-7.2 16-16c0-26.5 19.8-48 44-48h40c5.5 0 10.8 1.2 15.7 3.3 7.5-8.5 16.1-16 25.4-22.4z");
    			add_location(path, file$u, 0, 95, 95);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$u, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 640 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$v($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Users_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Users_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$v, create_fragment$w, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Users_svg_rollup_plugin",
    			options,
    			id: create_fragment$w.name
    		});
    	}
    }

    var users_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Users_svg_rollup_plugin
    });

    var require$$98 = /*@__PURE__*/getAugmentedNamespace(users_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/video.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$t = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/video.svg.rollup-plugin.svelte";

    function create_fragment$v(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ version: "1.1" },
    		{ id: "Layer_1" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{
    			"xmlns:xlink": "http://www.w3.org/1999/xlink"
    		},
    		{ x: "0px" },
    		{ y: "0px" },
    		{ viewBox: "0 0 51 48" },
    		{
    			style: "enable-background:new 0 0 51 48;"
    		},
    		{ "xml:space": "preserve" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M45,47.5H6.1c-3.1,0-5.6-2.5-5.6-5.6V6.1C0.5,3,3,0.5,6.1,0.5H45c3.1,0,5.6,2.5,5.6,5.6v35.8\n\tC50.6,45,48.1,47.5,45,47.5z M6.1,3.5c-1.4,0-2.6,1.2-2.6,2.6v35.8c0,1.4,1.2,2.6,2.6,2.6H45c1.4,0,2.6-1.2,2.6-2.6V6.1\n\tc0-1.4-1.2-2.6-2.6-2.6H6.1z M30.7,43.4c-2.1,0-3.5-1.5-3.5-3.5v-0.5h-19c-0.8,0-1.5-0.7-1.5-1.5s0.7-1.5,1.5-1.5h19v-0.5\n\tc0-2.1,1.5-3.5,3.5-3.5s3.5,1.5,3.5,3.5v0.5H43c0.8,0,1.5,0.7,1.5,1.5s-0.7,1.5-1.5,1.5h-8.7v0.5C34.2,41.9,32.8,43.4,30.7,43.4z\n\t M30.1,37.8v2c0,0.4,0.1,0.5,0.5,0.5s0.5-0.1,0.5-0.5v-4.1c0-0.4-0.1-0.5-0.5-0.5s-0.5,0.1-0.5,0.5V37.8z M20.2,30.3\n\tc-0.5,0-0.9-0.1-1.3-0.4c-0.8-0.5-1.3-1.3-1.3-2.3V13.7c0-1,0.6-1.9,1.4-2.4c0.9-0.5,1.9-0.4,2.6,0.1l12,6.9\n\tc0.8,0.4,1.4,1.3,1.4,2.3c0,1-0.6,1.9-1.4,2.4l-12,6.9c0,0-0.1,0-0.1,0C21.1,30.2,20.6,30.3,20.2,30.3z M20.8,28.7L20.8,28.7\n\tL20.8,28.7z M20.9,27.6C20.9,27.6,20.9,27.6,20.9,27.6C20.9,27.6,20.9,27.6,20.9,27.6z M20.7,14.3V27l11-6.3L20.7,14.3z M32.2,21\n\tC32.2,21,32.2,21,32.2,21L32.2,21z M32.2,20.4C32.2,20.4,32.2,20.4,32.2,20.4L32.2,20.4z M19.8,13.8C19.8,13.8,19.8,13.8,19.8,13.8\n\tC19.8,13.8,19.8,13.8,19.8,13.8z");
    			add_location(path, file$t, 11, 2, 244);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$t, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ version: "1.1" },
    				{ id: "Layer_1" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{
    					"xmlns:xlink": "http://www.w3.org/1999/xlink"
    				},
    				{ x: "0px" },
    				{ y: "0px" },
    				{ viewBox: "0 0 51 48" },
    				{
    					style: "enable-background:new 0 0 51 48;"
    				},
    				{ "xml:space": "preserve" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Video_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Video_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$u, create_fragment$v, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Video_svg_rollup_plugin",
    			options,
    			id: create_fragment$v.name
    		});
    	}
    }

    var video_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Video_svg_rollup_plugin
    });

    var require$$99 = /*@__PURE__*/getAugmentedNamespace(video_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/volume-muted-solid.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$s = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/volume-muted-solid.svg.rollup-plugin.svelte";

    function create_fragment$u(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fas" },
    		{ "data-icon": "volume-slash" },
    		{
    			class: "svg-inline--fa fa-volume-slash fa-w-20"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 640 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M633.82 458.1l-69-53.33C592.42 360.8 608 309.68 608 256c0-95.33-47.73-183.58-127.65-236.03-11.17-7.33-26.18-4.24-33.51 6.95-7.34 11.17-4.22 26.18 6.95 33.51 66.27 43.49 105.82 116.6 105.82 195.58 0 42.78-11.96 83.59-33.22 119.06l-38.12-29.46C503.49 318.68 512 288.06 512 256c0-63.09-32.06-122.09-85.77-156.16-11.19-7.09-26.03-3.8-33.12 7.41-7.09 11.2-3.78 26.03 7.41 33.13C440.27 165.59 464 209.44 464 256c0 21.21-5.03 41.57-14.2 59.88l-39.56-30.58c3.38-9.35 5.76-19.07 5.76-29.3 0-31.88-17.53-61.33-45.77-76.88-11.58-6.33-26.19-2.16-32.61 9.45-6.39 11.61-2.16 26.2 9.45 32.61 11.76 6.46 19.12 18.18 20.4 31.06L288 190.82V88.02c0-21.46-25.96-31.98-40.97-16.97l-49.71 49.7L45.47 3.37C38.49-2.05 28.43-.8 23.01 6.18L3.37 31.45C-2.05 38.42-.8 48.47 6.18 53.9l588.36 454.73c6.98 5.43 17.03 4.17 22.46-2.81l19.64-25.27c5.41-6.97 4.16-17.02-2.82-22.45zM32 184v144c0 13.25 10.74 24 24 24h102.06l88.97 88.95c15.03 15.03 40.97 4.47 40.97-16.97V352.6L43.76 163.84C36.86 168.05 32 175.32 32 184z");
    			add_location(path, file$s, 0, 214, 214);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$s, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fas" },
    				{ "data-icon": "volume-slash" },
    				{
    					class: "svg-inline--fa fa-volume-slash fa-w-20"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 640 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Volume_muted_solid_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Volume_muted_solid_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$t, create_fragment$u, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Volume_muted_solid_svg_rollup_plugin",
    			options,
    			id: create_fragment$u.name
    		});
    	}
    }

    var volumeMutedSolid_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Volume_muted_solid_svg_rollup_plugin
    });

    var require$$100 = /*@__PURE__*/getAugmentedNamespace(volumeMutedSolid_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/volume-up-solid.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$r = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/volume-up-solid.svg.rollup-plugin.svelte";

    function create_fragment$t(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fas" },
    		{ "data-icon": "volume-up" },
    		{
    			class: "svg-inline--fa fa-volume-up fa-w-18"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 576 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M215.03 71.05L126.06 160H24c-13.26 0-24 10.74-24 24v144c0 13.25 10.74 24 24 24h102.06l88.97 88.95c15.03 15.03 40.97 4.47 40.97-16.97V88.02c0-21.46-25.96-31.98-40.97-16.97zm233.32-51.08c-11.17-7.33-26.18-4.24-33.51 6.95-7.34 11.17-4.22 26.18 6.95 33.51 66.27 43.49 105.82 116.6 105.82 195.58 0 78.98-39.55 152.09-105.82 195.58-11.17 7.32-14.29 22.34-6.95 33.5 7.04 10.71 21.93 14.56 33.51 6.95C528.27 439.58 576 351.33 576 256S528.27 72.43 448.35 19.97zM480 256c0-63.53-32.06-121.94-85.77-156.24-11.19-7.14-26.03-3.82-33.12 7.46s-3.78 26.21 7.41 33.36C408.27 165.97 432 209.11 432 256s-23.73 90.03-63.48 115.42c-11.19 7.14-14.5 22.07-7.41 33.36 6.51 10.36 21.12 15.14 33.12 7.46C447.94 377.94 480 319.54 480 256zm-141.77-76.87c-11.58-6.33-26.19-2.16-32.61 9.45-6.39 11.61-2.16 26.2 9.45 32.61C327.98 228.28 336 241.63 336 256c0 14.38-8.02 27.72-20.92 34.81-11.61 6.41-15.84 21-9.45 32.61 6.43 11.66 21.05 15.8 32.61 9.45 28.23-15.55 45.77-45 45.77-76.88s-17.54-61.32-45.78-76.86z");
    			add_location(path, file$r, 0, 208, 208);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$r, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fas" },
    				{ "data-icon": "volume-up" },
    				{
    					class: "svg-inline--fa fa-volume-up fa-w-18"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 576 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Volume_up_solid_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Volume_up_solid_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$s, create_fragment$t, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Volume_up_solid_svg_rollup_plugin",
    			options,
    			id: create_fragment$t.name
    		});
    	}
    }

    var volumeUpSolid_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Volume_up_solid_svg_rollup_plugin
    });

    var require$$101 = /*@__PURE__*/getAugmentedNamespace(volumeUpSolid_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/youtube.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$q = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/svgs/youtube.svg.rollup-plugin.svelte";

    function create_fragment$s(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fab" },
    		{ "data-icon": "youtube" },
    		{
    			class: "svg-inline--fa fa-youtube fa-w-18"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 576 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M549.655 124.083c-6.281-23.65-24.787-42.276-48.284-48.597C458.781 64 288 64 288 64S117.22 64 74.629 75.486c-23.497 6.322-42.003 24.947-48.284 48.597-11.412 42.867-11.412 132.305-11.412 132.305s0 89.438 11.412 132.305c6.281 23.65 24.787 41.5 48.284 47.821C117.22 448 288 448 288 448s170.78 0 213.371-11.486c23.497-6.321 42.003-24.171 48.284-47.821 11.412-42.867 11.412-132.305 11.412-132.305s0-89.438-11.412-132.305zm-317.51 213.508V175.185l142.739 81.205-142.739 81.201z");
    			add_location(path, file$q, 0, 204, 204);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$q, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fab" },
    				{ "data-icon": "youtube" },
    				{
    					class: "svg-inline--fa fa-youtube fa-w-18"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 576 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Youtube_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Youtube_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$r, create_fragment$s, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Youtube_svg_rollup_plugin",
    			options,
    			id: create_fragment$s.name
    		});
    	}
    }

    var youtube_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Youtube_svg_rollup_plugin
    });

    var require$$102 = /*@__PURE__*/getAugmentedNamespace(youtube_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/graphics/ebplus-red.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$p = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/graphics/ebplus-red.svg.rollup-plugin.svelte";

    function create_fragment$r(ctx) {
    	let svg;
    	let g0;
    	let rect0;
    	let g1;
    	let polygon;
    	let g2;
    	let rect1;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 365 365" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			g0 = svg_element("g");
    			rect0 = svg_element("rect");
    			g1 = svg_element("g");
    			polygon = svg_element("polygon");
    			g2 = svg_element("g");
    			rect1 = svg_element("rect");
    			attr_dev(rect0, "x", "135.00002");
    			attr_dev(rect0, "width", "95");
    			attr_dev(rect0, "height", "365");
    			set_style(rect0, "fill", "#c60000");
    			add_location(rect0, file$p, 2, 4, 96);
    			attr_dev(g0, "id", "leg");
    			add_location(g0, file$p, 1, 2, 79);
    			attr_dev(polygon, "points", "135 230 135 263.493 230 230 135 230");
    			set_style(polygon, "fill", "#010101");
    			add_location(polygon, file$p, 5, 4, 194);
    			attr_dev(g1, "id", "shadow2");
    			add_location(g1, file$p, 4, 2, 173);
    			attr_dev(rect1, "x", "135.00002");
    			attr_dev(rect1, "y", "0.00001");
    			attr_dev(rect1, "width", "95");
    			attr_dev(rect1, "height", "364.99999");
    			attr_dev(rect1, "transform", "translate(365.00002 -0.00002) rotate(90)");
    			set_style(rect1, "fill", "#c60000");
    			add_location(rect1, file$p, 8, 4, 298);
    			attr_dev(g2, "id", "arm");
    			add_location(g2, file$p, 7, 2, 281);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$p, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, g0);
    			append_dev(g0, rect0);
    			append_dev(svg, g1);
    			append_dev(g1, polygon);
    			append_dev(svg, g2);
    			append_dev(g2, rect1);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 365 365" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Ebplus_red_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Ebplus_red_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$q, create_fragment$r, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Ebplus_red_svg_rollup_plugin",
    			options,
    			id: create_fragment$r.name
    		});
    	}
    }

    var ebplusRed_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Ebplus_red_svg_rollup_plugin
    });

    var require$$103 = /*@__PURE__*/getAugmentedNamespace(ebplusRed_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/graphics/ebplus-white-blackshadow.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$o = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/graphics/ebplus-white-blackshadow.svg.rollup-plugin.svelte";

    function create_fragment$q(ctx) {
    	let svg;
    	let g0;
    	let rect0;
    	let g1;
    	let polygon;
    	let g2;
    	let rect1;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 365 365" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			g0 = svg_element("g");
    			rect0 = svg_element("rect");
    			g1 = svg_element("g");
    			polygon = svg_element("polygon");
    			g2 = svg_element("g");
    			rect1 = svg_element("rect");
    			attr_dev(rect0, "x", "135.00002");
    			attr_dev(rect0, "width", "95");
    			attr_dev(rect0, "height", "365");
    			set_style(rect0, "fill", "#fff");
    			add_location(rect0, file$o, 2, 4, 96);
    			attr_dev(g0, "id", "leg");
    			add_location(g0, file$o, 1, 2, 79);
    			attr_dev(polygon, "points", "135 230 135 263.493 230 230 135 230");
    			set_style(polygon, "fill", "#333");
    			add_location(polygon, file$o, 5, 4, 191);
    			attr_dev(g1, "id", "shadow2");
    			add_location(g1, file$o, 4, 2, 170);
    			attr_dev(rect1, "x", "135.00002");
    			attr_dev(rect1, "y", "0.00001");
    			attr_dev(rect1, "width", "95");
    			attr_dev(rect1, "height", "364.99999");
    			attr_dev(rect1, "transform", "translate(365.00002 -0.00002) rotate(90)");
    			set_style(rect1, "fill", "#fff");
    			add_location(rect1, file$o, 8, 4, 292);
    			attr_dev(g2, "id", "arm");
    			add_location(g2, file$o, 7, 2, 275);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$o, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, g0);
    			append_dev(g0, rect0);
    			append_dev(svg, g1);
    			append_dev(g1, polygon);
    			append_dev(svg, g2);
    			append_dev(g2, rect1);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 365 365" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Ebplus_white_blackshadow_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Ebplus_white_blackshadow_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$p, create_fragment$q, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Ebplus_white_blackshadow_svg_rollup_plugin",
    			options,
    			id: create_fragment$q.name
    		});
    	}
    }

    var ebplusWhiteBlackshadow_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Ebplus_white_blackshadow_svg_rollup_plugin
    });

    var require$$104 = /*@__PURE__*/getAugmentedNamespace(ebplusWhiteBlackshadow_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/graphics/ebplus-white.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$n = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/graphics/ebplus-white.svg.rollup-plugin.svelte";

    function create_fragment$p(ctx) {
    	let svg;
    	let g0;
    	let rect0;
    	let g1;
    	let polygon;
    	let g2;
    	let rect1;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 365 365" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			g0 = svg_element("g");
    			rect0 = svg_element("rect");
    			g1 = svg_element("g");
    			polygon = svg_element("polygon");
    			g2 = svg_element("g");
    			rect1 = svg_element("rect");
    			attr_dev(rect0, "x", "135.00002");
    			attr_dev(rect0, "width", "95");
    			attr_dev(rect0, "height", "365");
    			set_style(rect0, "fill", "#fff");
    			add_location(rect0, file$n, 2, 4, 96);
    			attr_dev(g0, "id", "leg");
    			add_location(g0, file$n, 1, 2, 79);
    			attr_dev(polygon, "points", "135 230 135 263.493 230 230 135 230");
    			set_style(polygon, "fill", "#690000");
    			add_location(polygon, file$n, 5, 4, 191);
    			attr_dev(g1, "id", "shadow2");
    			add_location(g1, file$n, 4, 2, 170);
    			attr_dev(rect1, "x", "135.00002");
    			attr_dev(rect1, "y", "0.00001");
    			attr_dev(rect1, "width", "95");
    			attr_dev(rect1, "height", "364.99999");
    			attr_dev(rect1, "transform", "translate(365.00002 -0.00002) rotate(90)");
    			set_style(rect1, "fill", "#fff");
    			add_location(rect1, file$n, 8, 4, 295);
    			attr_dev(g2, "id", "arm");
    			add_location(g2, file$n, 7, 2, 278);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$n, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, g0);
    			append_dev(g0, rect0);
    			append_dev(svg, g1);
    			append_dev(g1, polygon);
    			append_dev(svg, g2);
    			append_dev(g2, rect1);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 365 365" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Ebplus_white_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Ebplus_white_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$o, create_fragment$p, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Ebplus_white_svg_rollup_plugin",
    			options,
    			id: create_fragment$p.name
    		});
    	}
    }

    var ebplusWhite_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Ebplus_white_svg_rollup_plugin
    });

    var require$$105 = /*@__PURE__*/getAugmentedNamespace(ebplusWhite_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/graphics/ekstrabladet.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$m = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/graphics/ekstrabladet.svg.rollup-plugin.svelte";

    function create_fragment$o(ctx) {
    	let svg;
    	let g;
    	let path0;
    	let polygon0;
    	let polygon1;
    	let path1;
    	let path2;
    	let path3;
    	let path4;
    	let path5;
    	let rect;
    	let path6;
    	let path7;
    	let path8;
    	let path9;

    	let svg_levels = [
    		{ version: "1.1" },
    		{ id: "logo" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{
    			"xmlns:xlink": "http://www.w3.org/1999/xlink"
    		},
    		{ x: "0px" },
    		{ y: "0px" },
    		{ viewBox: "0 0 100 88" },
    		{ "enable-background": "new 0 0 100 88" },
    		{ "xml:space": "preserve" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			g = svg_element("g");
    			path0 = svg_element("path");
    			polygon0 = svg_element("polygon");
    			polygon1 = svg_element("polygon");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			path3 = svg_element("path");
    			path4 = svg_element("path");
    			path5 = svg_element("path");
    			rect = svg_element("rect");
    			path6 = svg_element("path");
    			path7 = svg_element("path");
    			path8 = svg_element("path");
    			path9 = svg_element("path");
    			attr_dev(path0, "fill", "#B30000");
    			attr_dev(path0, "d", "M0-0.9h100V78l-49.5,9.5L0,77.6V-0.9L0-0.9z");
    			add_location(path0, file$m, 4, 1, 223);
    			attr_dev(polygon0, "fill", "#FFFFFF");
    			attr_dev(polygon0, "points", "23,42.3 10.6,42.3 10.6,37.8 20.4,37.8 20.4,34.4 10.6,34.4 10.6,29.8 22.1,29.8 22.1,26.5\n\t\t6.1,26.5 6.1,46.1 23.1,46.1 \t\t");
    			add_location(polygon0, file$m, 6, 1, 295);
    			attr_dev(polygon1, "fill", "#FFFFFF");
    			attr_dev(polygon1, "points", "39.7,46.1 33.7,37.3 38.7,31.9 33.9,31.9 28.7,37.5 28.7,26.5 24.8,26.5 24.8,46.1 28.7,46.1\n\t\t28.7,42.2 31,39.9 34.8,46.1 \t\t");
    			add_location(polygon1, file$m, 8, 1, 462);
    			attr_dev(path1, "fill", "#FFFFFF");
    			attr_dev(path1, "d", "M46.3,43.9c-2.4,0-3.1-0.5-3.5-2h-3.7c0,3.1,2.5,4.9,6.7,4.9c4.7,0,7.5-1.8,7.5-4.8c0-2-1.6-3.7-3.6-4.1\n\t\tL44.1,37c-0.6-0.1-1.2-0.7-1.2-1.4c0-0.8,0.8-1.4,2.3-1.4c3,0,3.5,0.4,3.6,2h3.8v-0.5c0-2.4-2.8-4.5-6.5-4.5\n\t\tc-4.2,0-6.9,1.8-6.9,4.9c0,1.8,1.3,3.6,3,3.8l5.8,1c0.8,0.1,1.3,0.5,1.3,1.2C49.4,43.3,48.5,43.9,46.3,43.9z");
    			add_location(path1, file$m, 10, 1, 631);
    			attr_dev(path2, "fill", "#FFFFFF");
    			attr_dev(path2, "d", "M56.5,42.6c0,2.6,1.7,4.2,4.7,4.2c1.1,0,2-0.2,3.6-1v-1.9c-0.7,0.1-1.7,0.1-2,0.1c-1.6,0-2.2-0.6-2.2-1.8\n\t\tv-7.6h3.8V32h-3.8v-5.4h-2.9l-0.1,1.2C57,31.6,56.9,32,55.8,32h-2.5v2.6h3.4L56.5,42.6z");
    			add_location(path2, file$m, 13, 1, 984);
    			attr_dev(path3, "fill", "#FFFFFF");
    			attr_dev(path3, "d", "M70.8,39.9c0-3.1,1.7-4.8,4.7-4.8h1.7v-3.6H76c-2.3,0-4.1,1.1-5.3,3.2V32h-3.8v14.2h4V39.9z");
    			add_location(path3, file$m, 17, 1, 1213);
    			attr_dev(path4, "fill", "#FFFFFF");
    			attr_dev(path4, "d", "M91,41.5v-3.1v-2.8c0-1.7-0.2-2.3-1-2.8c-1.3-1.1-3.4-1.6-5.8-1.6c-4.3,0-6.3,1.4-6.6,4.8h3.7\n\t\tc0.2-1.6,1-2,3-2c2.2,0,2.9,0.6,2.9,2.3c0,0.7-0.2,1-1.1,1.1l-4.1,0.5c-4.1,0.5-5.6,1.8-5.6,4.6c0,2.6,2,4.2,5.4,4.2\n\t\tc2.5,0,4.1-0.8,5.5-2.9c0.8,2.2,1.8,2.9,3.7,2.9c1,0,1.8-0.2,3.4-1.1v-1.8c-0.8,0.1-1.4,0.1-1.7,0.1C91.5,43.9,91,43.2,91,41.5z\n\t\t M83,43.9c-1.4,0-2.3-0.7-2.3-1.8c0-1.6,0.7-1.9,5.3-2.8l1.2-0.2C87.2,42.3,85.9,43.9,83,43.9z");
    			add_location(path4, file$m, 19, 1, 1341);
    			attr_dev(path5, "fill", "#FFFFFF");
    			attr_dev(path5, "d", "M20.1,58.8c2.8-0.6,4.2-2.2,4.2-4.4c0-2.6-2.4-4.7-5.5-4.7H6.1v19.5h12.5c3.7,0,6.4-2.2,6.4-5.3\n\t\tC25,61.2,23.4,59.7,20.1,58.8z M10.6,52.8h5.9c2.3,0,3.1,0.6,3.1,2.3c0,1.8-0.8,2.4-3.1,2.4h-5.9V52.8z M16.5,65.7h-6v-5.3h6\n\t\tc2.4,0,3.5,0.8,3.5,2.6C20,65.1,19.1,65.7,16.5,65.7z");
    			add_location(path5, file$m, 25, 2, 1808);
    			attr_dev(rect, "x", "26.9");
    			attr_dev(rect, "y", "49.8");
    			attr_dev(rect, "fill", "#FFFFFF");
    			attr_dev(rect, "width", "4.1");
    			attr_dev(rect, "height", "19.5");
    			add_location(rect, file$m, 29, 1, 2117);
    			attr_dev(path6, "fill", "#FFFFFF");
    			attr_dev(path6, "d", "M47.4,64.9l-0.1-6.9c-0.1-2.3-2.5-3.6-6.6-3.6c-5.1,0-6.9,1.2-7.1,4.8h3.8c0.2-1.4,0.8-1.9,2.9-1.9\n\t\tc2.4,0,3.1,0.5,3.1,2.2c0,0.7-0.4,1-1.2,1.1c-0.2,0-1.9,0.1-4.1,0.5c-3.8,0.5-5.4,1.8-5.4,4.6c0,2.6,1.9,4.2,5.3,4.2\n\t\tc2.6,0,4.1-0.7,5.6-2.9c0.7,2,1.8,2.9,3.9,2.9c1,0,1.7-0.2,2.9-0.8v-2c-0.5,0.1-0.8,0.1-1.2,0.1C47.9,67.1,47.4,66.5,47.4,64.9z\n\t\t M39.4,67c-1.7,0-2.5-0.6-2.5-1.7c0-1.3,1-2,3.1-2.4c1.9-0.2,1.8-0.2,3.2-0.6C43.3,65.4,42,67,39.4,67z");
    			add_location(path6, file$m, 31, 1, 2196);
    			attr_dev(path7, "fill", "#FFFFFF");
    			attr_dev(path7, "d", "M61.7,57.3c-1.3-1.9-2.8-2.8-4.9-2.8c-3.8,0-6.7,3.2-6.7,7.6c0,4.8,2.5,7.8,6.6,7.8c2.3,0,3.4-0.6,5.2-2.8\n\t\tv2.3h3.9V49.8h-4V57.3z M57.6,67.1c-2.4,0-3.5-1.7-3.5-4.9c0-3,1.2-4.7,3.5-4.7c2.2,0,3.6,1.9,3.6,4.7\n\t\tC61.2,65.2,59.8,67.1,57.6,67.1z");
    			add_location(path7, file$m, 35, 1, 2673);
    			attr_dev(path8, "fill", "#FFFFFF");
    			attr_dev(path8, "d", "M75.5,54.6c-4.5,0-7.8,3.4-7.8,7.7c0,4.6,3.2,7.8,7.8,7.8c4.4,0,7.2-1.8,7.7-5.1h-3.8\n\t\tc-0.5,1.6-1.3,2-3.4,2c-2.8,0-4.1-1.3-4.1-4h11.3C83.2,58,80.2,54.6,75.5,54.6z M72,60.9c0.2-2.3,1.3-3.5,3.4-3.5\n\t\tc2.2,0,3.2,1.1,3.4,3.5H72z");
    			add_location(path8, file$m, 39, 1, 2950);
    			attr_dev(path9, "fill", "#FFFFFF");
    			attr_dev(path9, "d", "M90.3,65.7v-7.6h4v-2.9h-4v-5.3h-2.9L87.3,51c-0.7,4.2-0.6,4.2-1.7,4.2h-2.3v2.9h3l-0.1,6.9v0.5\n\t\tc0,3.2,1.4,4.7,4.6,4.7c1.6,0,2.4-0.1,3.7-0.8v-2.2c-0.8,0.1-1.7,0.1-2,0.1C90.9,67.2,90.3,66.8,90.3,65.7z");
    			add_location(path9, file$m, 43, 1, 3213);
    			add_location(g, file$m, 2, 0, 217);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$m, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, g);
    			append_dev(g, path0);
    			append_dev(g, polygon0);
    			append_dev(g, polygon1);
    			append_dev(g, path1);
    			append_dev(g, path2);
    			append_dev(g, path3);
    			append_dev(g, path4);
    			append_dev(g, path5);
    			append_dev(g, rect);
    			append_dev(g, path6);
    			append_dev(g, path7);
    			append_dev(g, path8);
    			append_dev(g, path9);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ version: "1.1" },
    				{ id: "logo" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{
    					"xmlns:xlink": "http://www.w3.org/1999/xlink"
    				},
    				{ x: "0px" },
    				{ y: "0px" },
    				{ viewBox: "0 0 100 88" },
    				{ "enable-background": "new 0 0 100 88" },
    				{ "xml:space": "preserve" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Ekstrabladet_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Ekstrabladet_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$n, create_fragment$o, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Ekstrabladet_svg_rollup_plugin",
    			options,
    			id: create_fragment$o.name
    		});
    	}
    }

    var ekstrabladet_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Ekstrabladet_svg_rollup_plugin
    });

    var require$$106 = /*@__PURE__*/getAugmentedNamespace(ekstrabladet_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/graphics/figcaption-pin.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$l = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/graphics/figcaption-pin.svg.rollup-plugin.svelte";

    function create_fragment$n(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 34 16.4" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "d", "M15.6.8c.8-.8 2-.8 2.8 0l6.7 6.7c1.9 1.9 4.4 2.9 7.1 2.9H34v6H0v-6h1.9c2.7 0 5.2-1.1 7.1-2.9L15.6.8z");
    			attr_dev(path0, "fill", "var(--ebds-figcaption-bg)");
    			add_location(path0, file$l, 1, 0, 77);
    			attr_dev(path1, "d", "M9.7 12.9l6.6-6.6c.4-.4 1-.4 1.4 0l6.6 6.6c.6.6.2 1.7-.7 1.7H10.4c-.9 0-1.3-1-.7-1.7z");
    			add_location(path1, file$l, 2, 0, 224);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$l, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 34 16.4" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Figcaption_pin_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Figcaption_pin_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$m, create_fragment$n, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Figcaption_pin_svg_rollup_plugin",
    			options,
    			id: create_fragment$n.name
    		});
    	}
    }

    var figcaptionPin_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Figcaption_pin_svg_rollup_plugin
    });

    var require$$107 = /*@__PURE__*/getAugmentedNamespace(figcaptionPin_svg_rollupPlugin);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/graphics/video-graphic.svg.rollup-plugin.svelte generated by Svelte v3.46.4 */

    const file$k = "node_modules/@ekstra-bladet/designsystem/dist/components/icon/graphics/video-graphic.svg.rollup-plugin.svelte";

    function create_fragment$m(ctx) {
    	let svg;
    	let rect;
    	let path;

    	let svg_levels = [
    		{ class: "video-icon" },
    		{ width: "26" },
    		{ height: "26" },
    		{ viewBox: "0 0 26 26" },
    		{ fill: "none" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{
    			style: "box-shadow: 0px 6px 15px rgba(0, 0, 0, 0.12); border-radius: 4px;"
    		},
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			rect = svg_element("rect");
    			path = svg_element("path");
    			attr_dev(rect, "width", "26");
    			attr_dev(rect, "height", "26");
    			attr_dev(rect, "rx", "4");
    			attr_dev(rect, "fill", "white");
    			add_location(rect, file$k, 2, 4, 214);
    			attr_dev(path, "fill-rule", "evenodd");
    			attr_dev(path, "clip-rule", "evenodd");
    			attr_dev(path, "d", "M8 8.58703C8 7.36401 9.34875 6.60201 10.4227 7.21825L18.2007 11.6812C19.2664 12.2927 19.2664 13.8073 18.2007 14.4188L10.4227 18.8818C9.34874 19.498 8 18.736 8 17.513L8 8.58703Z");
    			attr_dev(path, "fill", "black");
    			add_location(path, file$k, 3, 4, 270);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$k, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, rect);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ class: "video-icon" },
    				{ width: "26" },
    				{ height: "26" },
    				{ viewBox: "0 0 26 26" },
    				{ fill: "none" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{
    					style: "box-shadow: 0px 6px 15px rgba(0, 0, 0, 0.12); border-radius: 4px;"
    				},
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Video_graphic_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Video_graphic_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$l, create_fragment$m, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Video_graphic_svg_rollup_plugin",
    			options,
    			id: create_fragment$m.name
    		});
    	}
    }

    var videoGraphic_svg_rollupPlugin = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Video_graphic_svg_rollup_plugin
    });

    var require$$108 = /*@__PURE__*/getAugmentedNamespace(videoGraphic_svg_rollupPlugin);

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.headphones = exports.gallery = exports.futbol = exports.filtersolid = exports.facebook = exports.externallink = exports.expand = exports.exclamationtriangle = exports.exclamationtrianglesolid = exports.exclamationcircle = exports.exclamationcirclesolid = exports.envelope = exports.edit = exports.ebplus = exports.ebpluscirclesolid = exports.dotcircle = exports.desktop = exports.creditcard = exports.creditcardsolid = exports.commentssolid = exports.comment = exports.commentsolid = exports.cog = exports.cogsolid = exports.clock = exports.circle = exports.circlesolid = exports.circlenotch = exports.check = exports.checksquare = exports.checksquaresolid = exports.checkcircle = exports.checkcirclesolid = exports.chartbar = exports.camera = exports.camerasolid = exports.calendar = exports.bookmark = exports.bookmarksolid = exports.bell = exports.at = exports.article = exports.arrowup = exports.arrowright = exports.arrowleft = exports.arrowdown = exports.angleup = exports.angleright = exports.angleleft = exports.angledown = void 0;
    exports.video = exports.users = exports.usersolid = exports.usercircle = exports.usercirclesolid = exports.twitter = exports.trash = exports.trashsolid = exports.toggleon = exports.toggleoff = exports.times = exports.timescircle = exports.timescirclesolid = exports.tags = exports.tagssolid = exports.tag = exports.tagsolid = exports.tablet = exports.sync = exports.star = exports.starsolid = exports.starhalfsolid = exports.square = exports.smartphone = exports.search = exports.rss = exports.rsssymbol = exports.questioncircle = exports.playcircle = exports.pinsolid = exports.phone = exports.newspaper = exports.miteb = exports.mitebsolid = exports.menubars = exports.menubarssolid = exports.medielogin = exports.mappinsolid = exports.lock = exports.listol = exports.linkedin = exports.lightning = exports.instagram = exports.infocircle = exports.infocirclesolid = exports.history = exports.heart = exports.heartsolid = exports.hearthalfsolid = exports.headset = void 0;
    exports.videographic = exports.figcaptionpin = exports.ekstrabladet = exports.ebpluswhite = exports.ebpluswhiteblackshadow = exports.ebplusred = exports.youtube = exports.volumeupsolid = exports.volumemutedsolid = void 0;
    var angle_down_svg_1 = require$$0$4;
    Object.defineProperty(exports, "angledown", { enumerable: true, get: function () { return angle_down_svg_1.default; } });
    var angle_left_svg_1 = require$$1$1;
    Object.defineProperty(exports, "angleleft", { enumerable: true, get: function () { return angle_left_svg_1.default; } });
    var angle_right_svg_1 = require$$2$1;
    Object.defineProperty(exports, "angleright", { enumerable: true, get: function () { return angle_right_svg_1.default; } });
    var angle_up_svg_1 = require$$3$1;
    Object.defineProperty(exports, "angleup", { enumerable: true, get: function () { return angle_up_svg_1.default; } });
    var arrow_down_svg_1 = require$$4$1;
    Object.defineProperty(exports, "arrowdown", { enumerable: true, get: function () { return arrow_down_svg_1.default; } });
    var arrow_left_svg_1 = require$$5$1;
    Object.defineProperty(exports, "arrowleft", { enumerable: true, get: function () { return arrow_left_svg_1.default; } });
    var arrow_right_svg_1 = require$$6$1;
    Object.defineProperty(exports, "arrowright", { enumerable: true, get: function () { return arrow_right_svg_1.default; } });
    var arrow_up_svg_1 = require$$7$1;
    Object.defineProperty(exports, "arrowup", { enumerable: true, get: function () { return arrow_up_svg_1.default; } });
    var article_svg_1 = require$$8$1;
    Object.defineProperty(exports, "article", { enumerable: true, get: function () { return article_svg_1.default; } });
    var at_svg_1 = require$$9$1;
    Object.defineProperty(exports, "at", { enumerable: true, get: function () { return at_svg_1.default; } });
    var bell_svg_1 = require$$10$1;
    Object.defineProperty(exports, "bell", { enumerable: true, get: function () { return bell_svg_1.default; } });
    var bookmark_solid_svg_1 = require$$11$1;
    Object.defineProperty(exports, "bookmarksolid", { enumerable: true, get: function () { return bookmark_solid_svg_1.default; } });
    var bookmark_svg_1 = require$$12$1;
    Object.defineProperty(exports, "bookmark", { enumerable: true, get: function () { return bookmark_svg_1.default; } });
    var calendar_svg_1 = require$$13$1;
    Object.defineProperty(exports, "calendar", { enumerable: true, get: function () { return calendar_svg_1.default; } });
    var camera_solid_svg_1 = require$$14$1;
    Object.defineProperty(exports, "camerasolid", { enumerable: true, get: function () { return camera_solid_svg_1.default; } });
    var camera_svg_1 = require$$15$1;
    Object.defineProperty(exports, "camera", { enumerable: true, get: function () { return camera_svg_1.default; } });
    var chart_bar_svg_1 = require$$16$1;
    Object.defineProperty(exports, "chartbar", { enumerable: true, get: function () { return chart_bar_svg_1.default; } });
    var check_circle_solid_svg_1 = require$$17$1;
    Object.defineProperty(exports, "checkcirclesolid", { enumerable: true, get: function () { return check_circle_solid_svg_1.default; } });
    var check_circle_svg_1 = require$$18$1;
    Object.defineProperty(exports, "checkcircle", { enumerable: true, get: function () { return check_circle_svg_1.default; } });
    var check_square_solid_svg_1 = require$$19$1;
    Object.defineProperty(exports, "checksquaresolid", { enumerable: true, get: function () { return check_square_solid_svg_1.default; } });
    var check_square_svg_1 = require$$20;
    Object.defineProperty(exports, "checksquare", { enumerable: true, get: function () { return check_square_svg_1.default; } });
    var check_svg_1 = require$$21;
    Object.defineProperty(exports, "check", { enumerable: true, get: function () { return check_svg_1.default; } });
    var circle_notch_svg_1 = require$$22;
    Object.defineProperty(exports, "circlenotch", { enumerable: true, get: function () { return circle_notch_svg_1.default; } });
    var circle_solid_svg_1 = require$$23;
    Object.defineProperty(exports, "circlesolid", { enumerable: true, get: function () { return circle_solid_svg_1.default; } });
    var circle_svg_1 = require$$24;
    Object.defineProperty(exports, "circle", { enumerable: true, get: function () { return circle_svg_1.default; } });
    var clock_svg_1 = require$$25;
    Object.defineProperty(exports, "clock", { enumerable: true, get: function () { return clock_svg_1.default; } });
    var cog_solid_svg_1 = require$$26;
    Object.defineProperty(exports, "cogsolid", { enumerable: true, get: function () { return cog_solid_svg_1.default; } });
    var cog_svg_1 = require$$27;
    Object.defineProperty(exports, "cog", { enumerable: true, get: function () { return cog_svg_1.default; } });
    var comment_solid_svg_1 = require$$28;
    Object.defineProperty(exports, "commentsolid", { enumerable: true, get: function () { return comment_solid_svg_1.default; } });
    var comment_svg_1 = require$$29;
    Object.defineProperty(exports, "comment", { enumerable: true, get: function () { return comment_svg_1.default; } });
    var comments_solid_svg_1 = require$$30;
    Object.defineProperty(exports, "commentssolid", { enumerable: true, get: function () { return comments_solid_svg_1.default; } });
    var creditcard_solid_svg_1 = require$$31;
    Object.defineProperty(exports, "creditcardsolid", { enumerable: true, get: function () { return creditcard_solid_svg_1.default; } });
    var creditcard_svg_1 = require$$32;
    Object.defineProperty(exports, "creditcard", { enumerable: true, get: function () { return creditcard_svg_1.default; } });
    var desktop_svg_1 = require$$33;
    Object.defineProperty(exports, "desktop", { enumerable: true, get: function () { return desktop_svg_1.default; } });
    var dot_circle_svg_1 = require$$34;
    Object.defineProperty(exports, "dotcircle", { enumerable: true, get: function () { return dot_circle_svg_1.default; } });
    var ebplus_circle_solid_svg_1 = require$$35;
    Object.defineProperty(exports, "ebpluscirclesolid", { enumerable: true, get: function () { return ebplus_circle_solid_svg_1.default; } });
    var ebplus_svg_1 = require$$36;
    Object.defineProperty(exports, "ebplus", { enumerable: true, get: function () { return ebplus_svg_1.default; } });
    var edit_svg_1 = require$$37;
    Object.defineProperty(exports, "edit", { enumerable: true, get: function () { return edit_svg_1.default; } });
    var envelope_svg_1 = require$$38;
    Object.defineProperty(exports, "envelope", { enumerable: true, get: function () { return envelope_svg_1.default; } });
    var exclamation_circle_solid_svg_1 = require$$39;
    Object.defineProperty(exports, "exclamationcirclesolid", { enumerable: true, get: function () { return exclamation_circle_solid_svg_1.default; } });
    var exclamation_circle_svg_1 = require$$40;
    Object.defineProperty(exports, "exclamationcircle", { enumerable: true, get: function () { return exclamation_circle_svg_1.default; } });
    var exclamation_triangle_solid_svg_1 = require$$41;
    Object.defineProperty(exports, "exclamationtrianglesolid", { enumerable: true, get: function () { return exclamation_triangle_solid_svg_1.default; } });
    var exclamation_triangle_svg_1 = require$$42;
    Object.defineProperty(exports, "exclamationtriangle", { enumerable: true, get: function () { return exclamation_triangle_svg_1.default; } });
    var expand_svg_1 = require$$43;
    Object.defineProperty(exports, "expand", { enumerable: true, get: function () { return expand_svg_1.default; } });
    var external_link_svg_1 = require$$44;
    Object.defineProperty(exports, "externallink", { enumerable: true, get: function () { return external_link_svg_1.default; } });
    var facebook_svg_1 = require$$45;
    Object.defineProperty(exports, "facebook", { enumerable: true, get: function () { return facebook_svg_1.default; } });
    var filter_solid_svg_1 = require$$46;
    Object.defineProperty(exports, "filtersolid", { enumerable: true, get: function () { return filter_solid_svg_1.default; } });
    var futbol_svg_1 = require$$47;
    Object.defineProperty(exports, "futbol", { enumerable: true, get: function () { return futbol_svg_1.default; } });
    var gallery_svg_1 = require$$48;
    Object.defineProperty(exports, "gallery", { enumerable: true, get: function () { return gallery_svg_1.default; } });
    var headphones_svg_1 = require$$49;
    Object.defineProperty(exports, "headphones", { enumerable: true, get: function () { return headphones_svg_1.default; } });
    var headset_svg_1 = require$$50;
    Object.defineProperty(exports, "headset", { enumerable: true, get: function () { return headset_svg_1.default; } });
    var heart_half_solid_svg_1 = require$$51;
    Object.defineProperty(exports, "hearthalfsolid", { enumerable: true, get: function () { return heart_half_solid_svg_1.default; } });
    var heart_solid_svg_1 = require$$52;
    Object.defineProperty(exports, "heartsolid", { enumerable: true, get: function () { return heart_solid_svg_1.default; } });
    var heart_svg_1 = require$$53;
    Object.defineProperty(exports, "heart", { enumerable: true, get: function () { return heart_svg_1.default; } });
    var history_svg_1 = require$$54;
    Object.defineProperty(exports, "history", { enumerable: true, get: function () { return history_svg_1.default; } });
    var info_circle_solid_svg_1 = require$$55;
    Object.defineProperty(exports, "infocirclesolid", { enumerable: true, get: function () { return info_circle_solid_svg_1.default; } });
    var info_circle_svg_1 = require$$56;
    Object.defineProperty(exports, "infocircle", { enumerable: true, get: function () { return info_circle_svg_1.default; } });
    var instagram_svg_1 = require$$57;
    Object.defineProperty(exports, "instagram", { enumerable: true, get: function () { return instagram_svg_1.default; } });
    var lightning_svg_1 = require$$58;
    Object.defineProperty(exports, "lightning", { enumerable: true, get: function () { return lightning_svg_1.default; } });
    var linkedin_svg_1 = require$$59;
    Object.defineProperty(exports, "linkedin", { enumerable: true, get: function () { return linkedin_svg_1.default; } });
    var list_ol_svg_1 = require$$60;
    Object.defineProperty(exports, "listol", { enumerable: true, get: function () { return list_ol_svg_1.default; } });
    var lock_svg_1 = require$$61;
    Object.defineProperty(exports, "lock", { enumerable: true, get: function () { return lock_svg_1.default; } });
    var mappin_solid_svg_1 = require$$62;
    Object.defineProperty(exports, "mappinsolid", { enumerable: true, get: function () { return mappin_solid_svg_1.default; } });
    var medielogin_svg_1 = require$$63;
    Object.defineProperty(exports, "medielogin", { enumerable: true, get: function () { return medielogin_svg_1.default; } });
    var menubars_solid_svg_1 = require$$64;
    Object.defineProperty(exports, "menubarssolid", { enumerable: true, get: function () { return menubars_solid_svg_1.default; } });
    var menubars_svg_1 = require$$65;
    Object.defineProperty(exports, "menubars", { enumerable: true, get: function () { return menubars_svg_1.default; } });
    var miteb_solid_svg_1 = require$$66;
    Object.defineProperty(exports, "mitebsolid", { enumerable: true, get: function () { return miteb_solid_svg_1.default; } });
    var miteb_svg_1 = require$$67;
    Object.defineProperty(exports, "miteb", { enumerable: true, get: function () { return miteb_svg_1.default; } });
    var newspaper_svg_1 = require$$68;
    Object.defineProperty(exports, "newspaper", { enumerable: true, get: function () { return newspaper_svg_1.default; } });
    var phone_svg_1 = require$$69;
    Object.defineProperty(exports, "phone", { enumerable: true, get: function () { return phone_svg_1.default; } });
    var pin_solid_svg_1 = require$$70;
    Object.defineProperty(exports, "pinsolid", { enumerable: true, get: function () { return pin_solid_svg_1.default; } });
    var play_circle_svg_1 = require$$71;
    Object.defineProperty(exports, "playcircle", { enumerable: true, get: function () { return play_circle_svg_1.default; } });
    var question_circle_svg_1 = require$$72;
    Object.defineProperty(exports, "questioncircle", { enumerable: true, get: function () { return question_circle_svg_1.default; } });
    var rss_symbol_svg_1 = require$$73;
    Object.defineProperty(exports, "rsssymbol", { enumerable: true, get: function () { return rss_symbol_svg_1.default; } });
    var rss_svg_1 = require$$74;
    Object.defineProperty(exports, "rss", { enumerable: true, get: function () { return rss_svg_1.default; } });
    var search_svg_1 = require$$75;
    Object.defineProperty(exports, "search", { enumerable: true, get: function () { return search_svg_1.default; } });
    var smartphone_svg_1 = require$$76;
    Object.defineProperty(exports, "smartphone", { enumerable: true, get: function () { return smartphone_svg_1.default; } });
    var square_svg_1 = require$$77;
    Object.defineProperty(exports, "square", { enumerable: true, get: function () { return square_svg_1.default; } });
    var star_half_solid_svg_1 = require$$78;
    Object.defineProperty(exports, "starhalfsolid", { enumerable: true, get: function () { return star_half_solid_svg_1.default; } });
    var star_solid_svg_1 = require$$79;
    Object.defineProperty(exports, "starsolid", { enumerable: true, get: function () { return star_solid_svg_1.default; } });
    var star_svg_1 = require$$80;
    Object.defineProperty(exports, "star", { enumerable: true, get: function () { return star_svg_1.default; } });
    var sync_svg_1 = require$$81;
    Object.defineProperty(exports, "sync", { enumerable: true, get: function () { return sync_svg_1.default; } });
    var tablet_svg_1 = require$$82;
    Object.defineProperty(exports, "tablet", { enumerable: true, get: function () { return tablet_svg_1.default; } });
    var tag_solid_svg_1 = require$$83;
    Object.defineProperty(exports, "tagsolid", { enumerable: true, get: function () { return tag_solid_svg_1.default; } });
    var tag_svg_1 = require$$84;
    Object.defineProperty(exports, "tag", { enumerable: true, get: function () { return tag_svg_1.default; } });
    var tags_solid_svg_1 = require$$85;
    Object.defineProperty(exports, "tagssolid", { enumerable: true, get: function () { return tags_solid_svg_1.default; } });
    var tags_svg_1 = require$$86;
    Object.defineProperty(exports, "tags", { enumerable: true, get: function () { return tags_svg_1.default; } });
    var times_circle_solid_svg_1 = require$$87;
    Object.defineProperty(exports, "timescirclesolid", { enumerable: true, get: function () { return times_circle_solid_svg_1.default; } });
    var times_circle_svg_1 = require$$88;
    Object.defineProperty(exports, "timescircle", { enumerable: true, get: function () { return times_circle_svg_1.default; } });
    var times_svg_1 = require$$89;
    Object.defineProperty(exports, "times", { enumerable: true, get: function () { return times_svg_1.default; } });
    var toggle_off_svg_1 = require$$90;
    Object.defineProperty(exports, "toggleoff", { enumerable: true, get: function () { return toggle_off_svg_1.default; } });
    var toggle_on_svg_1 = require$$91;
    Object.defineProperty(exports, "toggleon", { enumerable: true, get: function () { return toggle_on_svg_1.default; } });
    var trash_solid_svg_1 = require$$92;
    Object.defineProperty(exports, "trashsolid", { enumerable: true, get: function () { return trash_solid_svg_1.default; } });
    var trash_svg_1 = require$$93;
    Object.defineProperty(exports, "trash", { enumerable: true, get: function () { return trash_svg_1.default; } });
    var twitter_svg_1 = require$$94;
    Object.defineProperty(exports, "twitter", { enumerable: true, get: function () { return twitter_svg_1.default; } });
    var user_circle_solid_svg_1 = require$$95;
    Object.defineProperty(exports, "usercirclesolid", { enumerable: true, get: function () { return user_circle_solid_svg_1.default; } });
    var user_circle_svg_1 = require$$96;
    Object.defineProperty(exports, "usercircle", { enumerable: true, get: function () { return user_circle_svg_1.default; } });
    var user_solid_svg_1 = require$$97;
    Object.defineProperty(exports, "usersolid", { enumerable: true, get: function () { return user_solid_svg_1.default; } });
    var users_svg_1 = require$$98;
    Object.defineProperty(exports, "users", { enumerable: true, get: function () { return users_svg_1.default; } });
    var video_svg_1 = require$$99;
    Object.defineProperty(exports, "video", { enumerable: true, get: function () { return video_svg_1.default; } });
    var volume_muted_solid_svg_1 = require$$100;
    Object.defineProperty(exports, "volumemutedsolid", { enumerable: true, get: function () { return volume_muted_solid_svg_1.default; } });
    var volume_up_solid_svg_1 = require$$101;
    Object.defineProperty(exports, "volumeupsolid", { enumerable: true, get: function () { return volume_up_solid_svg_1.default; } });
    var youtube_svg_1 = require$$102;
    Object.defineProperty(exports, "youtube", { enumerable: true, get: function () { return youtube_svg_1.default; } });
    var ebplus_red_svg_1 = require$$103;
    Object.defineProperty(exports, "ebplusred", { enumerable: true, get: function () { return ebplus_red_svg_1.default; } });
    var ebplus_white_blackshadow_svg_1 = require$$104;
    Object.defineProperty(exports, "ebpluswhiteblackshadow", { enumerable: true, get: function () { return ebplus_white_blackshadow_svg_1.default; } });
    var ebplus_white_svg_1 = require$$105;
    Object.defineProperty(exports, "ebpluswhite", { enumerable: true, get: function () { return ebplus_white_svg_1.default; } });
    var ekstrabladet_svg_1 = require$$106;
    Object.defineProperty(exports, "ekstrabladet", { enumerable: true, get: function () { return ekstrabladet_svg_1.default; } });
    var figcaption_pin_svg_1 = require$$107;
    Object.defineProperty(exports, "figcaptionpin", { enumerable: true, get: function () { return figcaption_pin_svg_1.default; } });
    var video_graphic_svg_1 = require$$108;
    Object.defineProperty(exports, "videographic", { enumerable: true, get: function () { return video_graphic_svg_1.default; } });
    }(IconComponents$1));

    var IconComponents = /*@__PURE__*/getDefaultExportFromCjs(IconComponents$1);

    var IconSVGS = /*#__PURE__*/_mergeNamespaces({
        __proto__: null,
        'default': IconComponents
    }, [IconComponents$1]);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/icon/Icon.svelte generated by Svelte v3.46.4 */

    // (14:0) {#if name}
    function create_if_block$c(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = IconSVGS[/*name*/ ctx[0].replace('-', '')];

    	function switch_props(ctx) {
    		return {
    			props: {
    				style: /*styleAttr*/ ctx[1],
    				class: /*baseClass*/ ctx[2]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*styleAttr*/ 2) switch_instance_changes.style = /*styleAttr*/ ctx[1];

    			if (switch_value !== (switch_value = IconSVGS[/*name*/ ctx[0].replace('-', '')])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(14:0) {#if name}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*name*/ ctx[0] && create_if_block$c(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*name*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*name*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$c(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let cssWidth;
    	let styleAttr;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Icon', slots, []);
    	let { className = undefined } = $$props;
    	let { name = undefined } = $$props;
    	let { width = undefined } = $$props;
    	let { style = undefined } = $$props;
    	let baseClass = className ? `icon-svg ${className}` : 'icon-svg';
    	const writable_props = ['className', 'name', 'width', 'style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Icon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('className' in $$props) $$invalidate(3, className = $$props.className);
    		if ('name' in $$props) $$invalidate(0, name = $$props.name);
    		if ('width' in $$props) $$invalidate(4, width = $$props.width);
    		if ('style' in $$props) $$invalidate(5, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({
    		IconSVGS,
    		className,
    		name,
    		width,
    		style,
    		baseClass,
    		cssWidth,
    		styleAttr
    	});

    	$$self.$inject_state = $$props => {
    		if ('className' in $$props) $$invalidate(3, className = $$props.className);
    		if ('name' in $$props) $$invalidate(0, name = $$props.name);
    		if ('width' in $$props) $$invalidate(4, width = $$props.width);
    		if ('style' in $$props) $$invalidate(5, style = $$props.style);
    		if ('baseClass' in $$props) $$invalidate(2, baseClass = $$props.baseClass);
    		if ('cssWidth' in $$props) $$invalidate(6, cssWidth = $$props.cssWidth);
    		if ('styleAttr' in $$props) $$invalidate(1, styleAttr = $$props.styleAttr);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*width*/ 16) {
    			$$invalidate(6, cssWidth = width ? `--icon-size: ${width}px;` : '');
    		}

    		if ($$self.$$.dirty & /*style, cssWidth*/ 96) {
    			$$invalidate(1, styleAttr = style ? `${cssWidth} ${style}` : cssWidth);
    		}
    	};

    	return [name, styleAttr, baseClass, className, width, style, cssWidth];
    }

    class Icon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$k, create_fragment$l, safe_not_equal, {
    			className: 3,
    			name: 0,
    			width: 4,
    			style: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Icon",
    			options,
    			id: create_fragment$l.name
    		});
    	}

    	get className() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Icon$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Icon
    });

    /* node_modules/@ekstra-bladet/designsystem/dist/components/accordion/Accordion.svelte generated by Svelte v3.46.4 */
    const file$j = "node_modules/@ekstra-bladet/designsystem/dist/components/accordion/Accordion.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	child_ctx[7] = i;
    	return child_ctx;
    }

    // (9:2) {#each tabs as tab, i}
    function create_each_block(ctx) {
    	let div2;
    	let div0;
    	let span;
    	let t0_value = /*tab*/ ctx[5].title + "";
    	let t0;
    	let t1;
    	let icon;
    	let t2;
    	let div1;
    	let raw_value = /*tab*/ ctx[5].content + "";
    	let t3;
    	let current;
    	let mounted;
    	let dispose;

    	icon = new Icon({
    			props: { name: "angledown", width: "14" },
    			$$inline: true
    		});

    	function click_handler() {
    		return /*click_handler*/ ctx[4](/*i*/ ctx[7]);
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			create_component(icon.$$.fragment);
    			t2 = space();
    			div1 = element("div");
    			t3 = space();
    			attr_dev(span, "class", "fontweight-bold fontsize-medium");
    			add_location(span, file$j, 16, 8, 637);
    			attr_dev(div0, "class", "accordion-header flex flex-justify--between flex-align--center padding-m");
    			add_location(div0, file$j, 10, 6, 417);
    			attr_dev(div1, "class", "accordion-body padding-m padding-l--rl");
    			add_location(div1, file$j, 19, 6, 766);
    			attr_dev(div2, "class", "accordion-tab margin-m--b");
    			toggle_class(div2, "accordion-expanded", /*$activeTab*/ ctx[3] === /*i*/ ctx[7]);
    			add_location(div2, file$j, 9, 4, 327);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, span);
    			append_dev(span, t0);
    			append_dev(div0, t1);
    			mount_component(icon, div0, null);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			div1.innerHTML = raw_value;
    			append_dev(div2, t3);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div0, "click", stop_propagation(click_handler), false, false, true);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if ((!current || dirty & /*tabs*/ 4) && t0_value !== (t0_value = /*tab*/ ctx[5].title + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*tabs*/ 4) && raw_value !== (raw_value = /*tab*/ ctx[5].content + "")) div1.innerHTML = raw_value;
    			if (dirty & /*$activeTab*/ 8) {
    				toggle_class(div2, "accordion-expanded", /*$activeTab*/ ctx[3] === /*i*/ ctx[7]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(icon);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(9:2) {#each tabs as tab, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$k(ctx) {
    	let div;
    	let current;
    	let each_value = /*tabs*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "data-theme", /*dataTheme*/ ctx[1]);
    			attr_dev(div, "class", "accordion card-mode padding-l ff-secondary width-1of1");
    			add_location(div, file$j, 7, 0, 207);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$activeTab, tabs, undefined*/ 12) {
    				each_value = /*tabs*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (!current || dirty & /*dataTheme*/ 2) {
    				attr_dev(div, "data-theme", /*dataTheme*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let $activeTab,
    		$$unsubscribe_activeTab = noop,
    		$$subscribe_activeTab = () => ($$unsubscribe_activeTab(), $$unsubscribe_activeTab = subscribe(activeTab, $$value => $$invalidate(3, $activeTab = $$value)), activeTab);

    	$$self.$$.on_destroy.push(() => $$unsubscribe_activeTab());
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Accordion', slots, []);
    	const activeTab = writable(undefined);
    	validate_store(activeTab, 'activeTab');
    	$$subscribe_activeTab();
    	let { dataTheme = undefined } = $$props;
    	let { tabs } = $$props;
    	const writable_props = ['dataTheme', 'tabs'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Accordion> was created with unknown prop '${key}'`);
    	});

    	const click_handler = i => {
    		set_store_value(activeTab, $activeTab = $activeTab !== i ? i : undefined, $activeTab);
    	};

    	$$self.$$set = $$props => {
    		if ('dataTheme' in $$props) $$invalidate(1, dataTheme = $$props.dataTheme);
    		if ('tabs' in $$props) $$invalidate(2, tabs = $$props.tabs);
    	};

    	$$self.$capture_state = () => ({
    		writable,
    		Icon,
    		activeTab,
    		dataTheme,
    		tabs,
    		$activeTab
    	});

    	$$self.$inject_state = $$props => {
    		if ('dataTheme' in $$props) $$invalidate(1, dataTheme = $$props.dataTheme);
    		if ('tabs' in $$props) $$invalidate(2, tabs = $$props.tabs);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [activeTab, dataTheme, tabs, $activeTab, click_handler];
    }

    class Accordion extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$j, create_fragment$k, safe_not_equal, { activeTab: 0, dataTheme: 1, tabs: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Accordion",
    			options,
    			id: create_fragment$k.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*tabs*/ ctx[2] === undefined && !('tabs' in props)) {
    			console.warn("<Accordion> was created without expected prop 'tabs'");
    		}
    	}

    	get activeTab() {
    		return this.$$.ctx[0];
    	}

    	set activeTab(value) {
    		throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dataTheme() {
    		throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dataTheme(value) {
    		throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabs() {
    		throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabs(value) {
    		throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Accordion$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Accordion
    });

    var require$$0$3 = /*@__PURE__*/getAugmentedNamespace(Accordion$1);

    var parsedate = {};

    Object.defineProperty(parsedate, "__esModule", { value: true });
    parsedate.populateDates = parseDate_1 = parsedate.parseDate = void 0;
    function parseDate(datetime) {
        const monthNames = ['jan', 'feb', 'mar', 'apr', 'maj', 'jun', 'jul', 'aug', 'sep', 'okt', 'nov', 'dec'];
        const inputdate = new Date(datetime); // UTC-time from server (Z)
        const now = new Date();
        const inputDateLocalTz = new Date(inputdate.getTime() + now.getTimezoneOffset() * 60);
        const secondsSince = Math.round((now.getTime() - inputDateLocalTz.getTime()) / 1000);
        const days = Math.floor(secondsSince / 86400);
        let output = '';
        if (days) {
            // More than 24 hours old
            const yesterday = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1);
            if (inputDateLocalTz.getTime() > yesterday.getTime()) {
                output = 'I går';
            }
            else {
                output = `${inputDateLocalTz.getDate()}. ${monthNames[inputDateLocalTz.getMonth()]}.${now.getFullYear() !== inputDateLocalTz.getFullYear() ? ` ${inputDateLocalTz.getFullYear()}` : ''}`;
            }
        }
        else {
            // Less than 24 hours old
            const hours = Math.floor((secondsSince % 86400) / 3600);
            const minutes = Math.floor(((secondsSince % 86400) % 3600) / 60);
            const seconds = secondsSince % 60;
            if (hours) {
                output = hours === 1 ? `${hours} time` : `${hours} timer`;
            }
            else if (minutes) {
                output = `${minutes} min`;
            }
            else if (seconds) {
                output = `${seconds} sek`;
            }
        }
        return output;
    }
    var parseDate_1 = parsedate.parseDate = parseDate;
    function populateDates() {
        const dateElems = document.querySelectorAll('span[data-timestamp]');
        dateElems.forEach((dateElem) => {
            const formattedDate = parseDate(dateElem.dataset.timestamp);
            if (formattedDate) {
                dateElem.innerText = parseDate(dateElem.dataset.timestamp);
            }
        });
    }
    parsedate.populateDates = populateDates;

    /* node_modules/@ekstra-bladet/designsystem/dist/components/badge/Badge.svelte generated by Svelte v3.46.4 */

    const file$i = "node_modules/@ekstra-bladet/designsystem/dist/components/badge/Badge.svelte";

    // (22:0) {:else}
    function create_else_block$6(ctx) {
    	let span;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (default_slot) default_slot.c();
    			attr_dev(span, "class", /*cssClass*/ ctx[3]);
    			attr_dev(span, "style", /*style*/ ctx[1]);
    			attr_dev(span, "data-type", /*type*/ ctx[2]);
    			add_location(span, file$i, 22, 2, 593);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (default_slot) {
    				default_slot.m(span, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(span, "click", /*click_handler_1*/ ctx[10], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*cssClass*/ 8) {
    				attr_dev(span, "class", /*cssClass*/ ctx[3]);
    			}

    			if (!current || dirty & /*style*/ 2) {
    				attr_dev(span, "style", /*style*/ ctx[1]);
    			}

    			if (!current || dirty & /*type*/ 4) {
    				attr_dev(span, "data-type", /*type*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(22:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (18:0) {#if href}
    function create_if_block$b(ctx) {
    	let a;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (default_slot) default_slot.c();
    			attr_dev(a, "href", /*href*/ ctx[0]);
    			attr_dev(a, "class", /*cssClass*/ ctx[3]);
    			attr_dev(a, "style", /*style*/ ctx[1]);
    			attr_dev(a, "data-type", /*type*/ ctx[2]);
    			add_location(a, file$i, 18, 2, 501);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*click_handler*/ ctx[9], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*href*/ 1) {
    				attr_dev(a, "href", /*href*/ ctx[0]);
    			}

    			if (!current || dirty & /*cssClass*/ 8) {
    				attr_dev(a, "class", /*cssClass*/ ctx[3]);
    			}

    			if (!current || dirty & /*style*/ 2) {
    				attr_dev(a, "style", /*style*/ ctx[1]);
    			}

    			if (!current || dirty & /*type*/ 4) {
    				attr_dev(a, "data-type", /*type*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(18:0) {#if href}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$j(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$b, create_else_block$6];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*href*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let cssClass;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Badge', slots, ['default']);
    	let { className = '' } = $$props;
    	let { extension = undefined } = $$props;
    	let { href = undefined } = $$props;
    	let { style = undefined } = $$props;
    	let { type = undefined } = $$props;
    	let baseClass = 'badge';

    	if (extension) {
    		if (typeof extension === 'string') {
    			baseClass = `${baseClass} badge--${extension}`;
    		} else if (Array.isArray(extension)) {
    			baseClass = `${baseClass} badge--${extension.join(' badge--')}`;
    		}
    	}

    	const writable_props = ['className', 'extension', 'href', 'style', 'type'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Badge> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function click_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('className' in $$props) $$invalidate(4, className = $$props.className);
    		if ('extension' in $$props) $$invalidate(5, extension = $$props.extension);
    		if ('href' in $$props) $$invalidate(0, href = $$props.href);
    		if ('style' in $$props) $$invalidate(1, style = $$props.style);
    		if ('type' in $$props) $$invalidate(2, type = $$props.type);
    		if ('$$scope' in $$props) $$invalidate(7, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		className,
    		extension,
    		href,
    		style,
    		type,
    		baseClass,
    		cssClass
    	});

    	$$self.$inject_state = $$props => {
    		if ('className' in $$props) $$invalidate(4, className = $$props.className);
    		if ('extension' in $$props) $$invalidate(5, extension = $$props.extension);
    		if ('href' in $$props) $$invalidate(0, href = $$props.href);
    		if ('style' in $$props) $$invalidate(1, style = $$props.style);
    		if ('type' in $$props) $$invalidate(2, type = $$props.type);
    		if ('baseClass' in $$props) $$invalidate(6, baseClass = $$props.baseClass);
    		if ('cssClass' in $$props) $$invalidate(3, cssClass = $$props.cssClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*baseClass, className*/ 80) {
    			$$invalidate(3, cssClass = `${baseClass} ${className}`);
    		}
    	};

    	return [
    		href,
    		style,
    		type,
    		cssClass,
    		className,
    		extension,
    		baseClass,
    		$$scope,
    		slots,
    		click_handler,
    		click_handler_1
    	];
    }

    class Badge extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$i, create_fragment$j, safe_not_equal, {
    			className: 4,
    			extension: 5,
    			href: 0,
    			style: 1,
    			type: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Badge",
    			options,
    			id: create_fragment$j.name
    		});
    	}

    	get className() {
    		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get extension() {
    		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set extension(value) {
    		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Badge$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Badge
    });

    /* node_modules/@ekstra-bladet/designsystem/dist/components/card/Card.svelte generated by Svelte v3.46.4 */

    const file$h = "node_modules/@ekstra-bladet/designsystem/dist/components/card/Card.svelte";
    const get_footer_slot_changes_1 = dirty => ({});
    const get_footer_slot_context_1 = ctx => ({});
    const get_content_slot_changes_1 = dirty => ({});
    const get_content_slot_context_1 = ctx => ({});
    const get_media_slot_changes_1 = dirty => ({});
    const get_media_slot_context_1 = ctx => ({});
    const get_header_slot_changes_1 = dirty => ({});
    const get_header_slot_context_1 = ctx => ({});
    const get_footer_slot_changes = dirty => ({});
    const get_footer_slot_context = ctx => ({});
    const get_content_slot_changes = dirty => ({});
    const get_content_slot_context = ctx => ({});
    const get_media_slot_changes = dirty => ({});
    const get_media_slot_context = ctx => ({ class: "card-media" });
    const get_header_slot_changes = dirty => ({});
    const get_header_slot_context = ctx => ({ class: "card-header" });

    // (34:0) {:else}
    function create_else_block$5(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*$$slots*/ ctx[4].header && create_if_block_8$1(ctx);
    	let if_block1 = /*$$slots*/ ctx[4].media && create_if_block_7$1(ctx);
    	const default_slot_template = /*#slots*/ ctx[7].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
    	let if_block2 = /*$$slots*/ ctx[4].content && create_if_block_6$1(ctx);
    	let if_block3 = /*$$slots*/ ctx[4].footer && create_if_block_5$1(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (default_slot) default_slot.c();
    			t2 = space();
    			if (if_block2) if_block2.c();
    			t3 = space();
    			if (if_block3) if_block3.c();
    			attr_dev(div, "class", /*cssClass*/ ctx[3]);
    			attr_dev(div, "style", /*style*/ ctx[1]);
    			add_location(div, file$h, 34, 2, 824);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t1);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			append_dev(div, t2);
    			if (if_block2) if_block2.m(div, null);
    			append_dev(div, t3);
    			if (if_block3) if_block3.m(div, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*click_handler_1*/ ctx[9], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*$$slots*/ ctx[4].header) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*$$slots*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_8$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*$$slots*/ ctx[4].media) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*$$slots*/ 16) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_7$1(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
    						null
    					);
    				}
    			}

    			if (/*$$slots*/ ctx[4].content) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*$$slots*/ 16) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_6$1(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, t3);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*$$slots*/ ctx[4].footer) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty & /*$$slots*/ 16) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_5$1(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div, null);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*cssClass*/ 8) {
    				attr_dev(div, "class", /*cssClass*/ ctx[3]);
    			}

    			if (!current || dirty & /*style*/ 2) {
    				attr_dev(div, "style", /*style*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(default_slot, local);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(default_slot, local);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (default_slot) default_slot.d(detaching);
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(34:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (14:0) {#if url}
    function create_if_block$a(ctx) {
    	let a;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*$$slots*/ ctx[4].header && create_if_block_4$1(ctx);
    	let if_block1 = /*$$slots*/ ctx[4].media && create_if_block_3$1(ctx);
    	const default_slot_template = /*#slots*/ ctx[7].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
    	let if_block2 = /*$$slots*/ ctx[4].content && create_if_block_2$1(ctx);
    	let if_block3 = /*$$slots*/ ctx[4].footer && create_if_block_1$3(ctx);

    	let a_levels = [
    		{ href: /*url*/ ctx[0] },
    		{ class: /*cssClass*/ ctx[3] },
    		{ style: /*style*/ ctx[1] },
    		/*dataProps*/ ctx[2]
    	];

    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (default_slot) default_slot.c();
    			t2 = space();
    			if (if_block2) if_block2.c();
    			t3 = space();
    			if (if_block3) if_block3.c();
    			set_attributes(a, a_data);
    			add_location(a, file$h, 14, 2, 340);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			if (if_block0) if_block0.m(a, null);
    			append_dev(a, t0);
    			if (if_block1) if_block1.m(a, null);
    			append_dev(a, t1);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			append_dev(a, t2);
    			if (if_block2) if_block2.m(a, null);
    			append_dev(a, t3);
    			if (if_block3) if_block3.m(a, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*click_handler*/ ctx[8], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*$$slots*/ ctx[4].header) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*$$slots*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_4$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(a, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*$$slots*/ ctx[4].media) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*$$slots*/ 16) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_3$1(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(a, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
    						null
    					);
    				}
    			}

    			if (/*$$slots*/ ctx[4].content) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*$$slots*/ 16) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_2$1(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(a, t3);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*$$slots*/ ctx[4].footer) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty & /*$$slots*/ 16) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_1$3(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(a, null);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				(!current || dirty & /*url*/ 1) && { href: /*url*/ ctx[0] },
    				(!current || dirty & /*cssClass*/ 8) && { class: /*cssClass*/ ctx[3] },
    				(!current || dirty & /*style*/ 2) && { style: /*style*/ ctx[1] },
    				dirty & /*dataProps*/ 4 && /*dataProps*/ ctx[2]
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(default_slot, local);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(default_slot, local);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (default_slot) default_slot.d(detaching);
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(14:0) {#if url}",
    		ctx
    	});

    	return block;
    }

    // (36:4) {#if $$slots.header}
    function create_if_block_8$1(ctx) {
    	let div;
    	let current;
    	const header_slot_template = /*#slots*/ ctx[7].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[6], get_header_slot_context_1);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (header_slot) header_slot.c();
    			attr_dev(div, "class", "card-header");
    			add_location(div, file$h, 36, 6, 895);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (header_slot) {
    				header_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (header_slot) {
    				if (header_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						header_slot,
    						header_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[6], dirty, get_header_slot_changes_1),
    						get_header_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (header_slot) header_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$1.name,
    		type: "if",
    		source: "(36:4) {#if $$slots.header}",
    		ctx
    	});

    	return block;
    }

    // (41:4) {#if $$slots.media}
    function create_if_block_7$1(ctx) {
    	let div;
    	let current;
    	const media_slot_template = /*#slots*/ ctx[7].media;
    	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[6], get_media_slot_context_1);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (media_slot) media_slot.c();
    			attr_dev(div, "class", "card-media");
    			add_location(div, file$h, 41, 6, 1005);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (media_slot) {
    				media_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (media_slot) {
    				if (media_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						media_slot,
    						media_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(media_slot_template, /*$$scope*/ ctx[6], dirty, get_media_slot_changes_1),
    						get_media_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(media_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(media_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (media_slot) media_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$1.name,
    		type: "if",
    		source: "(41:4) {#if $$slots.media}",
    		ctx
    	});

    	return block;
    }

    // (47:4) {#if $$slots.content}
    function create_if_block_6$1(ctx) {
    	let div;
    	let current;
    	const content_slot_template = /*#slots*/ ctx[7].content;
    	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[6], get_content_slot_context_1);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (content_slot) content_slot.c();
    			attr_dev(div, "class", "card-content");
    			add_location(div, file$h, 47, 6, 1128);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (content_slot) {
    				content_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (content_slot) {
    				if (content_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						content_slot,
    						content_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[6], dirty, get_content_slot_changes_1),
    						get_content_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(content_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(content_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (content_slot) content_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$1.name,
    		type: "if",
    		source: "(47:4) {#if $$slots.content}",
    		ctx
    	});

    	return block;
    }

    // (52:4) {#if $$slots.footer}
    function create_if_block_5$1(ctx) {
    	let div;
    	let current;
    	const footer_slot_template = /*#slots*/ ctx[7].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[6], get_footer_slot_context_1);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (footer_slot) footer_slot.c();
    			attr_dev(div, "class", "card-footer");
    			add_location(div, file$h, 52, 6, 1241);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (footer_slot) {
    				footer_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (footer_slot) {
    				if (footer_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						footer_slot,
    						footer_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[6], dirty, get_footer_slot_changes_1),
    						get_footer_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footer_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footer_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (footer_slot) footer_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$1.name,
    		type: "if",
    		source: "(52:4) {#if $$slots.footer}",
    		ctx
    	});

    	return block;
    }

    // (16:4) {#if $$slots.header}
    function create_if_block_4$1(ctx) {
    	let current;
    	const header_slot_template = /*#slots*/ ctx[7].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[6], get_header_slot_context);

    	const block = {
    		c: function create() {
    			if (header_slot) header_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (header_slot) {
    				header_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (header_slot) {
    				if (header_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						header_slot,
    						header_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[6], dirty, get_header_slot_changes),
    						get_header_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (header_slot) header_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(16:4) {#if $$slots.header}",
    		ctx
    	});

    	return block;
    }

    // (19:4) {#if $$slots.media}
    function create_if_block_3$1(ctx) {
    	let current;
    	const media_slot_template = /*#slots*/ ctx[7].media;
    	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[6], get_media_slot_context);

    	const block = {
    		c: function create() {
    			if (media_slot) media_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (media_slot) {
    				media_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (media_slot) {
    				if (media_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						media_slot,
    						media_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(media_slot_template, /*$$scope*/ ctx[6], dirty, get_media_slot_changes),
    						get_media_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(media_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(media_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (media_slot) media_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(19:4) {#if $$slots.media}",
    		ctx
    	});

    	return block;
    }

    // (23:4) {#if $$slots.content}
    function create_if_block_2$1(ctx) {
    	let div;
    	let current;
    	const content_slot_template = /*#slots*/ ctx[7].content;
    	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[6], get_content_slot_context);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (content_slot) content_slot.c();
    			attr_dev(div, "class", "card-content");
    			add_location(div, file$h, 23, 6, 614);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (content_slot) {
    				content_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (content_slot) {
    				if (content_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						content_slot,
    						content_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[6], dirty, get_content_slot_changes),
    						get_content_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(content_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(content_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (content_slot) content_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(23:4) {#if $$slots.content}",
    		ctx
    	});

    	return block;
    }

    // (28:4) {#if $$slots.footer}
    function create_if_block_1$3(ctx) {
    	let div;
    	let current;
    	const footer_slot_template = /*#slots*/ ctx[7].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[6], get_footer_slot_context);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (footer_slot) footer_slot.c();
    			attr_dev(div, "class", "card-footer");
    			add_location(div, file$h, 28, 6, 727);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (footer_slot) {
    				footer_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (footer_slot) {
    				if (footer_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						footer_slot,
    						footer_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[6], dirty, get_footer_slot_changes),
    						get_footer_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footer_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footer_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (footer_slot) footer_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(28:4) {#if $$slots.footer}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$i(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$a, create_else_block$5];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*url*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let cssClass;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Card', slots, ['header','media','default','content','footer']);
    	const $$slots = compute_slots(slots);
    	let { className = undefined } = $$props;
    	let { url = undefined } = $$props;
    	let { style = undefined } = $$props;
    	let baseClass = 'card';
    	const dataProps = {};

    	for (const prop in $$props) {
    		if (prop.indexOf('data-') === 0) {
    			dataProps[prop] = $$props[prop];
    		}
    	}

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function click_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(11, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('className' in $$new_props) $$invalidate(5, className = $$new_props.className);
    		if ('url' in $$new_props) $$invalidate(0, url = $$new_props.url);
    		if ('style' in $$new_props) $$invalidate(1, style = $$new_props.style);
    		if ('$$scope' in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		className,
    		url,
    		style,
    		baseClass,
    		dataProps,
    		cssClass
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(11, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(5, className = $$new_props.className);
    		if ('url' in $$props) $$invalidate(0, url = $$new_props.url);
    		if ('style' in $$props) $$invalidate(1, style = $$new_props.style);
    		if ('baseClass' in $$props) $$invalidate(10, baseClass = $$new_props.baseClass);
    		if ('cssClass' in $$props) $$invalidate(3, cssClass = $$new_props.cssClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className*/ 32) {
    			$$invalidate(3, cssClass = `${className} ${baseClass}`);
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		url,
    		style,
    		dataProps,
    		cssClass,
    		$$slots,
    		className,
    		$$scope,
    		slots,
    		click_handler,
    		click_handler_1
    	];
    }

    class Card extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$i, safe_not_equal, { className: 5, url: 0, style: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Card",
    			options,
    			id: create_fragment$i.name
    		});
    	}

    	get className() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get url() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set url(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Card$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Card
    });

    /* node_modules/@ekstra-bladet/designsystem/dist/components/toggler/Toggler.svelte generated by Svelte v3.46.4 */
    const file$g = "node_modules/@ekstra-bladet/designsystem/dist/components/toggler/Toggler.svelte";
    const get_off_slot_changes_1 = dirty => ({});
    const get_off_slot_context_1 = ctx => ({});
    const get_on_slot_changes_1 = dirty => ({});
    const get_on_slot_context_1 = ctx => ({});
    const get_off_slot_changes = dirty => ({});
    const get_off_slot_context = ctx => ({});
    const get_on_slot_changes = dirty => ({});
    const get_on_slot_context = ctx => ({});

    // (46:0) {:else}
    function create_else_block$4(ctx) {
    	let button;
    	let current_block_type_index;
    	let if_block;
    	let t;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_1$2, create_else_block_1];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*defaultState*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

    	const block = {
    		c: function create() {
    			button = element("button");
    			if_block.c();
    			t = space();
    			if (default_slot) default_slot.c();
    			attr_dev(button, "class", /*baseClass*/ ctx[3]);
    			button.disabled = /*disabled*/ ctx[2];
    			toggle_class(button, "toggle-disabled", /*disabled*/ ctx[2]);
    			add_location(button, file$g, 46, 2, 1395);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			if_blocks[current_block_type_index].m(button, null);
    			append_dev(button, t);

    			if (default_slot) {
    				default_slot.m(button, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", stop_propagation(/*toggle*/ ctx[5]), false, false, true);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(button, t);
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*baseClass*/ 8) {
    				attr_dev(button, "class", /*baseClass*/ ctx[3]);
    			}

    			if (!current || dirty & /*disabled*/ 4) {
    				prop_dev(button, "disabled", /*disabled*/ ctx[2]);
    			}

    			if (dirty & /*baseClass, disabled*/ 12) {
    				toggle_class(button, "toggle-disabled", /*disabled*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if_blocks[current_block_type_index].d();
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(46:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (24:0) {#if isSwitch}
    function create_if_block$9(ctx) {
    	let div;
    	let button0;
    	let button0_class_value;
    	let t0;
    	let icon;
    	let updating_name;
    	let t1;
    	let button1;
    	let button1_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	const on_slot_template = /*#slots*/ ctx[8].on;
    	const on_slot = create_slot(on_slot_template, ctx, /*$$scope*/ ctx[7], get_on_slot_context);

    	function icon_name_binding(value) {
    		/*icon_name_binding*/ ctx[10](value);
    	}

    	let icon_props = {
    		className: "margin-s--rl",
    		width: "30",
    		style: "cursor: pointer;"
    	};

    	if (/*name*/ ctx[4] !== void 0) {
    		icon_props.name = /*name*/ ctx[4];
    	}

    	icon = new Icon({ props: icon_props, $$inline: true });
    	binding_callbacks.push(() => bind(icon, 'name', icon_name_binding));
    	icon.$on("click", /*toggle*/ ctx[5]);
    	const off_slot_template = /*#slots*/ ctx[8].off;
    	const off_slot = create_slot(off_slot_template, ctx, /*$$scope*/ ctx[7], get_off_slot_context);

    	const block = {
    		c: function create() {
    			div = element("div");
    			button0 = element("button");
    			if (on_slot) on_slot.c();
    			t0 = space();
    			create_component(icon.$$.fragment);
    			t1 = space();
    			button1 = element("button");
    			if (off_slot) off_slot.c();
    			attr_dev(button0, "data-status", /*defaultState*/ ctx[0]);
    			attr_dev(button0, "class", button0_class_value = "toggle--switch " + /*baseClass*/ ctx[3]);
    			button0.disabled = /*disabled*/ ctx[2];
    			toggle_class(button0, "toggle-disabled", /*disabled*/ ctx[2]);
    			add_location(button0, file$g, 25, 4, 782);
    			attr_dev(button1, "data-status", /*defaultState*/ ctx[0]);
    			attr_dev(button1, "class", button1_class_value = "toggle--switch " + /*baseClass*/ ctx[3]);
    			button1.disabled = /*disabled*/ ctx[2];
    			toggle_class(button1, "toggle-disabled", /*disabled*/ ctx[2]);
    			add_location(button1, file$g, 35, 4, 1131);
    			attr_dev(div, "class", "flex flex-align--center");
    			add_location(div, file$g, 24, 2, 740);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button0);

    			if (on_slot) {
    				on_slot.m(button0, null);
    			}

    			append_dev(div, t0);
    			mount_component(icon, div, null);
    			append_dev(div, t1);
    			append_dev(div, button1);

    			if (off_slot) {
    				off_slot.m(button1, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", stop_propagation(/*click_handler*/ ctx[9]), false, false, true),
    					listen_dev(button1, "click", stop_propagation(/*click_handler_1*/ ctx[11]), false, false, true)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (on_slot) {
    				if (on_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot_base(
    						on_slot,
    						on_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(on_slot_template, /*$$scope*/ ctx[7], dirty, get_on_slot_changes),
    						get_on_slot_context
    					);
    				}
    			}

    			if (!current || dirty & /*defaultState*/ 1) {
    				attr_dev(button0, "data-status", /*defaultState*/ ctx[0]);
    			}

    			if (!current || dirty & /*baseClass*/ 8 && button0_class_value !== (button0_class_value = "toggle--switch " + /*baseClass*/ ctx[3])) {
    				attr_dev(button0, "class", button0_class_value);
    			}

    			if (!current || dirty & /*disabled*/ 4) {
    				prop_dev(button0, "disabled", /*disabled*/ ctx[2]);
    			}

    			if (dirty & /*baseClass, disabled*/ 12) {
    				toggle_class(button0, "toggle-disabled", /*disabled*/ ctx[2]);
    			}

    			const icon_changes = {};

    			if (!updating_name && dirty & /*name*/ 16) {
    				updating_name = true;
    				icon_changes.name = /*name*/ ctx[4];
    				add_flush_callback(() => updating_name = false);
    			}

    			icon.$set(icon_changes);

    			if (off_slot) {
    				if (off_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot_base(
    						off_slot,
    						off_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(off_slot_template, /*$$scope*/ ctx[7], dirty, get_off_slot_changes),
    						get_off_slot_context
    					);
    				}
    			}

    			if (!current || dirty & /*defaultState*/ 1) {
    				attr_dev(button1, "data-status", /*defaultState*/ ctx[0]);
    			}

    			if (!current || dirty & /*baseClass*/ 8 && button1_class_value !== (button1_class_value = "toggle--switch " + /*baseClass*/ ctx[3])) {
    				attr_dev(button1, "class", button1_class_value);
    			}

    			if (!current || dirty & /*disabled*/ 4) {
    				prop_dev(button1, "disabled", /*disabled*/ ctx[2]);
    			}

    			if (dirty & /*baseClass, disabled*/ 12) {
    				toggle_class(button1, "toggle-disabled", /*disabled*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(on_slot, local);
    			transition_in(icon.$$.fragment, local);
    			transition_in(off_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(on_slot, local);
    			transition_out(icon.$$.fragment, local);
    			transition_out(off_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (on_slot) on_slot.d(detaching);
    			destroy_component(icon);
    			if (off_slot) off_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(24:0) {#if isSwitch}",
    		ctx
    	});

    	return block;
    }

    // (50:4) {:else}
    function create_else_block_1(ctx) {
    	let current;
    	const off_slot_template = /*#slots*/ ctx[8].off;
    	const off_slot = create_slot(off_slot_template, ctx, /*$$scope*/ ctx[7], get_off_slot_context_1);

    	const block = {
    		c: function create() {
    			if (off_slot) off_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (off_slot) {
    				off_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (off_slot) {
    				if (off_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot_base(
    						off_slot,
    						off_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(off_slot_template, /*$$scope*/ ctx[7], dirty, get_off_slot_changes_1),
    						get_off_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(off_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(off_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (off_slot) off_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(50:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (48:4) {#if defaultState}
    function create_if_block_1$2(ctx) {
    	let current;
    	const on_slot_template = /*#slots*/ ctx[8].on;
    	const on_slot = create_slot(on_slot_template, ctx, /*$$scope*/ ctx[7], get_on_slot_context_1);

    	const block = {
    		c: function create() {
    			if (on_slot) on_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (on_slot) {
    				on_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (on_slot) {
    				if (on_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot_base(
    						on_slot,
    						on_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(on_slot_template, /*$$scope*/ ctx[7], dirty, get_on_slot_changes_1),
    						get_on_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(on_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(on_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (on_slot) on_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(48:4) {#if defaultState}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$h(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$9, create_else_block$4];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*isSwitch*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Toggler', slots, ['on','off','default']);
    	let { className = undefined } = $$props;
    	let { defaultState = true } = $$props;
    	let { isSwitch = false } = $$props;
    	let { disabled = false } = $$props;
    	let baseClass = `toggle-button`;
    	if (className) baseClass = `${className} ${baseClass}`;

    	/**
     * Handle user click on toggle element
     */
    	let name = defaultState ? 'toggleon' : 'toggleoff';

    	const dispatch = createEventDispatcher();

    	function toggle(evt, status) {
    		evt.preventDefault();

    		$$invalidate(0, defaultState = status !== null && status !== void 0
    		? status
    		: !defaultState);

    		$$invalidate(4, name = defaultState ? 'toggleon' : 'toggleoff');
    		dispatch('toggle', defaultState);
    	}

    	const writable_props = ['className', 'defaultState', 'isSwitch', 'disabled'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Toggler> was created with unknown prop '${key}'`);
    	});

    	const click_handler = evt => toggle(evt, true);

    	function icon_name_binding(value) {
    		name = value;
    		$$invalidate(4, name);
    	}

    	const click_handler_1 = evt => toggle(evt, false);

    	$$self.$$set = $$props => {
    		if ('className' in $$props) $$invalidate(6, className = $$props.className);
    		if ('defaultState' in $$props) $$invalidate(0, defaultState = $$props.defaultState);
    		if ('isSwitch' in $$props) $$invalidate(1, isSwitch = $$props.isSwitch);
    		if ('disabled' in $$props) $$invalidate(2, disabled = $$props.disabled);
    		if ('$$scope' in $$props) $$invalidate(7, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		Icon,
    		className,
    		defaultState,
    		isSwitch,
    		disabled,
    		baseClass,
    		name,
    		dispatch,
    		toggle
    	});

    	$$self.$inject_state = $$props => {
    		if ('className' in $$props) $$invalidate(6, className = $$props.className);
    		if ('defaultState' in $$props) $$invalidate(0, defaultState = $$props.defaultState);
    		if ('isSwitch' in $$props) $$invalidate(1, isSwitch = $$props.isSwitch);
    		if ('disabled' in $$props) $$invalidate(2, disabled = $$props.disabled);
    		if ('baseClass' in $$props) $$invalidate(3, baseClass = $$props.baseClass);
    		if ('name' in $$props) $$invalidate(4, name = $$props.name);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*defaultState*/ 1) ;
    	};

    	return [
    		defaultState,
    		isSwitch,
    		disabled,
    		baseClass,
    		name,
    		toggle,
    		className,
    		$$scope,
    		slots,
    		click_handler,
    		icon_name_binding,
    		click_handler_1
    	];
    }

    class Toggler extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$g, create_fragment$h, safe_not_equal, {
    			className: 6,
    			defaultState: 0,
    			isSwitch: 1,
    			disabled: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Toggler",
    			options,
    			id: create_fragment$h.name
    		});
    	}

    	get className() {
    		throw new Error("<Toggler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Toggler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get defaultState() {
    		throw new Error("<Toggler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set defaultState(value) {
    		throw new Error("<Toggler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isSwitch() {
    		throw new Error("<Toggler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isSwitch(value) {
    		throw new Error("<Toggler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Toggler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Toggler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Toggler$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Toggler
    });

    var colorNames = Background = void 0;
    var Background = { "bordeaux": { "background": "#8a0c36", "color": "#fff" }, "reddark": { "background": "#900", "color": "#fff" }, "red": { "background": "#bd1118", "color": "#fff" }, "pink": { "background": "#b31e61", "color": "#fff" }, "rose": { "background": "#dc7095", "color": "#fff" }, "orangedark": { "background": "#e96c0d", "color": "#fff" }, "orange": { "background": "#e5ad02", "color": "#fff" }, "yellow": { "background": "#fae500", "color": "#fff" }, "yellowlight": { "background": "#ff0", "color": "#000" }, "sand": { "background": "#cec4a6", "color": "#fff" }, "greendark": { "background": "#2f7820", "color": "#fff" }, "green": { "background": "#029e5d", "color": "#fff" }, "greenlight": { "background": "#93b923", "color": "#fff" }, "lime": { "background": "#cbfe33", "color": "#000" }, "purpledark": { "background": "#51208c", "color": "#fff" }, "bluenavy": { "background": "#1a237e", "color": "#fff" }, "bluedark": { "background": "#1058c2", "color": "#fff" }, "blue": { "background": "#31769b", "color": "#fff" }, "bluelight": { "background": "#4fa8df", "color": "#fff" }, "cyan": { "background": "#00b6d2", "color": "#fff" }, "sea": { "background": "#84a8c4", "color": "#fff" }, "black": { "background": "#000", "color": "#fff" }, "graa0": { "background": "#1b1b1b", "color": "#efefef" }, "graa1": { "background": "#3c3c3c", "color": "#fff" }, "graa2": { "background": "#484848", "color": "#fff" }, "graa3": { "background": "#999", "color": "#fff" }, "graa4": { "background": "#c8c8c8", "color": "#000" }, "graa5": { "background": "#ddd", "color": "#000" }, "graa6": { "background": "#e5e5e5", "color": "#000" }, "graa7": { "background": "#efefef", "color": "#000" }, "white": { "background": "#fff", "color": "#000" }, "pastelred": { "background": "#db5040", "color": "#fff" }, "pasteldarkred": { "background": "#954839", "color": "#fff" }, "pastellightred": { "background": "#d67e9b", "color": "#fff" }, "pastelgreen": { "background": "#9fc29c", "color": "#fff" }, "pasteldarkgreen": { "background": "#91a34f", "color": "#fff" }, "pastelyellow": { "background": "#d4c564", "color": "#fff" }, "eb": { "background": "#bd1118", "color": "#fff" }, "eb2": { "background": "#900", "color": "#fff" }, "breaking": { "background": "#ff0", "color": "#000" }, "bruger": { "background": "#4fa8df", "color": "#fff" }, "live": { "background": "#000", "color": "#fff" }, "native": { "background": "#cec4a6", "color": "#fff" }, "native2": { "background": "#84a8c4", "color": "#fff" }, "facebook": { "background": "#31769b", "color": "#fff" }, "twitter": { "background": "#4fa8df", "color": "#fff" }, "flash": { "background": "#e5ad02", "color": "#fff" }, "forbrug": { "background": "#00b6d2", "color": "#fff" }, "leder": { "background": "#1a237e", "color": "#fff" }, "livescore": { "background": "#029e5d", "color": "#fff" }, "livescore2": { "background": "#cbfe33", "color": "#000" }, "nyheder": { "background": "#1058c2", "color": "#fff" }, "nyheder2": { "background": "#000", "color": "#fff" }, "sexsamliv": { "background": "#b31e61", "color": "#fff" }, "sexsamliv2": { "background": "#dc7095", "color": "#fff" }, "skolefodbold": { "background": "#93b923", "color": "#fff" }, "sport": { "background": "#029e5d", "color": "#fff" }, "tv": { "background": "#bd1118", "color": "#fff" }, "underholdning": { "background": "#51208c", "color": "#fff" } };
    colorNames = { "eb": "eb", "eb2": "eb2", "breaking": "breaking", "bruger": "bruger", "live": "live", "native": "native", "native2": "native2", "facebook": "facebook", "twitter": "twitter", "flash": "flash", "forbrug": "forbrug", "leder": "leder", "livescore": "livescore", "livescore2": "livescore2", "nyheder": "nyheder", "nyheder2": "nyheder2", "sexsamliv": "sex-samliv", "sexsamliv2": "sex-samliv2", "skolefodbold": "skolefodbold", "sport": "sport", "tv": "tv", "underholdning": "underholdning" };

    /* node_modules/@ekstra-bladet/designsystem/dist/components/articlecard/ArticleCard.svelte generated by Svelte v3.46.4 */
    const file$f = "node_modules/@ekstra-bladet/designsystem/dist/components/articlecard/ArticleCard.svelte";
    const get_default_slot_changes_1 = dirty => ({});
    const get_default_slot_context_1 = ctx => ({ slot: "on" });
    const get_default_slot_changes = dirty => ({});
    const get_default_slot_context = ctx => ({ slot: "off" });

    // (63:0) {#if loading || (!loading && title)}
    function create_if_block$8(ctx) {
    	let card;
    	let current;

    	card = new Card({
    			props: {
    				url: /*url*/ ctx[12],
    				className: /*cssClass*/ ctx[16],
    				style: /*styleProp*/ ctx[17],
    				"data-breaking": /*breaking*/ ctx[2],
    				$$slots: { default: [create_default_slot$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	card.$on("click", /*click_handler*/ ctx[29]);

    	const block = {
    		c: function create() {
    			create_component(card.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(card, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const card_changes = {};
    			if (dirty[0] & /*url*/ 4096) card_changes.url = /*url*/ ctx[12];
    			if (dirty[0] & /*cssClass*/ 65536) card_changes.className = /*cssClass*/ ctx[16];
    			if (dirty[0] & /*styleProp*/ 131072) card_changes.style = /*styleProp*/ ctx[17];
    			if (dirty[0] & /*breaking*/ 4) card_changes["data-breaking"] = /*breaking*/ ctx[2];

    			if (dirty[0] & /*$$scope, innerClass, truncateTitle, title, saved, published, section, mediaCssClass, media, colorName, update, loadingStyle, loading, premiumMarkerSize, premium*/ 1073803259) {
    				card_changes.$$scope = { dirty, ctx };
    			}

    			card.$set(card_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(card.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(card.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(card, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(63:0) {#if loading || (!loading && title)}",
    		ctx
    	});

    	return block;
    }

    // (66:6) {#if premium}
    function create_if_block_8(ctx) {
    	let div;
    	let icon;
    	let div_class_value;
    	let current;

    	icon = new Icon({
    			props: {
    				className: "color--white",
    				name: "ebpluswhite"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(icon.$$.fragment);

    			attr_dev(div, "class", div_class_value = "premium-dogear " + (/*premiumMarkerSize*/ ctx[4]
    			? `premium-dogear--${/*premiumMarkerSize*/ ctx[4]}`
    			: ''));

    			add_location(div, file$f, 66, 8, 2448);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(icon, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty[0] & /*premiumMarkerSize*/ 16 && div_class_value !== (div_class_value = "premium-dogear " + (/*premiumMarkerSize*/ ctx[4]
    			? `premium-dogear--${/*premiumMarkerSize*/ ctx[4]}`
    			: ''))) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8.name,
    		type: "if",
    		source: "(66:6) {#if premium}",
    		ctx
    	});

    	return block;
    }

    // (71:6) {#if loading}
    function create_if_block_7(ctx) {
    	let div1;
    	let div0;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			attr_dev(div0, "class", "card-image bg--graa4");
    			attr_dev(div0, "style", /*loadingStyle*/ ctx[13]);
    			add_location(div0, file$f, 72, 10, 2696);
    			attr_dev(div1, "class", "card-media");
    			add_location(div1, file$f, 71, 8, 2661);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*loadingStyle*/ 8192) {
    				attr_dev(div0, "style", /*loadingStyle*/ ctx[13]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(71:6) {#if loading}",
    		ctx
    	});

    	return block;
    }

    // (76:6) {#if media}
    function create_if_block_5(ctx) {
    	let div;
    	let t;
    	let img;
    	let img_src_value;
    	let img_height_value;
    	let img_width_value;
    	let current;
    	let if_block = /*update*/ ctx[5] && create_if_block_6(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			img = element("img");
    			attr_dev(img, "alt", /*title*/ ctx[0]);
    			attr_dev(img, "class", "card-image");
    			if (!src_url_equal(img.src, img_src_value = /*media*/ ctx[6].src)) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "height", img_height_value = /*media*/ ctx[6].height);
    			attr_dev(img, "width", img_width_value = /*media*/ ctx[6].width);
    			add_location(img, file$f, 91, 10, 3357);
    			attr_dev(div, "class", /*mediaCssClass*/ ctx[15]);
    			add_location(div, file$f, 76, 8, 2807);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t);
    			append_dev(div, img);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*update*/ ctx[5]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*update*/ 32) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_6(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty[0] & /*title*/ 1) {
    				attr_dev(img, "alt", /*title*/ ctx[0]);
    			}

    			if (!current || dirty[0] & /*media*/ 64 && !src_url_equal(img.src, img_src_value = /*media*/ ctx[6].src)) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (!current || dirty[0] & /*media*/ 64 && img_height_value !== (img_height_value = /*media*/ ctx[6].height)) {
    				attr_dev(img, "height", img_height_value);
    			}

    			if (!current || dirty[0] & /*media*/ 64 && img_width_value !== (img_width_value = /*media*/ ctx[6].width)) {
    				attr_dev(img, "width", img_width_value);
    			}

    			if (!current || dirty[0] & /*mediaCssClass*/ 32768) {
    				attr_dev(div, "class", /*mediaCssClass*/ ctx[15]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(76:6) {#if media}",
    		ctx
    	});

    	return block;
    }

    // (78:10) {#if update}
    function create_if_block_6(ctx) {
    	let badge;
    	let current;

    	badge = new Badge({
    			props: {
    				className: "margin-s position-absolute padding-none padding-s--r card--shadow bg--black fontsize-small",
    				style: "bottom: 5px; left: 5px;",
    				$$slots: { default: [create_default_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(badge.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(badge, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const badge_changes = {};

    			if (dirty[0] & /*$$scope, colorName*/ 1073741832) {
    				badge_changes.$$scope = { dirty, ctx };
    			}

    			badge.$set(badge_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(badge, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(78:10) {#if update}",
    		ctx
    	});

    	return block;
    }

    // (79:12) <Badge               className="margin-s position-absolute padding-none padding-s--r card--shadow bg--black fontsize-small"               style="bottom: 5px; left: 5px;"             >
    function create_default_slot_1$1(ctx) {
    	let icon;
    	let t;
    	let current;

    	icon = new Icon({
    			props: {
    				name: "lightning",
    				className: "bg--white color--" + /*colorName*/ ctx[3] + " border-radius-s padding-s margin-s--r",
    				style: "margin-left: -1px;",
    				width: "15"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    			t = text("\n              UPDATE");
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const icon_changes = {};
    			if (dirty[0] & /*colorName*/ 8) icon_changes.className = "bg--white color--" + /*colorName*/ ctx[3] + " border-radius-s padding-s margin-s--r";
    			icon.$set(icon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$1.name,
    		type: "slot",
    		source: "(79:12) <Badge               className=\\\"margin-s position-absolute padding-none padding-s--r card--shadow bg--black fontsize-small\\\"               style=\\\"bottom: 5px; left: 5px;\\\"             >",
    		ctx
    	});

    	return block;
    }

    // (97:10) {#if section || published}
    function create_if_block_1$1(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let current;
    	let if_block0 = /*section*/ ctx[10] && create_if_block_4(ctx);
    	let if_block1 = /*published*/ ctx[8] && create_if_block_3(ctx);
    	let if_block2 = /*saved*/ ctx[9] !== undefined && create_if_block_2(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			attr_dev(div, "class", "card-meta flex flex-wrap--wrap fontsize-xxsmall");
    			add_location(div, file$f, 97, 12, 3606);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t1);
    			if (if_block2) if_block2.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*section*/ ctx[10]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*section*/ 1024) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_4(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*published*/ ctx[8]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*published*/ 256) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_3(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*saved*/ ctx[9] !== undefined) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*saved*/ 512) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_2(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(97:10) {#if section || published}",
    		ctx
    	});

    	return block;
    }

    // (99:14) {#if section}
    function create_if_block_4(ctx) {
    	let div;
    	let span1;
    	let icon;
    	let t0;
    	let span0;
    	let t1;
    	let current;

    	icon = new Icon({
    			props: { name: "tag", width: "12" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			span1 = element("span");
    			create_component(icon.$$.fragment);
    			t0 = space();
    			span0 = element("span");
    			t1 = text(/*section*/ ctx[10]);
    			attr_dev(span0, "class", "padding-s--l");
    			add_location(span0, file$f, 102, 20, 3871);
    			attr_dev(span1, "class", "flex flex-justify--center");
    			add_location(span1, file$f, 100, 18, 3759);
    			attr_dev(div, "class", "card-meta-item");
    			add_location(div, file$f, 99, 16, 3712);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span1);
    			mount_component(icon, span1, null);
    			append_dev(span1, t0);
    			append_dev(span1, span0);
    			append_dev(span0, t1);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty[0] & /*section*/ 1024) set_data_dev(t1, /*section*/ ctx[10]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(99:14) {#if section}",
    		ctx
    	});

    	return block;
    }

    // (107:14) {#if published}
    function create_if_block_3(ctx) {
    	let div;
    	let icon;
    	let t0;
    	let span;
    	let t1_value = parseDate_1(/*published*/ ctx[8]) + "";
    	let t1;
    	let current;

    	icon = new Icon({
    			props: { name: "clock", width: "12" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(icon.$$.fragment);
    			t0 = space();
    			span = element("span");
    			t1 = text(t1_value);
    			attr_dev(span, "class", "padding-s--l");
    			add_location(span, file$f, 109, 18, 4128);
    			attr_dev(div, "class", "card-meta-item");
    			add_location(div, file$f, 107, 16, 4030);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(icon, div, null);
    			append_dev(div, t0);
    			append_dev(div, span);
    			append_dev(span, t1);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*published*/ 256) && t1_value !== (t1_value = parseDate_1(/*published*/ ctx[8]) + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(107:14) {#if published}",
    		ctx
    	});

    	return block;
    }

    // (113:14) {#if saved !== undefined}
    function create_if_block_2(ctx) {
    	let toggler;
    	let current;

    	toggler = new Toggler({
    			props: {
    				className: "card-meta-item padding-m--r padding-s--b",
    				defaultState: /*saved*/ ctx[9],
    				$$slots: {
    					off: [create_off_slot],
    					on: [create_on_slot]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	toggler.$on("toggle", /*toggleSave*/ ctx[19]);

    	const block = {
    		c: function create() {
    			create_component(toggler.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(toggler, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const toggler_changes = {};
    			if (dirty[0] & /*saved*/ 512) toggler_changes.defaultState = /*saved*/ ctx[9];

    			if (dirty[0] & /*$$scope*/ 1073741824) {
    				toggler_changes.$$scope = { dirty, ctx };
    			}

    			toggler.$set(toggler_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(toggler.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(toggler.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(toggler, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(113:14) {#if saved !== undefined}",
    		ctx
    	});

    	return block;
    }

    // (119:34)                      
    function fallback_block_1(ctx) {
    	let icon;
    	let t0;
    	let span;
    	let current;

    	icon = new Icon({
    			props: {
    				name: "bookmarksolid",
    				style: "color: var(--fgcolor--list);",
    				width: 12
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    			t0 = space();
    			span = element("span");
    			span.textContent = "Gemt";
    			attr_dev(span, "class", "padding-s--l");
    			set_style(span, "color", "var(--fgcolor--list)");
    			add_location(span, file$f, 120, 20, 4615);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, span, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_1.name,
    		type: "fallback",
    		source: "(119:34)                      ",
    		ctx
    	});

    	return block;
    }

    // (119:18) 
    function create_on_slot(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[28].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[30], get_default_slot_context_1);
    	const default_slot_or_fallback = default_slot || fallback_block_1(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 1073741824)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[30],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[30])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[30], dirty, get_default_slot_changes_1),
    						get_default_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_on_slot.name,
    		type: "slot",
    		source: "(119:18) ",
    		ctx
    	});

    	return block;
    }

    // (123:35)                      
    function fallback_block(ctx) {
    	let icon;
    	let t0;
    	let span;
    	let current;

    	icon = new Icon({
    			props: {
    				name: "bookmark",
    				style: "color: var(--fgcolor--list);",
    				width: 12
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    			t0 = space();
    			span = element("span");
    			span.textContent = "Gem";
    			attr_dev(span, "class", "padding-s--l");
    			set_style(span, "color", "var(--fgcolor--list)");
    			add_location(span, file$f, 124, 20, 4866);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, span, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block.name,
    		type: "fallback",
    		source: "(123:35)                      ",
    		ctx
    	});

    	return block;
    }

    // (123:18) 
    function create_off_slot(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[28].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[30], get_default_slot_context);
    	const default_slot_or_fallback = default_slot || fallback_block(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 1073741824)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[30],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[30])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[30], dirty, get_default_slot_changes),
    						get_default_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_off_slot.name,
    		type: "slot",
    		source: "(123:18) ",
    		ctx
    	});

    	return block;
    }

    // (64:2) <Card {url} className={cssClass} style={styleProp} data-breaking={breaking} on:click>
    function create_default_slot$3(ctx) {
    	let div2;
    	let t0;
    	let t1;
    	let t2;
    	let div1;
    	let div0;
    	let t3;
    	let h2;
    	let t4;
    	let h2_class_value;
    	let current;
    	let if_block0 = /*premium*/ ctx[7] && create_if_block_8(ctx);
    	let if_block1 = /*loading*/ ctx[1] && create_if_block_7(ctx);
    	let if_block2 = /*media*/ ctx[6] && create_if_block_5(ctx);
    	let if_block3 = (/*section*/ ctx[10] || /*published*/ ctx[8]) && create_if_block_1$1(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			div1 = element("div");
    			div0 = element("div");
    			if (if_block3) if_block3.c();
    			t3 = space();
    			h2 = element("h2");
    			t4 = text(/*title*/ ctx[0]);
    			attr_dev(h2, "class", h2_class_value = "card-title " + (/*truncateTitle*/ ctx[11] ? 'card-title--truncated' : ''));
    			attr_dev(h2, "style", /*titleStyle*/ ctx[18]);
    			add_location(h2, file$f, 130, 10, 5059);
    			attr_dev(div0, "class", "card-content");
    			add_location(div0, file$f, 95, 8, 3530);
    			attr_dev(div1, "class", "card-content-wrapper");
    			add_location(div1, file$f, 94, 6, 3487);
    			attr_dev(div2, "class", /*innerClass*/ ctx[14]);
    			add_location(div2, file$f, 64, 4, 2395);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			if (if_block0) if_block0.m(div2, null);
    			append_dev(div2, t0);
    			if (if_block1) if_block1.m(div2, null);
    			append_dev(div2, t1);
    			if (if_block2) if_block2.m(div2, null);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			if (if_block3) if_block3.m(div0, null);
    			append_dev(div0, t3);
    			append_dev(div0, h2);
    			append_dev(h2, t4);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*premium*/ ctx[7]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*premium*/ 128) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_8(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div2, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*loading*/ ctx[1]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_7(ctx);
    					if_block1.c();
    					if_block1.m(div2, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*media*/ ctx[6]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*media*/ 64) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_5(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div2, t2);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*section*/ ctx[10] || /*published*/ ctx[8]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[0] & /*section, published*/ 1280) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_1$1(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div0, t3);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty[0] & /*title*/ 1) set_data_dev(t4, /*title*/ ctx[0]);

    			if (!current || dirty[0] & /*truncateTitle*/ 2048 && h2_class_value !== (h2_class_value = "card-title " + (/*truncateTitle*/ ctx[11] ? 'card-title--truncated' : ''))) {
    				attr_dev(h2, "class", h2_class_value);
    			}

    			if (!current || dirty[0] & /*innerClass*/ 16384) {
    				attr_dev(div2, "class", /*innerClass*/ ctx[14]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(64:2) <Card {url} className={cssClass} style={styleProp} data-breaking={breaking} on:click>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$g(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = (/*loading*/ ctx[1] || !/*loading*/ ctx[1] && /*title*/ ctx[0]) && create_if_block$8(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*loading*/ ctx[1] || !/*loading*/ ctx[1] && /*title*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*loading, title*/ 3) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$8(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let styleProp;
    	let cssClass;
    	let mediaCssClass;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ArticleCard', slots, ['default']);
    	let { loading = false } = $$props;
    	let { title = '' } = $$props;
    	let { breaking = false } = $$props;
    	let { cardType = undefined } = $$props;
    	let { className = undefined } = $$props;
    	let { colorName = undefined } = $$props;
    	let { premiumMarkerSize = undefined } = $$props;
    	let { id = undefined } = $$props;
    	let { update = false } = $$props;
    	let { maxLines = undefined } = $$props;
    	let { media = undefined } = $$props;
    	let { premium = false } = $$props;
    	let { published = undefined } = $$props;
    	let { read = null } = $$props;
    	let { saved = undefined } = $$props;
    	let { section = undefined } = $$props;
    	let { style = '' } = $$props;
    	let { truncateTitle = false } = $$props;
    	let { url = undefined } = $$props;
    	let { width = '100%' } = $$props;
    	const dispatch = createEventDispatcher();
    	let baseClass = `card-mode card-mode--article`;
    	let loadingStyle = 'padding-top: 56.25%; width: 100%;';

    	if (loading) {
    		baseClass = `${baseClass} animation-fogwave`;
    		title = 'Loading';

    		switch (cardType) {
    			case 'small-media':
    			case 'small-media--reverse':
    				loadingStyle = 'width: 200px;height: 115px;';
    				break;
    		}
    	}

    	let innerClass = 'card-inner';

    	switch (cardType) {
    		case 'small-media':
    			innerClass = `${innerClass} card--small-media`;
    			break;
    		case 'small-media--reverse':
    			innerClass = `${innerClass} card--small-media card--small-media--reverse`;
    			break;
    	}

    	const titleStyle = maxLines ? `--max-lines: ${maxLines};` : undefined;
    	const readClass = read ? 'articlecard--read' : '';

    	function toggleSave(evt) {
    		dispatch('save', { id, save: evt.detail });
    	}

    	const writable_props = [
    		'loading',
    		'title',
    		'breaking',
    		'cardType',
    		'className',
    		'colorName',
    		'premiumMarkerSize',
    		'id',
    		'update',
    		'maxLines',
    		'media',
    		'premium',
    		'published',
    		'read',
    		'saved',
    		'section',
    		'style',
    		'truncateTitle',
    		'url',
    		'width'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ArticleCard> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('loading' in $$props) $$invalidate(1, loading = $$props.loading);
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    		if ('breaking' in $$props) $$invalidate(2, breaking = $$props.breaking);
    		if ('cardType' in $$props) $$invalidate(20, cardType = $$props.cardType);
    		if ('className' in $$props) $$invalidate(21, className = $$props.className);
    		if ('colorName' in $$props) $$invalidate(3, colorName = $$props.colorName);
    		if ('premiumMarkerSize' in $$props) $$invalidate(4, premiumMarkerSize = $$props.premiumMarkerSize);
    		if ('id' in $$props) $$invalidate(22, id = $$props.id);
    		if ('update' in $$props) $$invalidate(5, update = $$props.update);
    		if ('maxLines' in $$props) $$invalidate(23, maxLines = $$props.maxLines);
    		if ('media' in $$props) $$invalidate(6, media = $$props.media);
    		if ('premium' in $$props) $$invalidate(7, premium = $$props.premium);
    		if ('published' in $$props) $$invalidate(8, published = $$props.published);
    		if ('read' in $$props) $$invalidate(24, read = $$props.read);
    		if ('saved' in $$props) $$invalidate(9, saved = $$props.saved);
    		if ('section' in $$props) $$invalidate(10, section = $$props.section);
    		if ('style' in $$props) $$invalidate(25, style = $$props.style);
    		if ('truncateTitle' in $$props) $$invalidate(11, truncateTitle = $$props.truncateTitle);
    		if ('url' in $$props) $$invalidate(12, url = $$props.url);
    		if ('width' in $$props) $$invalidate(26, width = $$props.width);
    		if ('$$scope' in $$props) $$invalidate(30, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		parseDate: parseDate_1,
    		Badge,
    		Card,
    		Icon,
    		Toggler,
    		colorNames,
    		loading,
    		title,
    		breaking,
    		cardType,
    		className,
    		colorName,
    		premiumMarkerSize,
    		id,
    		update,
    		maxLines,
    		media,
    		premium,
    		published,
    		read,
    		saved,
    		section,
    		style,
    		truncateTitle,
    		url,
    		width,
    		dispatch,
    		baseClass,
    		loadingStyle,
    		innerClass,
    		titleStyle,
    		readClass,
    		toggleSave,
    		mediaCssClass,
    		cssClass,
    		styleProp
    	});

    	$$self.$inject_state = $$props => {
    		if ('loading' in $$props) $$invalidate(1, loading = $$props.loading);
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    		if ('breaking' in $$props) $$invalidate(2, breaking = $$props.breaking);
    		if ('cardType' in $$props) $$invalidate(20, cardType = $$props.cardType);
    		if ('className' in $$props) $$invalidate(21, className = $$props.className);
    		if ('colorName' in $$props) $$invalidate(3, colorName = $$props.colorName);
    		if ('premiumMarkerSize' in $$props) $$invalidate(4, premiumMarkerSize = $$props.premiumMarkerSize);
    		if ('id' in $$props) $$invalidate(22, id = $$props.id);
    		if ('update' in $$props) $$invalidate(5, update = $$props.update);
    		if ('maxLines' in $$props) $$invalidate(23, maxLines = $$props.maxLines);
    		if ('media' in $$props) $$invalidate(6, media = $$props.media);
    		if ('premium' in $$props) $$invalidate(7, premium = $$props.premium);
    		if ('published' in $$props) $$invalidate(8, published = $$props.published);
    		if ('read' in $$props) $$invalidate(24, read = $$props.read);
    		if ('saved' in $$props) $$invalidate(9, saved = $$props.saved);
    		if ('section' in $$props) $$invalidate(10, section = $$props.section);
    		if ('style' in $$props) $$invalidate(25, style = $$props.style);
    		if ('truncateTitle' in $$props) $$invalidate(11, truncateTitle = $$props.truncateTitle);
    		if ('url' in $$props) $$invalidate(12, url = $$props.url);
    		if ('width' in $$props) $$invalidate(26, width = $$props.width);
    		if ('baseClass' in $$props) $$invalidate(27, baseClass = $$props.baseClass);
    		if ('loadingStyle' in $$props) $$invalidate(13, loadingStyle = $$props.loadingStyle);
    		if ('innerClass' in $$props) $$invalidate(14, innerClass = $$props.innerClass);
    		if ('mediaCssClass' in $$props) $$invalidate(15, mediaCssClass = $$props.mediaCssClass);
    		if ('cssClass' in $$props) $$invalidate(16, cssClass = $$props.cssClass);
    		if ('styleProp' in $$props) $$invalidate(17, styleProp = $$props.styleProp);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*style, breaking, colorName, width*/ 100663308) {
    			$$invalidate(17, styleProp = `${style}; --color--list: var(--color--${breaking ? colorNames.breaking : colorName}); --fgcolor--list: var(--fgcolor--${breaking ? colorNames.breaking : colorName}); --card-width: ${width};`);
    		}

    		if ($$self.$$.dirty[0] & /*className, baseClass*/ 136314880) {
    			$$invalidate(16, cssClass = className
    			? `${className} ${baseClass} ${readClass}`
    			: `${baseClass} ${readClass}`);
    		}

    		if ($$self.$$.dirty[0] & /*media*/ 64) {
    			$$invalidate(15, mediaCssClass = media && media.className
    			? `${media.className} card-media`
    			: 'card-media');
    		}
    	};

    	return [
    		title,
    		loading,
    		breaking,
    		colorName,
    		premiumMarkerSize,
    		update,
    		media,
    		premium,
    		published,
    		saved,
    		section,
    		truncateTitle,
    		url,
    		loadingStyle,
    		innerClass,
    		mediaCssClass,
    		cssClass,
    		styleProp,
    		titleStyle,
    		toggleSave,
    		cardType,
    		className,
    		id,
    		maxLines,
    		read,
    		style,
    		width,
    		baseClass,
    		slots,
    		click_handler,
    		$$scope
    	];
    }

    class ArticleCard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$f,
    			create_fragment$g,
    			safe_not_equal,
    			{
    				loading: 1,
    				title: 0,
    				breaking: 2,
    				cardType: 20,
    				className: 21,
    				colorName: 3,
    				premiumMarkerSize: 4,
    				id: 22,
    				update: 5,
    				maxLines: 23,
    				media: 6,
    				premium: 7,
    				published: 8,
    				read: 24,
    				saved: 9,
    				section: 10,
    				style: 25,
    				truncateTitle: 11,
    				url: 12,
    				width: 26
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ArticleCard",
    			options,
    			id: create_fragment$g.name
    		});
    	}

    	get loading() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loading(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get breaking() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set breaking(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cardType() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cardType(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get colorName() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set colorName(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get premiumMarkerSize() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set premiumMarkerSize(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get update() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set update(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get maxLines() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set maxLines(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get media() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set media(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get premium() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set premium(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get published() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set published(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get read() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set read(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get saved() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set saved(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get section() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set section(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get truncateTitle() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set truncateTitle(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get url() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set url(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var ArticleCard$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': ArticleCard
    });

    var require$$1 = /*@__PURE__*/getAugmentedNamespace(ArticleCard$1);

    var throttle$1 = {};

    Object.defineProperty(throttle$1, "__esModule", { value: true });
    var throttle_2 = throttle$1.throttle = void 0;
    function throttle(callback, wait) {
        let inThrottle;
        return function () {
            const args = arguments;
            const context = this;
            if (!inThrottle) {
                callback.apply(context, args);
                inThrottle = true;
                setTimeout(() => (inThrottle = false), wait);
            }
        };
    }
    throttle_2 = throttle$1.throttle = throttle;

    /* node_modules/@ekstra-bladet/designsystem/dist/components/buttongroup/ButtonGroup.svelte generated by Svelte v3.46.4 */
    const file$e = "node_modules/@ekstra-bladet/designsystem/dist/components/buttongroup/ButtonGroup.svelte";

    function create_fragment$f(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[10].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", /*cssClass*/ ctx[1]);
    			attr_dev(div, "style", /*style*/ ctx[0]);
    			add_location(div, file$e, 57, 0, 2048);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[9],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*cssClass*/ 2) {
    				attr_dev(div, "class", /*cssClass*/ ctx[1]);
    			}

    			if (!current || dirty & /*style*/ 1) {
    				attr_dev(div, "style", /*style*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const BUTTONS$1 = {};

    function instance$e($$self, $$props, $$invalidate) {
    	let cssClass;
    	let style;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ButtonGroup', slots, ['default']);
    	const selectedId = writable(0);
    	const selectedButton = writable(null);
    	const buttons = [];

    	selectedId.subscribe(i => {
    		selectedButton.set(buttons[i]);
    	});

    	setContext(BUTTONS$1, {
    		createContextButton: () => {
    			return { button: buttons.length };
    		},
    		registerButton: button => {
    			buttons.push(button);
    			selectedButton.update(current => current || button);

    			onDestroy(() => {
    				const i = buttons.indexOf(button);
    				buttons.splice(i, 1);

    				selectedButton.update(current => current === button
    				? buttons[i] || buttons[buttons.length - 1]
    				: current);
    			});
    		},
    		selectButton: button => {
    			const i = buttons.indexOf(button);
    			selectedId.set(i);
    		},
    		selectedButton
    	});

    	let { className = undefined } = $$props;
    	let { type = undefined } = $$props;
    	let { color = undefined } = $$props;
    	let { colorHover = undefined } = $$props;
    	let { solid = false } = $$props;
    	let baseClass = `buttongroup`;

    	if (solid) {
    		baseClass = `${baseClass} buttongroup--solid`;
    	}

    	if (type) {
    		baseClass = `${baseClass} buttongroup--${type}`;
    	}

    	const { background: colorBackground, color: colorForeground } = Background[color]
    	? Background[color]
    	: Background['bruger'];

    	/**
     * If hovercolor is not specified, use color and utimately fall back to "Bruger"
     */
    	colorHover = color && !colorHover ? color : colorHover;

    	const { background: hoverColor, color: hoverColorForeground } = Background[colorHover]
    	? Background[colorHover]
    	: Background['bruger'];

    	const writable_props = ['className', 'type', 'color', 'colorHover', 'solid'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ButtonGroup> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('className' in $$props) $$invalidate(4, className = $$props.className);
    		if ('type' in $$props) $$invalidate(5, type = $$props.type);
    		if ('color' in $$props) $$invalidate(6, color = $$props.color);
    		if ('colorHover' in $$props) $$invalidate(2, colorHover = $$props.colorHover);
    		if ('solid' in $$props) $$invalidate(7, solid = $$props.solid);
    		if ('$$scope' in $$props) $$invalidate(9, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		BUTTONS: BUTTONS$1,
    		setContext,
    		onDestroy,
    		writable,
    		Background,
    		selectedId,
    		selectedButton,
    		buttons,
    		className,
    		type,
    		color,
    		colorHover,
    		solid,
    		baseClass,
    		colorBackground,
    		colorForeground,
    		hoverColor,
    		hoverColorForeground,
    		style,
    		cssClass
    	});

    	$$self.$inject_state = $$props => {
    		if ('className' in $$props) $$invalidate(4, className = $$props.className);
    		if ('type' in $$props) $$invalidate(5, type = $$props.type);
    		if ('color' in $$props) $$invalidate(6, color = $$props.color);
    		if ('colorHover' in $$props) $$invalidate(2, colorHover = $$props.colorHover);
    		if ('solid' in $$props) $$invalidate(7, solid = $$props.solid);
    		if ('baseClass' in $$props) $$invalidate(8, baseClass = $$props.baseClass);
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    		if ('cssClass' in $$props) $$invalidate(1, cssClass = $$props.cssClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, baseClass*/ 272) {
    			$$invalidate(1, cssClass = className ? `${className} ${baseClass}` : baseClass);
    		}
    	};

    	$$invalidate(0, style = `--buttongroup-color: ${colorBackground}; --buttongroup-fgcolor: ${colorForeground}; --buttongroup-color--hover: ${hoverColor}; --buttongroup-fgcolor--hover: ${hoverColorForeground};`);

    	return [
    		style,
    		cssClass,
    		colorHover,
    		selectedId,
    		className,
    		type,
    		color,
    		solid,
    		baseClass,
    		$$scope,
    		slots
    	];
    }

    class ButtonGroup extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$e, create_fragment$f, safe_not_equal, {
    			selectedId: 3,
    			className: 4,
    			type: 5,
    			color: 6,
    			colorHover: 2,
    			solid: 7
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ButtonGroup",
    			options,
    			id: create_fragment$f.name
    		});
    	}

    	get selectedId() {
    		return this.$$.ctx[3];
    	}

    	set selectedId(value) {
    		throw new Error("<ButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<ButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<ButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<ButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<ButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<ButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<ButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get colorHover() {
    		throw new Error("<ButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set colorHover(value) {
    		throw new Error("<ButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get solid() {
    		throw new Error("<ButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set solid(value) {
    		throw new Error("<ButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var ButtonGroup$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': ButtonGroup,
        BUTTONS: BUTTONS$1
    });

    /* node_modules/@ekstra-bladet/designsystem/dist/components/button/Button.svelte generated by Svelte v3.46.4 */
    const file$d = "node_modules/@ekstra-bladet/designsystem/dist/components/button/Button.svelte";

    // (53:0) {:else}
    function create_else_block$3(ctx) {
    	let button;
    	let button_data_selected_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[14].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

    	const block = {
    		c: function create() {
    			button = element("button");
    			if (default_slot) default_slot.c();
    			attr_dev(button, "class", /*cssClass*/ ctx[5]);
    			button.disabled = /*disabled*/ ctx[0];
    			attr_dev(button, "data-selected", button_data_selected_value = /*$selectedButton*/ ctx[6] === /*contextButton*/ ctx[3]);
    			add_location(button, file$d, 53, 2, 1520);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (default_slot) {
    				default_slot.m(button, null);
    			}

    			/*button_binding*/ ctx[18](button);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_1*/ ctx[16], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[13],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*cssClass*/ 32) {
    				attr_dev(button, "class", /*cssClass*/ ctx[5]);
    			}

    			if (!current || dirty & /*disabled*/ 1) {
    				prop_dev(button, "disabled", /*disabled*/ ctx[0]);
    			}

    			if (!current || dirty & /*$selectedButton, contextButton*/ 72 && button_data_selected_value !== (button_data_selected_value = /*$selectedButton*/ ctx[6] === /*contextButton*/ ctx[3])) {
    				attr_dev(button, "data-selected", button_data_selected_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (default_slot) default_slot.d(detaching);
    			/*button_binding*/ ctx[18](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(53:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (49:0) {#if href}
    function create_if_block$7(ctx) {
    	let a;
    	let a_data_selected_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[14].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (default_slot) default_slot.c();
    			attr_dev(a, "href", /*href*/ ctx[1]);
    			attr_dev(a, "class", /*cssClass*/ ctx[5]);
    			attr_dev(a, "disabled", /*disabled*/ ctx[0]);
    			attr_dev(a, "data-selected", a_data_selected_value = /*$selectedButton*/ ctx[6] === /*contextButton*/ ctx[3]);
    			add_location(a, file$d, 49, 2, 1371);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			/*a_binding*/ ctx[17](a);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*click_handler*/ ctx[15], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[13],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*href*/ 2) {
    				attr_dev(a, "href", /*href*/ ctx[1]);
    			}

    			if (!current || dirty & /*cssClass*/ 32) {
    				attr_dev(a, "class", /*cssClass*/ ctx[5]);
    			}

    			if (!current || dirty & /*disabled*/ 1) {
    				attr_dev(a, "disabled", /*disabled*/ ctx[0]);
    			}

    			if (!current || dirty & /*$selectedButton, contextButton*/ 72 && a_data_selected_value !== (a_data_selected_value = /*$selectedButton*/ ctx[6] === /*contextButton*/ ctx[3])) {
    				attr_dev(a, "data-selected", a_data_selected_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot) default_slot.d(detaching);
    			/*a_binding*/ ctx[17](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(49:0) {#if href}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$7, create_else_block$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*href*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let cssClass;

    	let $selectedButton,
    		$$unsubscribe_selectedButton = noop,
    		$$subscribe_selectedButton = () => ($$unsubscribe_selectedButton(), $$unsubscribe_selectedButton = subscribe(selectedButton, $$value => $$invalidate(6, $selectedButton = $$value)), selectedButton);

    	$$self.$$.on_destroy.push(() => $$unsubscribe_selectedButton());
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Button', slots, ['default']);
    	let { className = undefined } = $$props;
    	let { disabled = false } = $$props;
    	let { extension = undefined } = $$props;
    	let { href = undefined } = $$props;
    	let { size = undefined } = $$props;
    	let { type = undefined } = $$props;
    	let baseClass = 'button';

    	if (extension) {
    		let extSplit = extension.split(' ');

    		extSplit.forEach(extClass => {
    			$$invalidate(12, baseClass = `${baseClass} button--${extClass}`);
    		});
    	}

    	if (size) {
    		baseClass = `${baseClass} button--${size}`;
    	}

    	if (type) {
    		baseClass = `${baseClass} button--${type}`;
    	}

    	let buttonEl;
    	let { initial = false } = $$props;
    	let contextButton;
    	let selectButton;
    	let selectedButton;
    	const contextButtons = getContext(BUTTONS$1);

    	if (contextButtons) {
    		const registerButton = contextButtons.registerButton;
    		contextButton = contextButtons.createContextButton();
    		selectButton = contextButtons.selectButton;
    		$$subscribe_selectedButton(selectedButton = contextButtons.selectedButton);
    		registerButton(contextButton);

    		if (initial) {
    			selectButton(contextButton);
    		}
    	}

    	onMount(() => {
    		if (typeof selectButton !== 'undefined') {
    			buttonEl.addEventListener('click', () => selectButton(contextButton));
    		}
    	});

    	const writable_props = ['className', 'disabled', 'extension', 'href', 'size', 'type', 'initial'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Button> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function click_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function a_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			buttonEl = $$value;
    			$$invalidate(2, buttonEl);
    		});
    	}

    	function button_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			buttonEl = $$value;
    			$$invalidate(2, buttonEl);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('className' in $$props) $$invalidate(7, className = $$props.className);
    		if ('disabled' in $$props) $$invalidate(0, disabled = $$props.disabled);
    		if ('extension' in $$props) $$invalidate(8, extension = $$props.extension);
    		if ('href' in $$props) $$invalidate(1, href = $$props.href);
    		if ('size' in $$props) $$invalidate(9, size = $$props.size);
    		if ('type' in $$props) $$invalidate(10, type = $$props.type);
    		if ('initial' in $$props) $$invalidate(11, initial = $$props.initial);
    		if ('$$scope' in $$props) $$invalidate(13, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		className,
    		disabled,
    		extension,
    		href,
    		size,
    		type,
    		baseClass,
    		buttonEl,
    		getContext,
    		onMount,
    		BUTTONS: BUTTONS$1,
    		initial,
    		contextButton,
    		selectButton,
    		selectedButton,
    		contextButtons,
    		cssClass,
    		$selectedButton
    	});

    	$$self.$inject_state = $$props => {
    		if ('className' in $$props) $$invalidate(7, className = $$props.className);
    		if ('disabled' in $$props) $$invalidate(0, disabled = $$props.disabled);
    		if ('extension' in $$props) $$invalidate(8, extension = $$props.extension);
    		if ('href' in $$props) $$invalidate(1, href = $$props.href);
    		if ('size' in $$props) $$invalidate(9, size = $$props.size);
    		if ('type' in $$props) $$invalidate(10, type = $$props.type);
    		if ('baseClass' in $$props) $$invalidate(12, baseClass = $$props.baseClass);
    		if ('buttonEl' in $$props) $$invalidate(2, buttonEl = $$props.buttonEl);
    		if ('initial' in $$props) $$invalidate(11, initial = $$props.initial);
    		if ('contextButton' in $$props) $$invalidate(3, contextButton = $$props.contextButton);
    		if ('selectButton' in $$props) selectButton = $$props.selectButton;
    		if ('selectedButton' in $$props) $$subscribe_selectedButton($$invalidate(4, selectedButton = $$props.selectedButton));
    		if ('cssClass' in $$props) $$invalidate(5, cssClass = $$props.cssClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, baseClass*/ 4224) {
    			$$invalidate(5, cssClass = className ? `${baseClass} ${className}` : baseClass);
    		}
    	};

    	return [
    		disabled,
    		href,
    		buttonEl,
    		contextButton,
    		selectedButton,
    		cssClass,
    		$selectedButton,
    		className,
    		extension,
    		size,
    		type,
    		initial,
    		baseClass,
    		$$scope,
    		slots,
    		click_handler,
    		click_handler_1,
    		a_binding,
    		button_binding
    	];
    }

    class Button extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$d, create_fragment$e, safe_not_equal, {
    			className: 7,
    			disabled: 0,
    			extension: 8,
    			href: 1,
    			size: 9,
    			type: 10,
    			initial: 11
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Button",
    			options,
    			id: create_fragment$e.name
    		});
    	}

    	get className() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get extension() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set extension(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get initial() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set initial(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Button$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Button
    });

    /* node_modules/@ekstra-bladet/designsystem/dist/components/horizontalScroll/HorizontalScroll.svelte generated by Svelte v3.46.4 */
    const file$c = "node_modules/@ekstra-bladet/designsystem/dist/components/horizontalScroll/HorizontalScroll.svelte";

    // (122:2) <Button on:click={prevScroll} className="horizontal-scroll-nav button-prev bg--white" extension="icon">
    function create_default_slot_1(ctx) {
    	let icon;
    	let current;

    	icon = new Icon({
    			props: { name: "angleleft", width: "14" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(122:2) <Button on:click={prevScroll} className=\\\"horizontal-scroll-nav button-prev bg--white\\\" extension=\\\"icon\\\">",
    		ctx
    	});

    	return block;
    }

    // (125:2) <Button on:click={nextScroll} className="horizontal-scroll-nav button-next bg--white" extension="icon">
    function create_default_slot$2(ctx) {
    	let icon;
    	let current;

    	icon = new Icon({
    			props: { name: "angleright", width: "14" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(125:2) <Button on:click={nextScroll} className=\\\"horizontal-scroll-nav button-next bg--white\\\" extension=\\\"icon\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let div1;
    	let button0;
    	let t0;
    	let button1;
    	let t1;
    	let div0;
    	let current;

    	button0 = new Button({
    			props: {
    				className: "horizontal-scroll-nav button-prev bg--white",
    				extension: "icon",
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("click", /*prevScroll*/ ctx[4]);

    	button1 = new Button({
    			props: {
    				className: "horizontal-scroll-nav button-next bg--white",
    				extension: "icon",
    				$$slots: { default: [create_default_slot$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("click", /*nextScroll*/ ctx[3]);
    	const default_slot_template = /*#slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			create_component(button0.$$.fragment);
    			t0 = space();
    			create_component(button1.$$.fragment);
    			t1 = space();
    			div0 = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div0, "class", "horizontal-scroll-items horizontal-scroll-items--gap flex position-relative");
    			attr_dev(div0, "data-horizontallist", "horizontallist");
    			add_location(div0, file$c, 127, 2, 4083);
    			attr_dev(div1, "class", /*cssClass*/ ctx[2]);
    			add_location(div1, file$c, 120, 0, 3711);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			mount_component(button0, div1, null);
    			append_dev(div1, t0);
    			mount_component(button1, div1, null);
    			append_dev(div1, t1);
    			append_dev(div1, div0);

    			if (default_slot) {
    				default_slot.m(div0, null);
    			}

    			/*div0_binding*/ ctx[7](div0);
    			/*div1_binding*/ ctx[8](div1);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[9],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*cssClass*/ 4) {
    				attr_dev(div1, "class", /*cssClass*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(button0);
    			destroy_component(button1);
    			if (default_slot) default_slot.d(detaching);
    			/*div0_binding*/ ctx[7](null);
    			/*div1_binding*/ ctx[8](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let cssClass;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('HorizontalScroll', slots, ['default']);
    	let { className = undefined } = $$props;
    	let baseClass = `horizontal-scroll-container position-relative`;

    	/* Horizontial Scroll elements */
    	let scrollContainer;

    	let scrollItemContainer;
    	let listCurrent = 0;
    	let children;
    	let maxLength;
    	let listLength;

    	function updateDataSet(pos, fromScroll = false) {
    		switch (pos) {
    			case 'neutral':
    				$$invalidate(0, scrollContainer.dataset.atstart = 'false', scrollContainer);
    				$$invalidate(0, scrollContainer.dataset.atend = 'false', scrollContainer);
    				if (fromScroll) listCurrent = 1;
    				break;
    			case 'end':
    				$$invalidate(0, scrollContainer.dataset.atstart = 'false', scrollContainer);
    				$$invalidate(0, scrollContainer.dataset.atend = 'true', scrollContainer);
    				listCurrent = maxLength;
    				break;
    			case 'start':
    				$$invalidate(0, scrollContainer.dataset.atstart = 'true', scrollContainer);
    				$$invalidate(0, scrollContainer.dataset.atend = 'false', scrollContainer);
    				listCurrent = 0;
    				break;
    			case 'disabled':
    				$$invalidate(0, scrollContainer.dataset.atstart = 'true', scrollContainer);
    				$$invalidate(0, scrollContainer.dataset.atend = 'true', scrollContainer);
    				break;
    		}
    	}

    	function updateButtons() {
    		if (listCurrent === 0) {
    			updateDataSet('start');
    		} else if (listCurrent === maxLength) {
    			updateDataSet('end');
    		} else {
    			updateDataSet('neutral');
    		}
    	}

    	function updateButtonsThroughScroll() {
    		const childLeft = children[0].getBoundingClientRect().left;
    		const wrapLeft = scrollItemContainer.getBoundingClientRect().left;
    		const childRight = children[listLength - 1].getBoundingClientRect().right;
    		const wrapRight = scrollItemContainer.getBoundingClientRect().right;
    		const childrenHiddenLeft = childLeft < wrapLeft;
    		const childrenHiddenRight = childRight > wrapRight;

    		if (childrenHiddenLeft && childrenHiddenRight) {
    			updateDataSet('neutral', true);
    		} else if (childrenHiddenLeft) {
    			updateDataSet('end', true);
    		} else if (childrenHiddenRight) {
    			updateDataSet('start', true);
    		} else {
    			updateDataSet('disabled', true);
    		}
    	}

    	/**
     * Advance scroll to make next or previous element visible
     */
    	function scroll(listCurrent) {
    		const newPos = children[listCurrent];

    		scrollItemContainer.scrollTo({
    			behavior: 'smooth',
    			left: newPos.offsetLeft,
    			top: 0
    		});

    		updateButtons();
    	}

    	function nextScroll(_ev) {
    		if (listCurrent !== maxLength) {
    			listCurrent = listCurrent + 1;
    			scroll(listCurrent);
    		}
    	}

    	function prevScroll(_ev) {
    		if (listCurrent !== 0) {
    			listCurrent = listCurrent - 1;
    			scroll(listCurrent);
    		}
    	}

    	onMount(() => {
    		scrollItemContainer.addEventListener('wheel', throttle_2(
    			() => {
    				updateButtonsThroughScroll();
    			},
    			150
    		));
    	});

    	afterUpdate(() => {
    		if (listLength === scrollItemContainer.children.length) return;
    		children = scrollItemContainer.children;
    		listLength = children.length;
    		const containerBBox = scrollContainer.getBoundingClientRect();

    		/**
     * Find how many visible elements we have
     */
    		let visibleChildren = Array.from(children).filter(child => child.getBoundingClientRect().left >= containerBBox.left && child.getBoundingClientRect().right <= containerBBox.right).length;

    		maxLength = listLength - visibleChildren;

    		if (maxLength) {
    			// Some children not visible - enable scroling
    			updateButtons();
    		} else {
    			updateDataSet('disabled');
    		}
    	});

    	const writable_props = ['className'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<HorizontalScroll> was created with unknown prop '${key}'`);
    	});

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			scrollItemContainer = $$value;
    			$$invalidate(1, scrollItemContainer);
    		});
    	}

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			scrollContainer = $$value;
    			$$invalidate(0, scrollContainer);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('className' in $$props) $$invalidate(5, className = $$props.className);
    		if ('$$scope' in $$props) $$invalidate(9, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		afterUpdate,
    		onMount,
    		throttle: throttle_2,
    		Button,
    		Icon,
    		className,
    		baseClass,
    		scrollContainer,
    		scrollItemContainer,
    		listCurrent,
    		children,
    		maxLength,
    		listLength,
    		updateDataSet,
    		updateButtons,
    		updateButtonsThroughScroll,
    		scroll,
    		nextScroll,
    		prevScroll,
    		cssClass
    	});

    	$$self.$inject_state = $$props => {
    		if ('className' in $$props) $$invalidate(5, className = $$props.className);
    		if ('baseClass' in $$props) $$invalidate(14, baseClass = $$props.baseClass);
    		if ('scrollContainer' in $$props) $$invalidate(0, scrollContainer = $$props.scrollContainer);
    		if ('scrollItemContainer' in $$props) $$invalidate(1, scrollItemContainer = $$props.scrollItemContainer);
    		if ('listCurrent' in $$props) listCurrent = $$props.listCurrent;
    		if ('children' in $$props) children = $$props.children;
    		if ('maxLength' in $$props) maxLength = $$props.maxLength;
    		if ('listLength' in $$props) listLength = $$props.listLength;
    		if ('cssClass' in $$props) $$invalidate(2, cssClass = $$props.cssClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className*/ 32) {
    			$$invalidate(2, cssClass = className ? `${className} ${baseClass}` : baseClass);
    		}
    	};

    	return [
    		scrollContainer,
    		scrollItemContainer,
    		cssClass,
    		nextScroll,
    		prevScroll,
    		className,
    		slots,
    		div0_binding,
    		div1_binding,
    		$$scope
    	];
    }

    class HorizontalScroll extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$d, safe_not_equal, { className: 5 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HorizontalScroll",
    			options,
    			id: create_fragment$d.name
    		});
    	}

    	get className() {
    		throw new Error("<HorizontalScroll>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<HorizontalScroll>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var HorizontalScroll$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': HorizontalScroll
    });

    /* node_modules/@ekstra-bladet/designsystem/dist/components/articlelist/ArticleList.svelte generated by Svelte v3.46.4 */
    const file$b = "node_modules/@ekstra-bladet/designsystem/dist/components/articlelist/ArticleList.svelte";

    // (47:2) {:else}
    function create_else_block$2(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[11].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "articlelist articlelist--columns");
    			attr_dev(div, "data-items", /*$childrenLength*/ ctx[1]);
    			set_style(div, "--articlelist-columns", /*$childrenLength*/ ctx[1]);
    			add_location(div, file$b, 47, 4, 2007);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[13],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*$childrenLength*/ 2) {
    				attr_dev(div, "data-items", /*$childrenLength*/ ctx[1]);
    			}

    			if (!current || dirty & /*$childrenLength*/ 2) {
    				set_style(div, "--articlelist-columns", /*$childrenLength*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(47:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (43:2) {#if $writableType === LISTTYPE.horizontal}
    function create_if_block$6(ctx) {
    	let horizontalscroll;
    	let current;

    	horizontalscroll = new HorizontalScroll({
    			props: {
    				$$slots: { default: [create_default_slot$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(horizontalscroll.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(horizontalscroll, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const horizontalscroll_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				horizontalscroll_changes.$$scope = { dirty, ctx };
    			}

    			horizontalscroll.$set(horizontalscroll_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(horizontalscroll.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(horizontalscroll.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(horizontalscroll, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(43:2) {#if $writableType === LISTTYPE.horizontal}",
    		ctx
    	});

    	return block;
    }

    // (44:4) <HorizontalScroll>
    function create_default_slot$1(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[11].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[13],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(44:4) <HorizontalScroll>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$6, create_else_block$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$writableType*/ ctx[5] === /*LISTTYPE*/ ctx[2].horizontal) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", /*className*/ ctx[0]);
    			set_style(div, "--card-mode--title", "var(--fs-" + /*titleFs*/ ctx[4] + ")");
    			add_location(div, file$b, 41, 0, 1779);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			/*div_binding*/ ctx[12](div);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}

    			if (!current || dirty & /*className*/ 1) {
    				attr_dev(div, "class", /*className*/ ctx[0]);
    			}

    			if (!current || dirty & /*titleFs*/ 16) {
    				set_style(div, "--card-mode--title", "var(--fs-" + /*titleFs*/ ctx[4] + ")");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    			/*div_binding*/ ctx[12](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let $childrenLength;
    	let $writableType;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ArticleList', slots, ['default']);
    	var _a;
    	var LISTTYPE;

    	(function (LISTTYPE) {
    		LISTTYPE["columns"] = "columns";
    		LISTTYPE["horizontal"] = "horizontal";
    		LISTTYPE["vertical"] = "vertical";
    	})(LISTTYPE || (LISTTYPE = {}));

    	let { className = 'margin-l--tb' } = $$props;
    	let { fontsizes = ['xxlarge', 'xlarge', 'large'] } = $$props;
    	let { type = LISTTYPE.horizontal } = $$props;
    	const writableType = writable(type);
    	validate_store(writableType, 'writableType');
    	component_subscribe($$self, writableType, value => $$invalidate(5, $writableType = value));
    	const childrenLength = writable(0);
    	validate_store(childrenLength, 'childrenLength');
    	component_subscribe($$self, childrenLength, value => $$invalidate(1, $childrenLength = value));
    	let articleListContainer;
    	let itemWidth;

    	const getChildrenWidth = () => articleListContainer.querySelector('[data-horizontallist="horizontallist"]')
    	? articleListContainer.querySelector('[data-horizontallist="horizontallist"]').children[0].clientWidth
    	: articleListContainer.children[0].children[0].clientWidth;

    	const getChildrenCount = () => articleListContainer.querySelector('[data-horizontallist="horizontallist"]')
    	? articleListContainer.querySelector('[data-horizontallist="horizontallist"]').children.length
    	: articleListContainer.children[0].children.length;

    	function updateType() {
    		itemWidth = itemWidth !== null && itemWidth !== void 0
    		? itemWidth
    		: getChildrenWidth();

    		if ($childrenLength <= Math.round(articleListContainer.clientWidth / itemWidth) && type === LISTTYPE.horizontal) {
    			writableType.set(LISTTYPE.columns);
    		} else {
    			writableType.set(LISTTYPE.horizontal);
    		}
    	}

    	afterUpdate(() => {
    		const childrenCount = getChildrenCount();
    		childrenLength.set(childrenCount);
    		updateType();
    	});

    	let titleFs;
    	const writable_props = ['className', 'fontsizes', 'type'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ArticleList> was created with unknown prop '${key}'`);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			articleListContainer = $$value;
    			$$invalidate(3, articleListContainer);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('className' in $$props) $$invalidate(0, className = $$props.className);
    		if ('fontsizes' in $$props) $$invalidate(8, fontsizes = $$props.fontsizes);
    		if ('type' in $$props) $$invalidate(9, type = $$props.type);
    		if ('$$scope' in $$props) $$invalidate(13, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		_a,
    		afterUpdate,
    		writable,
    		HorizontalScroll,
    		LISTTYPE,
    		className,
    		fontsizes,
    		type,
    		writableType,
    		childrenLength,
    		articleListContainer,
    		itemWidth,
    		getChildrenWidth,
    		getChildrenCount,
    		updateType,
    		titleFs,
    		$childrenLength,
    		$writableType
    	});

    	$$self.$inject_state = $$props => {
    		if ('_a' in $$props) $$invalidate(10, _a = $$props._a);
    		if ('LISTTYPE' in $$props) $$invalidate(2, LISTTYPE = $$props.LISTTYPE);
    		if ('className' in $$props) $$invalidate(0, className = $$props.className);
    		if ('fontsizes' in $$props) $$invalidate(8, fontsizes = $$props.fontsizes);
    		if ('type' in $$props) $$invalidate(9, type = $$props.type);
    		if ('articleListContainer' in $$props) $$invalidate(3, articleListContainer = $$props.articleListContainer);
    		if ('itemWidth' in $$props) itemWidth = $$props.itemWidth;
    		if ('titleFs' in $$props) $$invalidate(4, titleFs = $$props.titleFs);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*fontsizes, $childrenLength, _a*/ 1282) {
    			$$invalidate(4, titleFs = $$invalidate(10, _a = fontsizes[$childrenLength - 1]) !== null && _a !== void 0
    			? _a
    			: fontsizes[fontsizes.length - 1]);
    		}
    	};

    	return [
    		className,
    		$childrenLength,
    		LISTTYPE,
    		articleListContainer,
    		titleFs,
    		$writableType,
    		writableType,
    		childrenLength,
    		fontsizes,
    		type,
    		_a,
    		slots,
    		div_binding,
    		$$scope
    	];
    }

    class ArticleList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$c, safe_not_equal, { className: 0, fontsizes: 8, type: 9 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ArticleList",
    			options,
    			id: create_fragment$c.name
    		});
    	}

    	get className() {
    		throw new Error("<ArticleList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<ArticleList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fontsizes() {
    		throw new Error("<ArticleList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fontsizes(value) {
    		throw new Error("<ArticleList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<ArticleList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<ArticleList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var ArticleList$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': ArticleList
    });

    var require$$2 = /*@__PURE__*/getAugmentedNamespace(ArticleList$1);

    var require$$3 = /*@__PURE__*/getAugmentedNamespace(Badge$1);

    var require$$4 = /*@__PURE__*/getAugmentedNamespace(Button$1);

    var require$$5 = /*@__PURE__*/getAugmentedNamespace(ButtonGroup$1);

    var require$$6 = /*@__PURE__*/getAugmentedNamespace(Card$1);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/form-elements/Checkbox.svelte generated by Svelte v3.46.4 */
    const file$a = "node_modules/@ekstra-bladet/designsystem/dist/components/form-elements/Checkbox.svelte";

    // (20:4) {:else}
    function create_else_block$1(ctx) {
    	let icon0;
    	let t;
    	let icon1;
    	let current;

    	icon0 = new Icon({
    			props: {
    				className: "form-checkbox-toggle--on margin-s--l",
    				name: "checkcircle",
    				width: "16"
    			},
    			$$inline: true
    		});

    	icon1 = new Icon({
    			props: {
    				className: "form-checkbox-toggle--off margin-s--l",
    				name: "circle",
    				width: "16"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon0.$$.fragment);
    			t = space();
    			create_component(icon1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(icon1, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon0.$$.fragment, local);
    			transition_in(icon1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon0.$$.fragment, local);
    			transition_out(icon1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(icon1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(20:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (17:4) {#if inputtype === 'checkbox'}
    function create_if_block$5(ctx) {
    	let icon0;
    	let t;
    	let icon1;
    	let current;

    	icon0 = new Icon({
    			props: {
    				className: "form-checkbox-toggle--on margin-s--l",
    				name: "checksquare",
    				width: "16"
    			},
    			$$inline: true
    		});

    	icon1 = new Icon({
    			props: {
    				className: "form-checkbox-toggle--off margin-s--l",
    				name: "square",
    				width: "16"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon0.$$.fragment);
    			t = space();
    			create_component(icon1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(icon1, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon0.$$.fragment, local);
    			transition_in(icon1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon0.$$.fragment, local);
    			transition_out(icon1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(icon1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(17:4) {#if inputtype === 'checkbox'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let label_1;
    	let input;
    	let t0;
    	let span;
    	let t1;
    	let t2;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$5, create_else_block$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*inputtype*/ ctx[3] === 'checkbox') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			label_1 = element("label");
    			input = element("input");
    			t0 = space();
    			span = element("span");
    			t1 = text(/*label*/ ctx[2]);
    			t2 = space();
    			if_block.c();
    			attr_dev(input, "type", /*inputtype*/ ctx[3]);
    			attr_dev(input, "class", /*baseClass*/ ctx[5]);
    			attr_dev(input, "name", /*fieldName*/ ctx[0]);
    			attr_dev(input, "group", /*group*/ ctx[1]);
    			input.value = /*value*/ ctx[4];
    			add_location(input, file$a, 13, 2, 378);
    			attr_dev(span, "class", "flex form-label");
    			add_location(span, file$a, 14, 2, 458);
    			add_location(label_1, file$a, 12, 0, 368);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label_1, anchor);
    			append_dev(label_1, input);
    			append_dev(label_1, t0);
    			append_dev(label_1, span);
    			append_dev(span, t1);
    			append_dev(span, t2);
    			if_blocks[current_block_type_index].m(span, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*inputtype*/ 8) {
    				attr_dev(input, "type", /*inputtype*/ ctx[3]);
    			}

    			if (!current || dirty & /*baseClass*/ 32) {
    				attr_dev(input, "class", /*baseClass*/ ctx[5]);
    			}

    			if (!current || dirty & /*fieldName*/ 1) {
    				attr_dev(input, "name", /*fieldName*/ ctx[0]);
    			}

    			if (!current || dirty & /*group*/ 2) {
    				attr_dev(input, "group", /*group*/ ctx[1]);
    			}

    			if (!current || dirty & /*value*/ 16 && input.value !== /*value*/ ctx[4]) {
    				prop_dev(input, "value", /*value*/ ctx[4]);
    			}

    			if (!current || dirty & /*label*/ 4) set_data_dev(t1, /*label*/ ctx[2]);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(span, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label_1);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Checkbox', slots, []);
    	let { fieldName = undefined } = $$props;
    	let { group = undefined } = $$props;
    	let { label = undefined } = $$props;
    	let { inputtype = 'checkbox' } = $$props;
    	let { value = '' } = $$props;
    	let { className = undefined } = $$props;
    	let baseClass = `form-checkbox form-checkbox--icon`;
    	if (className) baseClass = `${className} ${baseClass}`;
    	const writable_props = ['fieldName', 'group', 'label', 'inputtype', 'value', 'className'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Checkbox> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('fieldName' in $$props) $$invalidate(0, fieldName = $$props.fieldName);
    		if ('group' in $$props) $$invalidate(1, group = $$props.group);
    		if ('label' in $$props) $$invalidate(2, label = $$props.label);
    		if ('inputtype' in $$props) $$invalidate(3, inputtype = $$props.inputtype);
    		if ('value' in $$props) $$invalidate(4, value = $$props.value);
    		if ('className' in $$props) $$invalidate(6, className = $$props.className);
    	};

    	$$self.$capture_state = () => ({
    		Icon,
    		fieldName,
    		group,
    		label,
    		inputtype,
    		value,
    		className,
    		baseClass
    	});

    	$$self.$inject_state = $$props => {
    		if ('fieldName' in $$props) $$invalidate(0, fieldName = $$props.fieldName);
    		if ('group' in $$props) $$invalidate(1, group = $$props.group);
    		if ('label' in $$props) $$invalidate(2, label = $$props.label);
    		if ('inputtype' in $$props) $$invalidate(3, inputtype = $$props.inputtype);
    		if ('value' in $$props) $$invalidate(4, value = $$props.value);
    		if ('className' in $$props) $$invalidate(6, className = $$props.className);
    		if ('baseClass' in $$props) $$invalidate(5, baseClass = $$props.baseClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [fieldName, group, label, inputtype, value, baseClass, className];
    }

    class Checkbox extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$a, create_fragment$b, safe_not_equal, {
    			fieldName: 0,
    			group: 1,
    			label: 2,
    			inputtype: 3,
    			value: 4,
    			className: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Checkbox",
    			options,
    			id: create_fragment$b.name
    		});
    	}

    	get fieldName() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fieldName(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get group() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set group(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inputtype() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputtype(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Checkbox$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Checkbox
    });

    var require$$7 = /*@__PURE__*/getAugmentedNamespace(Checkbox$1);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/form-elements/Select.svelte generated by Svelte v3.46.4 */

    const file$9 = "node_modules/@ekstra-bladet/designsystem/dist/components/form-elements/Select.svelte";

    function create_fragment$a(ctx) {
    	let label_1;
    	let t0;
    	let t1;
    	let select;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

    	const block = {
    		c: function create() {
    			label_1 = element("label");
    			t0 = text(/*label*/ ctx[1]);
    			t1 = space();
    			select = element("select");
    			if (default_slot) default_slot.c();
    			attr_dev(label_1, "class", "form-label");
    			attr_dev(label_1, "for", "select");
    			add_location(label_1, file$9, 9, 0, 272);
    			attr_dev(select, "classname", /*baseClass*/ ctx[2]);
    			attr_dev(select, "id", "select");
    			if (/*selected*/ ctx[0] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[7].call(select));
    			add_location(select, file$9, 10, 0, 327);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label_1, anchor);
    			append_dev(label_1, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, select, anchor);

    			if (default_slot) {
    				default_slot.m(select, null);
    			}

    			select_option(select, /*selected*/ ctx[0]);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(select, "change", /*select_change_handler*/ ctx[7]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*label*/ 2) set_data_dev(t0, /*label*/ ctx[1]);

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[5],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*baseClass*/ 4) {
    				attr_dev(select, "classname", /*baseClass*/ ctx[2]);
    			}

    			if (dirty & /*selected*/ 1) {
    				select_option(select, /*selected*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label_1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(select);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Select', slots, ['default']);
    	let { inputtype = 'text' } = $$props;
    	let { label = undefined } = $$props;
    	let { className = undefined } = $$props;
    	let { selected = undefined } = $$props;
    	let baseClass = `form-input form-input--${inputtype}`;
    	if (className) baseClass = `${className} ${baseClass}`;
    	const writable_props = ['inputtype', 'label', 'className', 'selected'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Select> was created with unknown prop '${key}'`);
    	});

    	function select_change_handler() {
    		selected = select_value(this);
    		$$invalidate(0, selected);
    	}

    	$$self.$$set = $$props => {
    		if ('inputtype' in $$props) $$invalidate(3, inputtype = $$props.inputtype);
    		if ('label' in $$props) $$invalidate(1, label = $$props.label);
    		if ('className' in $$props) $$invalidate(4, className = $$props.className);
    		if ('selected' in $$props) $$invalidate(0, selected = $$props.selected);
    		if ('$$scope' in $$props) $$invalidate(5, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		inputtype,
    		label,
    		className,
    		selected,
    		baseClass
    	});

    	$$self.$inject_state = $$props => {
    		if ('inputtype' in $$props) $$invalidate(3, inputtype = $$props.inputtype);
    		if ('label' in $$props) $$invalidate(1, label = $$props.label);
    		if ('className' in $$props) $$invalidate(4, className = $$props.className);
    		if ('selected' in $$props) $$invalidate(0, selected = $$props.selected);
    		if ('baseClass' in $$props) $$invalidate(2, baseClass = $$props.baseClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		selected,
    		label,
    		baseClass,
    		inputtype,
    		className,
    		$$scope,
    		slots,
    		select_change_handler
    	];
    }

    class Select extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$9, create_fragment$a, safe_not_equal, {
    			inputtype: 3,
    			label: 1,
    			className: 4,
    			selected: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Select",
    			options,
    			id: create_fragment$a.name
    		});
    	}

    	get inputtype() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputtype(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selected() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selected(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Select$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Select
    });

    /* node_modules/@ekstra-bladet/designsystem/dist/components/form-elements/TextInput.svelte generated by Svelte v3.46.4 */
    const file$8 = "node_modules/@ekstra-bladet/designsystem/dist/components/form-elements/TextInput.svelte";

    // (28:2) {#if label}
    function create_if_block$4(ctx) {
    	let span;
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text(/*label*/ ctx[1]);
    			t1 = text(":");
    			attr_dev(span, "class", "hidden");
    			add_location(span, file$8, 28, 4, 954);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			append_dev(span, t1);
    			/*span_binding*/ ctx[8](span);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*label*/ 2) set_data_dev(t0, /*label*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			/*span_binding*/ ctx[8](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(28:2) {#if label}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$9(ctx) {
    	let div;
    	let t;
    	let input;
    	let div_class_value;
    	let mounted;
    	let dispose;
    	let if_block = /*label*/ ctx[1] && create_if_block$4(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			input = element("input");
    			attr_dev(input, "type", /*inputtype*/ ctx[0]);
    			attr_dev(input, "placeholder", /*label*/ ctx[1]);
    			attr_dev(input, "class", /*baseClass*/ ctx[5]);
    			add_location(input, file$8, 30, 2, 1026);
    			attr_dev(div, "class", div_class_value = `form-input-container flex border-radius padding-m--rl ${/*size*/ ctx[2]}`);
    			add_location(div, file$8, 26, 0, 858);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t);
    			append_dev(div, input);
    			/*input_binding*/ ctx[9](input);

    			if (!mounted) {
    				dispose = listen_dev(input, "focus", /*focus_handler*/ ctx[7], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*label*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$4(ctx);
    					if_block.c();
    					if_block.m(div, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*inputtype*/ 1) {
    				attr_dev(input, "type", /*inputtype*/ ctx[0]);
    			}

    			if (dirty & /*label*/ 2) {
    				attr_dev(input, "placeholder", /*label*/ ctx[1]);
    			}

    			if (dirty & /*baseClass*/ 32) {
    				attr_dev(input, "class", /*baseClass*/ ctx[5]);
    			}

    			if (dirty & /*size*/ 4 && div_class_value !== (div_class_value = `form-input-container flex border-radius padding-m--rl ${/*size*/ ctx[2]}`)) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			/*input_binding*/ ctx[9](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TextInput', slots, []);
    	let { inputtype = 'text' } = $$props;
    	let { label = undefined } = $$props;
    	let { className = undefined } = $$props;
    	let { size = "padding-m--tb" } = $$props;
    	let inputEl;
    	let inputLabelEl;
    	let baseClass = `form-input form-input--${inputtype} width-1of1`;
    	if (className) baseClass = `${className} ${baseClass}`;

    	/* focus effect on form elements */
    	onMount(() => {
    		inputEl.addEventListener('focus', () => {
    			inputEl.parentElement.setAttribute('data-focus', 'true');
    			const inputLabel = inputEl.previousElementSibling;
    			inputLabel.classList.remove('hidden');
    		});

    		inputEl.addEventListener('focusout', () => {
    			inputEl.parentElement.setAttribute('data-focus', 'false');

    			if (inputEl.value.length === 0) {
    				inputLabelEl.classList.add('hidden');
    			}
    		});
    	});

    	const writable_props = ['inputtype', 'label', 'className', 'size'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TextInput> was created with unknown prop '${key}'`);
    	});

    	function focus_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function span_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inputLabelEl = $$value;
    			$$invalidate(4, inputLabelEl);
    		});
    	}

    	function input_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inputEl = $$value;
    			$$invalidate(3, inputEl);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('inputtype' in $$props) $$invalidate(0, inputtype = $$props.inputtype);
    		if ('label' in $$props) $$invalidate(1, label = $$props.label);
    		if ('className' in $$props) $$invalidate(6, className = $$props.className);
    		if ('size' in $$props) $$invalidate(2, size = $$props.size);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		inputtype,
    		label,
    		className,
    		size,
    		inputEl,
    		inputLabelEl,
    		baseClass
    	});

    	$$self.$inject_state = $$props => {
    		if ('inputtype' in $$props) $$invalidate(0, inputtype = $$props.inputtype);
    		if ('label' in $$props) $$invalidate(1, label = $$props.label);
    		if ('className' in $$props) $$invalidate(6, className = $$props.className);
    		if ('size' in $$props) $$invalidate(2, size = $$props.size);
    		if ('inputEl' in $$props) $$invalidate(3, inputEl = $$props.inputEl);
    		if ('inputLabelEl' in $$props) $$invalidate(4, inputLabelEl = $$props.inputLabelEl);
    		if ('baseClass' in $$props) $$invalidate(5, baseClass = $$props.baseClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		inputtype,
    		label,
    		size,
    		inputEl,
    		inputLabelEl,
    		baseClass,
    		className,
    		focus_handler,
    		span_binding,
    		input_binding
    	];
    }

    class TextInput extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$8, create_fragment$9, safe_not_equal, {
    			inputtype: 0,
    			label: 1,
    			className: 6,
    			size: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TextInput",
    			options,
    			id: create_fragment$9.name
    		});
    	}

    	get inputtype() {
    		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputtype(value) {
    		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var TextInput$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': TextInput
    });

    /* node_modules/@ekstra-bladet/designsystem/dist/components/form-elements/TextArea.svelte generated by Svelte v3.46.4 */
    const file$7 = "node_modules/@ekstra-bladet/designsystem/dist/components/form-elements/TextArea.svelte";

    // (28:2) {#if label}
    function create_if_block$3(ctx) {
    	let span;
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text(/*label*/ ctx[0]);
    			t1 = text(":");
    			attr_dev(span, "class", "hidden");
    			add_location(span, file$7, 28, 4, 998);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			append_dev(span, t1);
    			/*span_binding*/ ctx[8](span);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*label*/ 1) set_data_dev(t0, /*label*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			/*span_binding*/ ctx[8](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(28:2) {#if label}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let div;
    	let t;
    	let textarea;
    	let div_class_value;
    	let mounted;
    	let dispose;
    	let if_block = /*label*/ ctx[0] && create_if_block$3(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			textarea = element("textarea");
    			attr_dev(textarea, "class", /*baseClass*/ ctx[4]);
    			attr_dev(textarea, "placeholder", /*label*/ ctx[0]);
    			add_location(textarea, file$7, 30, 2, 1073);
    			attr_dev(div, "class", div_class_value = `form-input-container flex flex--column border-radius padding-m--rl ${/*size*/ ctx[1]}`);
    			add_location(div, file$7, 26, 0, 889);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t);
    			append_dev(div, textarea);
    			/*textarea_binding*/ ctx[9](textarea);

    			if (!mounted) {
    				dispose = listen_dev(textarea, "focus", /*focus_handler*/ ctx[7], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*label*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$3(ctx);
    					if_block.c();
    					if_block.m(div, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*baseClass*/ 16) {
    				attr_dev(textarea, "class", /*baseClass*/ ctx[4]);
    			}

    			if (dirty & /*label*/ 1) {
    				attr_dev(textarea, "placeholder", /*label*/ ctx[0]);
    			}

    			if (dirty & /*size*/ 2 && div_class_value !== (div_class_value = `form-input-container flex flex--column border-radius padding-m--rl ${/*size*/ ctx[1]}`)) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			/*textarea_binding*/ ctx[9](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TextArea', slots, []);
    	let { inputtype = 'textarea' } = $$props;
    	let { label = undefined } = $$props;
    	let { className = undefined } = $$props;
    	let { size = "padding-m--tb" } = $$props;
    	let textareaEl;
    	let textareaLabelEl;
    	let baseClass = `form-input form-input--${inputtype} width-1of1`;
    	if (className) baseClass = `${className} ${baseClass}`;

    	/* focus effect on form elements */
    	onMount(() => {
    		textareaEl.addEventListener('focus', () => {
    			textareaEl.parentElement.setAttribute('data-focus', 'true');
    			const inputLabel = textareaEl.previousElementSibling;
    			inputLabel.classList.remove('hidden');
    		});

    		textareaEl.addEventListener('focusout', () => {
    			textareaEl.parentElement.setAttribute('data-focus', 'false');

    			if (textareaEl.value.length === 0) {
    				textareaLabelEl.classList.add('hidden');
    			}
    		});
    	});

    	const writable_props = ['inputtype', 'label', 'className', 'size'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TextArea> was created with unknown prop '${key}'`);
    	});

    	function focus_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function span_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			textareaLabelEl = $$value;
    			$$invalidate(3, textareaLabelEl);
    		});
    	}

    	function textarea_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			textareaEl = $$value;
    			$$invalidate(2, textareaEl);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('inputtype' in $$props) $$invalidate(5, inputtype = $$props.inputtype);
    		if ('label' in $$props) $$invalidate(0, label = $$props.label);
    		if ('className' in $$props) $$invalidate(6, className = $$props.className);
    		if ('size' in $$props) $$invalidate(1, size = $$props.size);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		inputtype,
    		label,
    		className,
    		size,
    		textareaEl,
    		textareaLabelEl,
    		baseClass
    	});

    	$$self.$inject_state = $$props => {
    		if ('inputtype' in $$props) $$invalidate(5, inputtype = $$props.inputtype);
    		if ('label' in $$props) $$invalidate(0, label = $$props.label);
    		if ('className' in $$props) $$invalidate(6, className = $$props.className);
    		if ('size' in $$props) $$invalidate(1, size = $$props.size);
    		if ('textareaEl' in $$props) $$invalidate(2, textareaEl = $$props.textareaEl);
    		if ('textareaLabelEl' in $$props) $$invalidate(3, textareaLabelEl = $$props.textareaLabelEl);
    		if ('baseClass' in $$props) $$invalidate(4, baseClass = $$props.baseClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		label,
    		size,
    		textareaEl,
    		textareaLabelEl,
    		baseClass,
    		inputtype,
    		className,
    		focus_handler,
    		span_binding,
    		textarea_binding
    	];
    }

    class TextArea extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$7, create_fragment$8, safe_not_equal, {
    			inputtype: 5,
    			label: 0,
    			className: 6,
    			size: 1
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TextArea",
    			options,
    			id: create_fragment$8.name
    		});
    	}

    	get inputtype() {
    		throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputtype(value) {
    		throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var TextArea$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': TextArea
    });

    /* node_modules/@ekstra-bladet/designsystem/dist/components/form-elements/FormElement.svelte generated by Svelte v3.46.4 */
    const file$6 = "node_modules/@ekstra-bladet/designsystem/dist/components/form-elements/FormElement.svelte";

    // (42:2) <svelte:component this={component} class={className} {size} {label} {inputtype} {group} {value} name={fieldName}>
    function create_default_slot(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[9],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(42:2) <svelte:component this={component} class={className} {size} {label} {inputtype} {group} {value} name={fieldName}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$7(ctx) {
    	let div;
    	let switch_instance;
    	let current;
    	var switch_value = /*component*/ ctx[7];

    	function switch_props(ctx) {
    		return {
    			props: {
    				class: /*className*/ ctx[1],
    				size: /*size*/ ctx[0],
    				label: /*label*/ ctx[5],
    				inputtype: /*inputtype*/ ctx[4],
    				group: /*group*/ ctx[3],
    				value: /*value*/ ctx[6],
    				name: /*fieldName*/ ctx[2],
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr_dev(div, "class", "form-element margin-l--b");
    			add_location(div, file$6, 40, 0, 905);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*className*/ 2) switch_instance_changes.class = /*className*/ ctx[1];
    			if (dirty & /*size*/ 1) switch_instance_changes.size = /*size*/ ctx[0];
    			if (dirty & /*label*/ 32) switch_instance_changes.label = /*label*/ ctx[5];
    			if (dirty & /*inputtype*/ 16) switch_instance_changes.inputtype = /*inputtype*/ ctx[4];
    			if (dirty & /*group*/ 8) switch_instance_changes.group = /*group*/ ctx[3];
    			if (dirty & /*value*/ 64) switch_instance_changes.value = /*value*/ ctx[6];
    			if (dirty & /*fieldName*/ 4) switch_instance_changes.name = /*fieldName*/ ctx[2];

    			if (dirty & /*$$scope*/ 512) {
    				switch_instance_changes.$$scope = { dirty, ctx };
    			}

    			if (switch_value !== (switch_value = /*component*/ ctx[7])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (switch_instance) destroy_component(switch_instance);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FormElement', slots, ['default']);
    	let { className = undefined } = $$props;
    	let { fieldName = undefined } = $$props;
    	let { group = undefined } = $$props;
    	let { inputtype = 'text' } = $$props;
    	let { label = undefined } = $$props;
    	let { value = '' } = $$props;
    	let { size = 'medium' } = $$props;
    	let component = TextInput;

    	switch (inputtype) {
    		case 'select':
    			component = Select;
    			break;
    		case 'checkbox':
    		case 'radio':
    			component = Checkbox;
    			break;
    		case 'textarea':
    			component = TextArea;
    			break;
    	}

    	switch (size) {
    		case 'small':
    			{
    				size = 'padding-s--tb';
    				break;
    			}
    		case 'medium':
    			{
    				size = 'padding-m--tb';
    				break;
    			}
    		case 'large':
    			{
    				size = 'padding-l--tb';
    				break;
    			}
    	}

    	const writable_props = ['className', 'fieldName', 'group', 'inputtype', 'label', 'value', 'size'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FormElement> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('className' in $$props) $$invalidate(1, className = $$props.className);
    		if ('fieldName' in $$props) $$invalidate(2, fieldName = $$props.fieldName);
    		if ('group' in $$props) $$invalidate(3, group = $$props.group);
    		if ('inputtype' in $$props) $$invalidate(4, inputtype = $$props.inputtype);
    		if ('label' in $$props) $$invalidate(5, label = $$props.label);
    		if ('value' in $$props) $$invalidate(6, value = $$props.value);
    		if ('size' in $$props) $$invalidate(0, size = $$props.size);
    		if ('$$scope' in $$props) $$invalidate(9, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Checkbox,
    		Select,
    		TextInput,
    		TextArea,
    		className,
    		fieldName,
    		group,
    		inputtype,
    		label,
    		value,
    		size,
    		component
    	});

    	$$self.$inject_state = $$props => {
    		if ('className' in $$props) $$invalidate(1, className = $$props.className);
    		if ('fieldName' in $$props) $$invalidate(2, fieldName = $$props.fieldName);
    		if ('group' in $$props) $$invalidate(3, group = $$props.group);
    		if ('inputtype' in $$props) $$invalidate(4, inputtype = $$props.inputtype);
    		if ('label' in $$props) $$invalidate(5, label = $$props.label);
    		if ('value' in $$props) $$invalidate(6, value = $$props.value);
    		if ('size' in $$props) $$invalidate(0, size = $$props.size);
    		if ('component' in $$props) $$invalidate(7, component = $$props.component);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		size,
    		className,
    		fieldName,
    		group,
    		inputtype,
    		label,
    		value,
    		component,
    		slots,
    		$$scope
    	];
    }

    class FormElement extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$6, create_fragment$7, safe_not_equal, {
    			className: 1,
    			fieldName: 2,
    			group: 3,
    			inputtype: 4,
    			label: 5,
    			value: 6,
    			size: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FormElement",
    			options,
    			id: create_fragment$7.name
    		});
    	}

    	get className() {
    		throw new Error("<FormElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<FormElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fieldName() {
    		throw new Error("<FormElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fieldName(value) {
    		throw new Error("<FormElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get group() {
    		throw new Error("<FormElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set group(value) {
    		throw new Error("<FormElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inputtype() {
    		throw new Error("<FormElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputtype(value) {
    		throw new Error("<FormElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<FormElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<FormElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<FormElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<FormElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<FormElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<FormElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var FormElement$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': FormElement
    });

    var require$$8 = /*@__PURE__*/getAugmentedNamespace(FormElement$1);

    var require$$9 = /*@__PURE__*/getAugmentedNamespace(HorizontalScroll$1);

    var require$$10 = /*@__PURE__*/getAugmentedNamespace(Icon$1);

    var require$$11 = /*@__PURE__*/getAugmentedNamespace(Select$1);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/spinner/Spinner.svelte generated by Svelte v3.46.4 */
    const file$5 = "node_modules/@ekstra-bladet/designsystem/dist/components/spinner/Spinner.svelte";

    // (5:0) {#if isLoading}
    function create_if_block$2(ctx) {
    	let div;
    	let icon0;
    	let t0;
    	let icon1;
    	let t1;
    	let icon2;
    	let current;

    	icon0 = new Icon({
    			props: {
    				className: "bounce bounce1",
    				name: "circlesolid",
    				style: "width: 18px; height: 18px;"
    			},
    			$$inline: true
    		});

    	icon1 = new Icon({
    			props: {
    				className: "bounce bounce2",
    				name: "circlesolid",
    				style: "width: 18px; height: 18px;"
    			},
    			$$inline: true
    		});

    	icon2 = new Icon({
    			props: {
    				className: "bounce bounce3",
    				name: "circlesolid",
    				style: "width: 18px; height: 18px;"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(icon0.$$.fragment);
    			t0 = space();
    			create_component(icon1.$$.fragment);
    			t1 = space();
    			create_component(icon2.$$.fragment);
    			attr_dev(div, "class", "loader flex flex--center");
    			add_location(div, file$5, 5, 2, 117);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(icon0, div, null);
    			append_dev(div, t0);
    			mount_component(icon1, div, null);
    			append_dev(div, t1);
    			mount_component(icon2, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon0.$$.fragment, local);
    			transition_in(icon1.$$.fragment, local);
    			transition_in(icon2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon0.$$.fragment, local);
    			transition_out(icon1.$$.fragment, local);
    			transition_out(icon2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(icon0);
    			destroy_component(icon1);
    			destroy_component(icon2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(5:0) {#if isLoading}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*isLoading*/ ctx[0] && create_if_block$2(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*isLoading*/ ctx[0]) {
    				if (if_block) {
    					if (dirty & /*isLoading*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$2(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Spinner', slots, []);
    	let { isLoading = false } = $$props;
    	const writable_props = ['isLoading'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Spinner> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('isLoading' in $$props) $$invalidate(0, isLoading = $$props.isLoading);
    	};

    	$$self.$capture_state = () => ({ Icon, isLoading });

    	$$self.$inject_state = $$props => {
    		if ('isLoading' in $$props) $$invalidate(0, isLoading = $$props.isLoading);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [isLoading];
    }

    class Spinner extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$6, safe_not_equal, { isLoading: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Spinner",
    			options,
    			id: create_fragment$6.name
    		});
    	}

    	get isLoading() {
    		throw new Error("<Spinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isLoading(value) {
    		throw new Error("<Spinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Spinner$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Spinner
    });

    var require$$12 = /*@__PURE__*/getAugmentedNamespace(Spinner$1);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/tabs/Tabs.svelte generated by Svelte v3.46.4 */
    const file$4 = "node_modules/@ekstra-bladet/designsystem/dist/components/tabs/Tabs.svelte";

    function create_fragment$5(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", /*className*/ ctx[0]);
    			add_location(div, file$4, 43, 0, 1412);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*className*/ 1) {
    				attr_dev(div, "class", /*className*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const BUTTONS = {};

    function instance$4($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Tabs', slots, ['default']);
    	const selectedId = writable(0);
    	const buttons = [];
    	const panels = [];
    	const selectedButton = writable(null);
    	const selectedPanel = writable(null);

    	selectedId.subscribe(i => {
    		selectedButton.set(buttons[i]);
    		selectedPanel.set(panels[i]);
    	});

    	setContext(BUTTONS, {
    		registerTab: button => {
    			buttons.push(button);
    			selectedButton.update(current => current || button);

    			onDestroy(() => {
    				const i = buttons.indexOf(button);
    				buttons.splice(i, 1);

    				selectedButton.update(current => current === button
    				? buttons[i] || buttons[buttons.length - 1]
    				: current);
    			});
    		},
    		registerPanel: panel => {
    			panels.push(panel);
    			selectedPanel.update(current => current || panel);

    			onDestroy(() => {
    				const i = panels.indexOf(panel);
    				panels.splice(i, 1);

    				selectedPanel.update(current => current === panel
    				? panels[i] || panels[panels.length - 1]
    				: current);
    			});
    		},
    		selectButton: button => {
    			const i = buttons.indexOf(button);
    			selectedId.set(i);
    		},
    		selectedButton,
    		selectedPanel
    	});

    	let { className = undefined } = $$props;
    	const writable_props = ['className'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Tabs> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('className' in $$props) $$invalidate(0, className = $$props.className);
    		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		BUTTONS,
    		setContext,
    		onDestroy,
    		SvelteComponent: SvelteComponentDev,
    		writable,
    		selectedId,
    		buttons,
    		panels,
    		selectedButton,
    		selectedPanel,
    		className
    	});

    	$$self.$inject_state = $$props => {
    		if ('className' in $$props) $$invalidate(0, className = $$props.className);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [className, selectedId, $$scope, slots];
    }

    class Tabs extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$5, safe_not_equal, { selectedId: 1, className: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tabs",
    			options,
    			id: create_fragment$5.name
    		});
    	}

    	get selectedId() {
    		return this.$$.ctx[1];
    	}

    	set selectedId(value) {
    		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Tabs$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Tabs,
        BUTTONS: BUTTONS
    });

    /* node_modules/@ekstra-bladet/designsystem/dist/components/tabs/Tab.svelte generated by Svelte v3.46.4 */
    const file$3 = "node_modules/@ekstra-bladet/designsystem/dist/components/tabs/Tab.svelte";

    function create_fragment$4(ctx) {
    	let button_1;
    	let button_1_data_selected_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[7].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

    	const block = {
    		c: function create() {
    			button_1 = element("button");
    			if (default_slot) default_slot.c();
    			attr_dev(button_1, "class", /*cssClass*/ ctx[0]);
    			attr_dev(button_1, "data-selected", button_1_data_selected_value = /*$selectedButton*/ ctx[1] === /*button*/ ctx[2]);
    			add_location(button_1, file$3, 10, 0, 349);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button_1, anchor);

    			if (default_slot) {
    				default_slot.m(button_1, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button_1, "click", stop_propagation(/*click_handler*/ ctx[8]), false, false, true);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*cssClass*/ 1) {
    				attr_dev(button_1, "class", /*cssClass*/ ctx[0]);
    			}

    			if (!current || dirty & /*$selectedButton*/ 2 && button_1_data_selected_value !== (button_1_data_selected_value = /*$selectedButton*/ ctx[1] === /*button*/ ctx[2])) {
    				attr_dev(button_1, "data-selected", button_1_data_selected_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button_1);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let cssClass;
    	let $selectedButton;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Tab', slots, ['default']);
    	const button = {};
    	const { registerTab, selectButton, selectedButton } = getContext(BUTTONS);
    	validate_store(selectedButton, 'selectedButton');
    	component_subscribe($$self, selectedButton, value => $$invalidate(1, $selectedButton = value));
    	registerTab(button);
    	let { className = undefined } = $$props;
    	let baseClass = `button`;
    	const writable_props = ['className'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Tab> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => selectButton(button);

    	$$self.$$set = $$props => {
    		if ('className' in $$props) $$invalidate(5, className = $$props.className);
    		if ('$$scope' in $$props) $$invalidate(6, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		BUTTONS,
    		button,
    		registerTab,
    		selectButton,
    		selectedButton,
    		className,
    		baseClass,
    		cssClass,
    		$selectedButton
    	});

    	$$self.$inject_state = $$props => {
    		if ('className' in $$props) $$invalidate(5, className = $$props.className);
    		if ('baseClass' in $$props) $$invalidate(10, baseClass = $$props.baseClass);
    		if ('cssClass' in $$props) $$invalidate(0, cssClass = $$props.cssClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className*/ 32) {
    			$$invalidate(0, cssClass = className ? `${baseClass} ${className}` : baseClass);
    		}
    	};

    	return [
    		cssClass,
    		$selectedButton,
    		button,
    		selectButton,
    		selectedButton,
    		className,
    		$$scope,
    		slots,
    		click_handler
    	];
    }

    class Tab extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$4, safe_not_equal, { className: 5 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tab",
    			options,
    			id: create_fragment$4.name
    		});
    	}

    	get className() {
    		throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Tab$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Tab
    });

    var require$$13 = /*@__PURE__*/getAugmentedNamespace(Tab$1);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/tabs/TabContent.svelte generated by Svelte v3.46.4 */

    // (8:0) {#if $selectedPanel === panel}
    function create_if_block$1(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[3],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(8:0) {#if $selectedPanel === panel}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$selectedPanel*/ ctx[0] === /*panel*/ ctx[1] && create_if_block$1(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$selectedPanel*/ ctx[0] === /*panel*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$selectedPanel*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$1(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let $selectedPanel;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TabContent', slots, ['default']);
    	const panel = {};
    	const { registerPanel, selectedPanel } = getContext(BUTTONS);
    	validate_store(selectedPanel, 'selectedPanel');
    	component_subscribe($$self, selectedPanel, value => $$invalidate(0, $selectedPanel = value));
    	registerPanel(panel);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TabContent> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		BUTTONS,
    		panel,
    		registerPanel,
    		selectedPanel,
    		$selectedPanel
    	});

    	return [$selectedPanel, panel, selectedPanel, $$scope, slots];
    }

    class TabContent extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$3, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TabContent",
    			options,
    			id: create_fragment$3.name
    		});
    	}
    }

    var TabContent$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': TabContent
    });

    var require$$14 = /*@__PURE__*/getAugmentedNamespace(TabContent$1);

    /* node_modules/@ekstra-bladet/designsystem/dist/components/tabs/TabList.svelte generated by Svelte v3.46.4 */

    const file$2 = "node_modules/@ekstra-bladet/designsystem/dist/components/tabs/TabList.svelte";

    function create_fragment$2(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", /*cssClass*/ ctx[0]);
    			add_location(div, file$2, 14, 0, 357);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*cssClass*/ 1) {
    				attr_dev(div, "class", /*cssClass*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let cssClass;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TabList', slots, ['default']);
    	let { type = 'tabs' } = $$props;
    	let { className = undefined } = $$props;
    	let baseClass = '';

    	switch (type) {
    		case 'tabs':
    			baseClass = 'tabs';
    			break;
    		case 'pillnavigation':
    			baseClass = 'pillnavigation toggle toggle--buttons';
    			break;
    	}

    	const writable_props = ['type', 'className'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TabList> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('type' in $$props) $$invalidate(1, type = $$props.type);
    		if ('className' in $$props) $$invalidate(2, className = $$props.className);
    		if ('$$scope' in $$props) $$invalidate(4, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ type, className, baseClass, cssClass });

    	$$self.$inject_state = $$props => {
    		if ('type' in $$props) $$invalidate(1, type = $$props.type);
    		if ('className' in $$props) $$invalidate(2, className = $$props.className);
    		if ('baseClass' in $$props) $$invalidate(3, baseClass = $$props.baseClass);
    		if ('cssClass' in $$props) $$invalidate(0, cssClass = $$props.cssClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, baseClass*/ 12) {
    			$$invalidate(0, cssClass = className ? `${baseClass} ${className}` : baseClass);
    		}
    	};

    	return [cssClass, type, className, baseClass, $$scope, slots];
    }

    class TabList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$2, safe_not_equal, { type: 1, className: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TabList",
    			options,
    			id: create_fragment$2.name
    		});
    	}

    	get type() {
    		throw new Error("<TabList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<TabList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<TabList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<TabList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var TabList$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': TabList
    });

    var require$$15 = /*@__PURE__*/getAugmentedNamespace(TabList$1);

    var require$$16 = /*@__PURE__*/getAugmentedNamespace(Tabs$1);

    var require$$17 = /*@__PURE__*/getAugmentedNamespace(TextArea$1);

    var require$$18 = /*@__PURE__*/getAugmentedNamespace(TextInput$1);

    var require$$19 = /*@__PURE__*/getAugmentedNamespace(Toggler$1);

    var tooltipAction = {};

    var tooltipRender$1 = {};

    var top = 'top';
    var bottom = 'bottom';
    var right = 'right';
    var left = 'left';
    var auto = 'auto';
    var basePlacements = [top, bottom, right, left];
    var start = 'start';
    var end = 'end';
    var clippingParents = 'clippingParents';
    var viewport = 'viewport';
    var popper = 'popper';
    var reference = 'reference';
    var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
      return acc.concat([placement + "-" + start, placement + "-" + end]);
    }, []);
    var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
      return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
    }, []); // modifiers that need to read the DOM

    var beforeRead = 'beforeRead';
    var read = 'read';
    var afterRead = 'afterRead'; // pure-logic modifiers

    var beforeMain = 'beforeMain';
    var main = 'main';
    var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

    var beforeWrite = 'beforeWrite';
    var write = 'write';
    var afterWrite = 'afterWrite';
    var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

    function getNodeName(element) {
      return element ? (element.nodeName || '').toLowerCase() : null;
    }

    function getWindow(node) {
      if (node == null) {
        return window;
      }

      if (node.toString() !== '[object Window]') {
        var ownerDocument = node.ownerDocument;
        return ownerDocument ? ownerDocument.defaultView || window : window;
      }

      return node;
    }

    function isElement$1(node) {
      var OwnElement = getWindow(node).Element;
      return node instanceof OwnElement || node instanceof Element;
    }

    function isHTMLElement(node) {
      var OwnElement = getWindow(node).HTMLElement;
      return node instanceof OwnElement || node instanceof HTMLElement;
    }

    function isShadowRoot(node) {
      // IE 11 has no ShadowRoot
      if (typeof ShadowRoot === 'undefined') {
        return false;
      }

      var OwnElement = getWindow(node).ShadowRoot;
      return node instanceof OwnElement || node instanceof ShadowRoot;
    }

    // and applies them to the HTMLElements such as popper and arrow

    function applyStyles(_ref) {
      var state = _ref.state;
      Object.keys(state.elements).forEach(function (name) {
        var style = state.styles[name] || {};
        var attributes = state.attributes[name] || {};
        var element = state.elements[name]; // arrow is optional + virtual elements

        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        } // Flow doesn't support to extend this property, but it's the most
        // effective way to apply styles to an HTMLElement
        // $FlowFixMe[cannot-write]


        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function (name) {
          var value = attributes[name];

          if (value === false) {
            element.removeAttribute(name);
          } else {
            element.setAttribute(name, value === true ? '' : value);
          }
        });
      });
    }

    function effect$2(_ref2) {
      var state = _ref2.state;
      var initialStyles = {
        popper: {
          position: state.options.strategy,
          left: '0',
          top: '0',
          margin: '0'
        },
        arrow: {
          position: 'absolute'
        },
        reference: {}
      };
      Object.assign(state.elements.popper.style, initialStyles.popper);
      state.styles = initialStyles;

      if (state.elements.arrow) {
        Object.assign(state.elements.arrow.style, initialStyles.arrow);
      }

      return function () {
        Object.keys(state.elements).forEach(function (name) {
          var element = state.elements[name];
          var attributes = state.attributes[name] || {};
          var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

          var style = styleProperties.reduce(function (style, property) {
            style[property] = '';
            return style;
          }, {}); // arrow is optional + virtual elements

          if (!isHTMLElement(element) || !getNodeName(element)) {
            return;
          }

          Object.assign(element.style, style);
          Object.keys(attributes).forEach(function (attribute) {
            element.removeAttribute(attribute);
          });
        });
      };
    } // eslint-disable-next-line import/no-unused-modules


    var applyStyles$1 = {
      name: 'applyStyles',
      enabled: true,
      phase: 'write',
      fn: applyStyles,
      effect: effect$2,
      requires: ['computeStyles']
    };

    function getBasePlacement$1(placement) {
      return placement.split('-')[0];
    }

    var max = Math.max;
    var min = Math.min;
    var round = Math.round;

    function getBoundingClientRect(element, includeScale) {
      if (includeScale === void 0) {
        includeScale = false;
      }

      var rect = element.getBoundingClientRect();
      var scaleX = 1;
      var scaleY = 1;

      if (isHTMLElement(element) && includeScale) {
        var offsetHeight = element.offsetHeight;
        var offsetWidth = element.offsetWidth; // Do not attempt to divide by 0, otherwise we get `Infinity` as scale
        // Fallback to 1 in case both values are `0`

        if (offsetWidth > 0) {
          scaleX = round(rect.width) / offsetWidth || 1;
        }

        if (offsetHeight > 0) {
          scaleY = round(rect.height) / offsetHeight || 1;
        }
      }

      return {
        width: rect.width / scaleX,
        height: rect.height / scaleY,
        top: rect.top / scaleY,
        right: rect.right / scaleX,
        bottom: rect.bottom / scaleY,
        left: rect.left / scaleX,
        x: rect.left / scaleX,
        y: rect.top / scaleY
      };
    }

    // means it doesn't take into account transforms.

    function getLayoutRect(element) {
      var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
      // Fixes https://github.com/popperjs/popper-core/issues/1223

      var width = element.offsetWidth;
      var height = element.offsetHeight;

      if (Math.abs(clientRect.width - width) <= 1) {
        width = clientRect.width;
      }

      if (Math.abs(clientRect.height - height) <= 1) {
        height = clientRect.height;
      }

      return {
        x: element.offsetLeft,
        y: element.offsetTop,
        width: width,
        height: height
      };
    }

    function contains(parent, child) {
      var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

      if (parent.contains(child)) {
        return true;
      } // then fallback to custom implementation with Shadow DOM support
      else if (rootNode && isShadowRoot(rootNode)) {
          var next = child;

          do {
            if (next && parent.isSameNode(next)) {
              return true;
            } // $FlowFixMe[prop-missing]: need a better way to handle this...


            next = next.parentNode || next.host;
          } while (next);
        } // Give up, the result is false


      return false;
    }

    function getComputedStyle$1(element) {
      return getWindow(element).getComputedStyle(element);
    }

    function isTableElement(element) {
      return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
    }

    function getDocumentElement(element) {
      // $FlowFixMe[incompatible-return]: assume body is always available
      return ((isElement$1(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
      element.document) || window.document).documentElement;
    }

    function getParentNode(element) {
      if (getNodeName(element) === 'html') {
        return element;
      }

      return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
        // $FlowFixMe[incompatible-return]
        // $FlowFixMe[prop-missing]
        element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
        element.parentNode || ( // DOM Element detected
        isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
        // $FlowFixMe[incompatible-call]: HTMLElement is a Node
        getDocumentElement(element) // fallback

      );
    }

    function getTrueOffsetParent(element) {
      if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
      getComputedStyle$1(element).position === 'fixed') {
        return null;
      }

      return element.offsetParent;
    } // `.offsetParent` reports `null` for fixed elements, while absolute elements
    // return the containing block


    function getContainingBlock(element) {
      var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') !== -1;
      var isIE = navigator.userAgent.indexOf('Trident') !== -1;

      if (isIE && isHTMLElement(element)) {
        // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
        var elementCss = getComputedStyle$1(element);

        if (elementCss.position === 'fixed') {
          return null;
        }
      }

      var currentNode = getParentNode(element);

      if (isShadowRoot(currentNode)) {
        currentNode = currentNode.host;
      }

      while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
        var css = getComputedStyle$1(currentNode); // This is non-exhaustive but covers the most common CSS properties that
        // create a containing block.
        // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

        if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
          return currentNode;
        } else {
          currentNode = currentNode.parentNode;
        }
      }

      return null;
    } // Gets the closest ancestor positioned element. Handles some edge cases,
    // such as table ancestors and cross browser bugs.


    function getOffsetParent(element) {
      var window = getWindow(element);
      var offsetParent = getTrueOffsetParent(element);

      while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {
        offsetParent = getTrueOffsetParent(offsetParent);
      }

      if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static')) {
        return window;
      }

      return offsetParent || getContainingBlock(element) || window;
    }

    function getMainAxisFromPlacement(placement) {
      return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
    }

    function within(min$1, value, max$1) {
      return max(min$1, min(value, max$1));
    }
    function withinMaxClamp(min, value, max) {
      var v = within(min, value, max);
      return v > max ? max : v;
    }

    function getFreshSideObject() {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    }

    function mergePaddingObject(paddingObject) {
      return Object.assign({}, getFreshSideObject(), paddingObject);
    }

    function expandToHashMap(value, keys) {
      return keys.reduce(function (hashMap, key) {
        hashMap[key] = value;
        return hashMap;
      }, {});
    }

    var toPaddingObject = function toPaddingObject(padding, state) {
      padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
        placement: state.placement
      })) : padding;
      return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
    };

    function arrow(_ref) {
      var _state$modifiersData$;

      var state = _ref.state,
          name = _ref.name,
          options = _ref.options;
      var arrowElement = state.elements.arrow;
      var popperOffsets = state.modifiersData.popperOffsets;
      var basePlacement = getBasePlacement$1(state.placement);
      var axis = getMainAxisFromPlacement(basePlacement);
      var isVertical = [left, right].indexOf(basePlacement) >= 0;
      var len = isVertical ? 'height' : 'width';

      if (!arrowElement || !popperOffsets) {
        return;
      }

      var paddingObject = toPaddingObject(options.padding, state);
      var arrowRect = getLayoutRect(arrowElement);
      var minProp = axis === 'y' ? top : left;
      var maxProp = axis === 'y' ? bottom : right;
      var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
      var startDiff = popperOffsets[axis] - state.rects.reference[axis];
      var arrowOffsetParent = getOffsetParent(arrowElement);
      var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
      var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
      // outside of the popper bounds

      var min = paddingObject[minProp];
      var max = clientSize - arrowRect[len] - paddingObject[maxProp];
      var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
      var offset = within(min, center, max); // Prevents breaking syntax highlighting...

      var axisProp = axis;
      state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
    }

    function effect$1(_ref2) {
      var state = _ref2.state,
          options = _ref2.options;
      var _options$element = options.element,
          arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

      if (arrowElement == null) {
        return;
      } // CSS selector


      if (typeof arrowElement === 'string') {
        arrowElement = state.elements.popper.querySelector(arrowElement);

        if (!arrowElement) {
          return;
        }
      }

      {
        if (!isHTMLElement(arrowElement)) {
          console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '));
        }
      }

      if (!contains(state.elements.popper, arrowElement)) {
        {
          console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', 'element.'].join(' '));
        }

        return;
      }

      state.elements.arrow = arrowElement;
    } // eslint-disable-next-line import/no-unused-modules


    var arrow$1 = {
      name: 'arrow',
      enabled: true,
      phase: 'main',
      fn: arrow,
      effect: effect$1,
      requires: ['popperOffsets'],
      requiresIfExists: ['preventOverflow']
    };

    function getVariation(placement) {
      return placement.split('-')[1];
    }

    var unsetSides = {
      top: 'auto',
      right: 'auto',
      bottom: 'auto',
      left: 'auto'
    }; // Round the offsets to the nearest suitable subpixel based on the DPR.
    // Zooming can change the DPR, but it seems to report a value that will
    // cleanly divide the values into the appropriate subpixels.

    function roundOffsetsByDPR(_ref) {
      var x = _ref.x,
          y = _ref.y;
      var win = window;
      var dpr = win.devicePixelRatio || 1;
      return {
        x: round(x * dpr) / dpr || 0,
        y: round(y * dpr) / dpr || 0
      };
    }

    function mapToStyles(_ref2) {
      var _Object$assign2;

      var popper = _ref2.popper,
          popperRect = _ref2.popperRect,
          placement = _ref2.placement,
          variation = _ref2.variation,
          offsets = _ref2.offsets,
          position = _ref2.position,
          gpuAcceleration = _ref2.gpuAcceleration,
          adaptive = _ref2.adaptive,
          roundOffsets = _ref2.roundOffsets,
          isFixed = _ref2.isFixed;
      var _offsets$x = offsets.x,
          x = _offsets$x === void 0 ? 0 : _offsets$x,
          _offsets$y = offsets.y,
          y = _offsets$y === void 0 ? 0 : _offsets$y;

      var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
        x: x,
        y: y
      }) : {
        x: x,
        y: y
      };

      x = _ref3.x;
      y = _ref3.y;
      var hasX = offsets.hasOwnProperty('x');
      var hasY = offsets.hasOwnProperty('y');
      var sideX = left;
      var sideY = top;
      var win = window;

      if (adaptive) {
        var offsetParent = getOffsetParent(popper);
        var heightProp = 'clientHeight';
        var widthProp = 'clientWidth';

        if (offsetParent === getWindow(popper)) {
          offsetParent = getDocumentElement(popper);

          if (getComputedStyle$1(offsetParent).position !== 'static' && position === 'absolute') {
            heightProp = 'scrollHeight';
            widthProp = 'scrollWidth';
          }
        } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


        offsetParent = offsetParent;

        if (placement === top || (placement === left || placement === right) && variation === end) {
          sideY = bottom;
          var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]
          offsetParent[heightProp];
          y -= offsetY - popperRect.height;
          y *= gpuAcceleration ? 1 : -1;
        }

        if (placement === left || (placement === top || placement === bottom) && variation === end) {
          sideX = right;
          var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]
          offsetParent[widthProp];
          x -= offsetX - popperRect.width;
          x *= gpuAcceleration ? 1 : -1;
        }
      }

      var commonStyles = Object.assign({
        position: position
      }, adaptive && unsetSides);

      var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
        x: x,
        y: y
      }) : {
        x: x,
        y: y
      };

      x = _ref4.x;
      y = _ref4.y;

      if (gpuAcceleration) {
        var _Object$assign;

        return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
      }

      return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
    }

    function computeStyles(_ref5) {
      var state = _ref5.state,
          options = _ref5.options;
      var _options$gpuAccelerat = options.gpuAcceleration,
          gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
          _options$adaptive = options.adaptive,
          adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
          _options$roundOffsets = options.roundOffsets,
          roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;

      {
        var transitionProperty = getComputedStyle$1(state.elements.popper).transitionProperty || '';

        if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(function (property) {
          return transitionProperty.indexOf(property) >= 0;
        })) {
          console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: "transform", "top", "right", "bottom", "left".', '\n\n', 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\n\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));
        }
      }

      var commonStyles = {
        placement: getBasePlacement$1(state.placement),
        variation: getVariation(state.placement),
        popper: state.elements.popper,
        popperRect: state.rects.popper,
        gpuAcceleration: gpuAcceleration,
        isFixed: state.options.strategy === 'fixed'
      };

      if (state.modifiersData.popperOffsets != null) {
        state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.popperOffsets,
          position: state.options.strategy,
          adaptive: adaptive,
          roundOffsets: roundOffsets
        })));
      }

      if (state.modifiersData.arrow != null) {
        state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.arrow,
          position: 'absolute',
          adaptive: false,
          roundOffsets: roundOffsets
        })));
      }

      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        'data-popper-placement': state.placement
      });
    } // eslint-disable-next-line import/no-unused-modules


    var computeStyles$1 = {
      name: 'computeStyles',
      enabled: true,
      phase: 'beforeWrite',
      fn: computeStyles,
      data: {}
    };

    var passive = {
      passive: true
    };

    function effect(_ref) {
      var state = _ref.state,
          instance = _ref.instance,
          options = _ref.options;
      var _options$scroll = options.scroll,
          scroll = _options$scroll === void 0 ? true : _options$scroll,
          _options$resize = options.resize,
          resize = _options$resize === void 0 ? true : _options$resize;
      var window = getWindow(state.elements.popper);
      var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

      if (scroll) {
        scrollParents.forEach(function (scrollParent) {
          scrollParent.addEventListener('scroll', instance.update, passive);
        });
      }

      if (resize) {
        window.addEventListener('resize', instance.update, passive);
      }

      return function () {
        if (scroll) {
          scrollParents.forEach(function (scrollParent) {
            scrollParent.removeEventListener('scroll', instance.update, passive);
          });
        }

        if (resize) {
          window.removeEventListener('resize', instance.update, passive);
        }
      };
    } // eslint-disable-next-line import/no-unused-modules


    var eventListeners = {
      name: 'eventListeners',
      enabled: true,
      phase: 'write',
      fn: function fn() {},
      effect: effect,
      data: {}
    };

    var hash$1 = {
      left: 'right',
      right: 'left',
      bottom: 'top',
      top: 'bottom'
    };
    function getOppositePlacement(placement) {
      return placement.replace(/left|right|bottom|top/g, function (matched) {
        return hash$1[matched];
      });
    }

    var hash = {
      start: 'end',
      end: 'start'
    };
    function getOppositeVariationPlacement(placement) {
      return placement.replace(/start|end/g, function (matched) {
        return hash[matched];
      });
    }

    function getWindowScroll(node) {
      var win = getWindow(node);
      var scrollLeft = win.pageXOffset;
      var scrollTop = win.pageYOffset;
      return {
        scrollLeft: scrollLeft,
        scrollTop: scrollTop
      };
    }

    function getWindowScrollBarX(element) {
      // If <html> has a CSS width greater than the viewport, then this will be
      // incorrect for RTL.
      // Popper 1 is broken in this case and never had a bug report so let's assume
      // it's not an issue. I don't think anyone ever specifies width on <html>
      // anyway.
      // Browsers where the left scrollbar doesn't cause an issue report `0` for
      // this (e.g. Edge 2019, IE11, Safari)
      return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
    }

    function getViewportRect(element) {
      var win = getWindow(element);
      var html = getDocumentElement(element);
      var visualViewport = win.visualViewport;
      var width = html.clientWidth;
      var height = html.clientHeight;
      var x = 0;
      var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper
      // can be obscured underneath it.
      // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even
      // if it isn't open, so if this isn't available, the popper will be detected
      // to overflow the bottom of the screen too early.

      if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)
        // In Chrome, it returns a value very close to 0 (+/-) but contains rounding
        // errors due to floating point numbers, so we need to check precision.
        // Safari returns a number <= 0, usually < -1 when pinch-zoomed
        // Feature detection fails in mobile emulation mode in Chrome.
        // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <
        // 0.001
        // Fallback here: "Not Safari" userAgent

        if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
          x = visualViewport.offsetLeft;
          y = visualViewport.offsetTop;
        }
      }

      return {
        width: width,
        height: height,
        x: x + getWindowScrollBarX(element),
        y: y
      };
    }

    // of the `<html>` and `<body>` rect bounds if horizontally scrollable

    function getDocumentRect(element) {
      var _element$ownerDocumen;

      var html = getDocumentElement(element);
      var winScroll = getWindowScroll(element);
      var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
      var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
      var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
      var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
      var y = -winScroll.scrollTop;

      if (getComputedStyle$1(body || html).direction === 'rtl') {
        x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
      }

      return {
        width: width,
        height: height,
        x: x,
        y: y
      };
    }

    function isScrollParent(element) {
      // Firefox wants us to check `-x` and `-y` variations as well
      var _getComputedStyle = getComputedStyle$1(element),
          overflow = _getComputedStyle.overflow,
          overflowX = _getComputedStyle.overflowX,
          overflowY = _getComputedStyle.overflowY;

      return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
    }

    function getScrollParent(node) {
      if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
        // $FlowFixMe[incompatible-return]: assume body is always available
        return node.ownerDocument.body;
      }

      if (isHTMLElement(node) && isScrollParent(node)) {
        return node;
      }

      return getScrollParent(getParentNode(node));
    }

    /*
    given a DOM element, return the list of all scroll parents, up the list of ancesors
    until we get to the top window object. This list is what we attach scroll listeners
    to, because if any of these parent elements scroll, we'll need to re-calculate the
    reference element's position.
    */

    function listScrollParents(element, list) {
      var _element$ownerDocumen;

      if (list === void 0) {
        list = [];
      }

      var scrollParent = getScrollParent(element);
      var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
      var win = getWindow(scrollParent);
      var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
      var updatedList = list.concat(target);
      return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      updatedList.concat(listScrollParents(getParentNode(target)));
    }

    function rectToClientRect(rect) {
      return Object.assign({}, rect, {
        left: rect.x,
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
      });
    }

    function getInnerBoundingClientRect(element) {
      var rect = getBoundingClientRect(element);
      rect.top = rect.top + element.clientTop;
      rect.left = rect.left + element.clientLeft;
      rect.bottom = rect.top + element.clientHeight;
      rect.right = rect.left + element.clientWidth;
      rect.width = element.clientWidth;
      rect.height = element.clientHeight;
      rect.x = rect.left;
      rect.y = rect.top;
      return rect;
    }

    function getClientRectFromMixedType(element, clippingParent) {
      return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isElement$1(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
    } // A "clipping parent" is an overflowable container with the characteristic of
    // clipping (or hiding) overflowing elements with a position different from
    // `initial`


    function getClippingParents(element) {
      var clippingParents = listScrollParents(getParentNode(element));
      var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle$1(element).position) >= 0;
      var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

      if (!isElement$1(clipperElement)) {
        return [];
      } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


      return clippingParents.filter(function (clippingParent) {
        return isElement$1(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
      });
    } // Gets the maximum area that the element is visible in due to any number of
    // clipping parents


    function getClippingRect(element, boundary, rootBoundary) {
      var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
      var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
      var firstClippingParent = clippingParents[0];
      var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
        var rect = getClientRectFromMixedType(element, clippingParent);
        accRect.top = max(rect.top, accRect.top);
        accRect.right = min(rect.right, accRect.right);
        accRect.bottom = min(rect.bottom, accRect.bottom);
        accRect.left = max(rect.left, accRect.left);
        return accRect;
      }, getClientRectFromMixedType(element, firstClippingParent));
      clippingRect.width = clippingRect.right - clippingRect.left;
      clippingRect.height = clippingRect.bottom - clippingRect.top;
      clippingRect.x = clippingRect.left;
      clippingRect.y = clippingRect.top;
      return clippingRect;
    }

    function computeOffsets(_ref) {
      var reference = _ref.reference,
          element = _ref.element,
          placement = _ref.placement;
      var basePlacement = placement ? getBasePlacement$1(placement) : null;
      var variation = placement ? getVariation(placement) : null;
      var commonX = reference.x + reference.width / 2 - element.width / 2;
      var commonY = reference.y + reference.height / 2 - element.height / 2;
      var offsets;

      switch (basePlacement) {
        case top:
          offsets = {
            x: commonX,
            y: reference.y - element.height
          };
          break;

        case bottom:
          offsets = {
            x: commonX,
            y: reference.y + reference.height
          };
          break;

        case right:
          offsets = {
            x: reference.x + reference.width,
            y: commonY
          };
          break;

        case left:
          offsets = {
            x: reference.x - element.width,
            y: commonY
          };
          break;

        default:
          offsets = {
            x: reference.x,
            y: reference.y
          };
      }

      var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

      if (mainAxis != null) {
        var len = mainAxis === 'y' ? 'height' : 'width';

        switch (variation) {
          case start:
            offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
            break;

          case end:
            offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
            break;
        }
      }

      return offsets;
    }

    function detectOverflow(state, options) {
      if (options === void 0) {
        options = {};
      }

      var _options = options,
          _options$placement = _options.placement,
          placement = _options$placement === void 0 ? state.placement : _options$placement,
          _options$boundary = _options.boundary,
          boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
          _options$rootBoundary = _options.rootBoundary,
          rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
          _options$elementConte = _options.elementContext,
          elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
          _options$altBoundary = _options.altBoundary,
          altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
          _options$padding = _options.padding,
          padding = _options$padding === void 0 ? 0 : _options$padding;
      var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
      var altContext = elementContext === popper ? reference : popper;
      var popperRect = state.rects.popper;
      var element = state.elements[altBoundary ? altContext : elementContext];
      var clippingClientRect = getClippingRect(isElement$1(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
      var referenceClientRect = getBoundingClientRect(state.elements.reference);
      var popperOffsets = computeOffsets({
        reference: referenceClientRect,
        element: popperRect,
        strategy: 'absolute',
        placement: placement
      });
      var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
      var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
      // 0 or negative = within the clipping rect

      var overflowOffsets = {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right
      };
      var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

      if (elementContext === popper && offsetData) {
        var offset = offsetData[placement];
        Object.keys(overflowOffsets).forEach(function (key) {
          var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
          var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
          overflowOffsets[key] += offset[axis] * multiply;
        });
      }

      return overflowOffsets;
    }

    function computeAutoPlacement(state, options) {
      if (options === void 0) {
        options = {};
      }

      var _options = options,
          placement = _options.placement,
          boundary = _options.boundary,
          rootBoundary = _options.rootBoundary,
          padding = _options.padding,
          flipVariations = _options.flipVariations,
          _options$allowedAutoP = _options.allowedAutoPlacements,
          allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
      var variation = getVariation(placement);
      var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
        return getVariation(placement) === variation;
      }) : basePlacements;
      var allowedPlacements = placements$1.filter(function (placement) {
        return allowedAutoPlacements.indexOf(placement) >= 0;
      });

      if (allowedPlacements.length === 0) {
        allowedPlacements = placements$1;

        {
          console.error(['Popper: The `allowedAutoPlacements` option did not allow any', 'placements. Ensure the `placement` option matches the variation', 'of the allowed placements.', 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(' '));
        }
      } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


      var overflows = allowedPlacements.reduce(function (acc, placement) {
        acc[placement] = detectOverflow(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          padding: padding
        })[getBasePlacement$1(placement)];
        return acc;
      }, {});
      return Object.keys(overflows).sort(function (a, b) {
        return overflows[a] - overflows[b];
      });
    }

    function getExpandedFallbackPlacements(placement) {
      if (getBasePlacement$1(placement) === auto) {
        return [];
      }

      var oppositePlacement = getOppositePlacement(placement);
      return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
    }

    function flip(_ref) {
      var state = _ref.state,
          options = _ref.options,
          name = _ref.name;

      if (state.modifiersData[name]._skip) {
        return;
      }

      var _options$mainAxis = options.mainAxis,
          checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
          _options$altAxis = options.altAxis,
          checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
          specifiedFallbackPlacements = options.fallbackPlacements,
          padding = options.padding,
          boundary = options.boundary,
          rootBoundary = options.rootBoundary,
          altBoundary = options.altBoundary,
          _options$flipVariatio = options.flipVariations,
          flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
          allowedAutoPlacements = options.allowedAutoPlacements;
      var preferredPlacement = state.options.placement;
      var basePlacement = getBasePlacement$1(preferredPlacement);
      var isBasePlacement = basePlacement === preferredPlacement;
      var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
      var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
        return acc.concat(getBasePlacement$1(placement) === auto ? computeAutoPlacement(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          padding: padding,
          flipVariations: flipVariations,
          allowedAutoPlacements: allowedAutoPlacements
        }) : placement);
      }, []);
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var checksMap = new Map();
      var makeFallbackChecks = true;
      var firstFittingPlacement = placements[0];

      for (var i = 0; i < placements.length; i++) {
        var placement = placements[i];

        var _basePlacement = getBasePlacement$1(placement);

        var isStartVariation = getVariation(placement) === start;
        var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
        var len = isVertical ? 'width' : 'height';
        var overflow = detectOverflow(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          altBoundary: altBoundary,
          padding: padding
        });
        var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;

        if (referenceRect[len] > popperRect[len]) {
          mainVariationSide = getOppositePlacement(mainVariationSide);
        }

        var altVariationSide = getOppositePlacement(mainVariationSide);
        var checks = [];

        if (checkMainAxis) {
          checks.push(overflow[_basePlacement] <= 0);
        }

        if (checkAltAxis) {
          checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
        }

        if (checks.every(function (check) {
          return check;
        })) {
          firstFittingPlacement = placement;
          makeFallbackChecks = false;
          break;
        }

        checksMap.set(placement, checks);
      }

      if (makeFallbackChecks) {
        // `2` may be desired in some cases – research later
        var numberOfChecks = flipVariations ? 3 : 1;

        var _loop = function _loop(_i) {
          var fittingPlacement = placements.find(function (placement) {
            var checks = checksMap.get(placement);

            if (checks) {
              return checks.slice(0, _i).every(function (check) {
                return check;
              });
            }
          });

          if (fittingPlacement) {
            firstFittingPlacement = fittingPlacement;
            return "break";
          }
        };

        for (var _i = numberOfChecks; _i > 0; _i--) {
          var _ret = _loop(_i);

          if (_ret === "break") break;
        }
      }

      if (state.placement !== firstFittingPlacement) {
        state.modifiersData[name]._skip = true;
        state.placement = firstFittingPlacement;
        state.reset = true;
      }
    } // eslint-disable-next-line import/no-unused-modules


    var flip$1 = {
      name: 'flip',
      enabled: true,
      phase: 'main',
      fn: flip,
      requiresIfExists: ['offset'],
      data: {
        _skip: false
      }
    };

    function getSideOffsets(overflow, rect, preventedOffsets) {
      if (preventedOffsets === void 0) {
        preventedOffsets = {
          x: 0,
          y: 0
        };
      }

      return {
        top: overflow.top - rect.height - preventedOffsets.y,
        right: overflow.right - rect.width + preventedOffsets.x,
        bottom: overflow.bottom - rect.height + preventedOffsets.y,
        left: overflow.left - rect.width - preventedOffsets.x
      };
    }

    function isAnySideFullyClipped(overflow) {
      return [top, right, bottom, left].some(function (side) {
        return overflow[side] >= 0;
      });
    }

    function hide(_ref) {
      var state = _ref.state,
          name = _ref.name;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var preventedOffsets = state.modifiersData.preventOverflow;
      var referenceOverflow = detectOverflow(state, {
        elementContext: 'reference'
      });
      var popperAltOverflow = detectOverflow(state, {
        altBoundary: true
      });
      var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
      var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
      var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
      var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
      state.modifiersData[name] = {
        referenceClippingOffsets: referenceClippingOffsets,
        popperEscapeOffsets: popperEscapeOffsets,
        isReferenceHidden: isReferenceHidden,
        hasPopperEscaped: hasPopperEscaped
      };
      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        'data-popper-reference-hidden': isReferenceHidden,
        'data-popper-escaped': hasPopperEscaped
      });
    } // eslint-disable-next-line import/no-unused-modules


    var hide$1 = {
      name: 'hide',
      enabled: true,
      phase: 'main',
      requiresIfExists: ['preventOverflow'],
      fn: hide
    };

    function distanceAndSkiddingToXY(placement, rects, offset) {
      var basePlacement = getBasePlacement$1(placement);
      var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;

      var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
        placement: placement
      })) : offset,
          skidding = _ref[0],
          distance = _ref[1];

      skidding = skidding || 0;
      distance = (distance || 0) * invertDistance;
      return [left, right].indexOf(basePlacement) >= 0 ? {
        x: distance,
        y: skidding
      } : {
        x: skidding,
        y: distance
      };
    }

    function offset(_ref2) {
      var state = _ref2.state,
          options = _ref2.options,
          name = _ref2.name;
      var _options$offset = options.offset,
          offset = _options$offset === void 0 ? [0, 0] : _options$offset;
      var data = placements.reduce(function (acc, placement) {
        acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
        return acc;
      }, {});
      var _data$state$placement = data[state.placement],
          x = _data$state$placement.x,
          y = _data$state$placement.y;

      if (state.modifiersData.popperOffsets != null) {
        state.modifiersData.popperOffsets.x += x;
        state.modifiersData.popperOffsets.y += y;
      }

      state.modifiersData[name] = data;
    } // eslint-disable-next-line import/no-unused-modules


    var offset$1 = {
      name: 'offset',
      enabled: true,
      phase: 'main',
      requires: ['popperOffsets'],
      fn: offset
    };

    function popperOffsets(_ref) {
      var state = _ref.state,
          name = _ref.name;
      // Offsets are the actual position the popper needs to have to be
      // properly positioned near its reference element
      // This is the most basic placement, and will be adjusted by
      // the modifiers in the next step
      state.modifiersData[name] = computeOffsets({
        reference: state.rects.reference,
        element: state.rects.popper,
        strategy: 'absolute',
        placement: state.placement
      });
    } // eslint-disable-next-line import/no-unused-modules


    var popperOffsets$1 = {
      name: 'popperOffsets',
      enabled: true,
      phase: 'read',
      fn: popperOffsets,
      data: {}
    };

    function getAltAxis(axis) {
      return axis === 'x' ? 'y' : 'x';
    }

    function preventOverflow(_ref) {
      var state = _ref.state,
          options = _ref.options,
          name = _ref.name;
      var _options$mainAxis = options.mainAxis,
          checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
          _options$altAxis = options.altAxis,
          checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
          boundary = options.boundary,
          rootBoundary = options.rootBoundary,
          altBoundary = options.altBoundary,
          padding = options.padding,
          _options$tether = options.tether,
          tether = _options$tether === void 0 ? true : _options$tether,
          _options$tetherOffset = options.tetherOffset,
          tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
      var overflow = detectOverflow(state, {
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding,
        altBoundary: altBoundary
      });
      var basePlacement = getBasePlacement$1(state.placement);
      var variation = getVariation(state.placement);
      var isBasePlacement = !variation;
      var mainAxis = getMainAxisFromPlacement(basePlacement);
      var altAxis = getAltAxis(mainAxis);
      var popperOffsets = state.modifiersData.popperOffsets;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
        placement: state.placement
      })) : tetherOffset;
      var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
        mainAxis: tetherOffsetValue,
        altAxis: tetherOffsetValue
      } : Object.assign({
        mainAxis: 0,
        altAxis: 0
      }, tetherOffsetValue);
      var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
      var data = {
        x: 0,
        y: 0
      };

      if (!popperOffsets) {
        return;
      }

      if (checkMainAxis) {
        var _offsetModifierState$;

        var mainSide = mainAxis === 'y' ? top : left;
        var altSide = mainAxis === 'y' ? bottom : right;
        var len = mainAxis === 'y' ? 'height' : 'width';
        var offset = popperOffsets[mainAxis];
        var min$1 = offset + overflow[mainSide];
        var max$1 = offset - overflow[altSide];
        var additive = tether ? -popperRect[len] / 2 : 0;
        var minLen = variation === start ? referenceRect[len] : popperRect[len];
        var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
        // outside the reference bounds

        var arrowElement = state.elements.arrow;
        var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
          width: 0,
          height: 0
        };
        var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
        var arrowPaddingMin = arrowPaddingObject[mainSide];
        var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
        // to include its full size in the calculation. If the reference is small
        // and near the edge of a boundary, the popper can overflow even if the
        // reference is not overflowing as well (e.g. virtual elements with no
        // width or height)

        var arrowLen = within(0, referenceRect[len], arrowRect[len]);
        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
        var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
        var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
        var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
        var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
        var tetherMax = offset + maxOffset - offsetModifierValue;
        var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
        popperOffsets[mainAxis] = preventedOffset;
        data[mainAxis] = preventedOffset - offset;
      }

      if (checkAltAxis) {
        var _offsetModifierState$2;

        var _mainSide = mainAxis === 'x' ? top : left;

        var _altSide = mainAxis === 'x' ? bottom : right;

        var _offset = popperOffsets[altAxis];

        var _len = altAxis === 'y' ? 'height' : 'width';

        var _min = _offset + overflow[_mainSide];

        var _max = _offset - overflow[_altSide];

        var isOriginSide = [top, left].indexOf(basePlacement) !== -1;

        var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;

        var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;

        var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;

        var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);

        popperOffsets[altAxis] = _preventedOffset;
        data[altAxis] = _preventedOffset - _offset;
      }

      state.modifiersData[name] = data;
    } // eslint-disable-next-line import/no-unused-modules


    var preventOverflow$1 = {
      name: 'preventOverflow',
      enabled: true,
      phase: 'main',
      fn: preventOverflow,
      requiresIfExists: ['offset']
    };

    function getHTMLElementScroll(element) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }

    function getNodeScroll(node) {
      if (node === getWindow(node) || !isHTMLElement(node)) {
        return getWindowScroll(node);
      } else {
        return getHTMLElementScroll(node);
      }
    }

    function isElementScaled(element) {
      var rect = element.getBoundingClientRect();
      var scaleX = round(rect.width) / element.offsetWidth || 1;
      var scaleY = round(rect.height) / element.offsetHeight || 1;
      return scaleX !== 1 || scaleY !== 1;
    } // Returns the composite rect of an element relative to its offsetParent.
    // Composite means it takes into account transforms as well as layout.


    function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
      if (isFixed === void 0) {
        isFixed = false;
      }

      var isOffsetParentAnElement = isHTMLElement(offsetParent);
      var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
      var documentElement = getDocumentElement(offsetParent);
      var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);
      var scroll = {
        scrollLeft: 0,
        scrollTop: 0
      };
      var offsets = {
        x: 0,
        y: 0
      };

      if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
        isScrollParent(documentElement)) {
          scroll = getNodeScroll(offsetParent);
        }

        if (isHTMLElement(offsetParent)) {
          offsets = getBoundingClientRect(offsetParent, true);
          offsets.x += offsetParent.clientLeft;
          offsets.y += offsetParent.clientTop;
        } else if (documentElement) {
          offsets.x = getWindowScrollBarX(documentElement);
        }
      }

      return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
      };
    }

    function order(modifiers) {
      var map = new Map();
      var visited = new Set();
      var result = [];
      modifiers.forEach(function (modifier) {
        map.set(modifier.name, modifier);
      }); // On visiting object, check for its dependencies and visit them recursively

      function sort(modifier) {
        visited.add(modifier.name);
        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
        requires.forEach(function (dep) {
          if (!visited.has(dep)) {
            var depModifier = map.get(dep);

            if (depModifier) {
              sort(depModifier);
            }
          }
        });
        result.push(modifier);
      }

      modifiers.forEach(function (modifier) {
        if (!visited.has(modifier.name)) {
          // check for visited object
          sort(modifier);
        }
      });
      return result;
    }

    function orderModifiers(modifiers) {
      // order based on dependencies
      var orderedModifiers = order(modifiers); // order based on phase

      return modifierPhases.reduce(function (acc, phase) {
        return acc.concat(orderedModifiers.filter(function (modifier) {
          return modifier.phase === phase;
        }));
      }, []);
    }

    function debounce$1(fn) {
      var pending;
      return function () {
        if (!pending) {
          pending = new Promise(function (resolve) {
            Promise.resolve().then(function () {
              pending = undefined;
              resolve(fn());
            });
          });
        }

        return pending;
      };
    }

    function format(str) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return [].concat(args).reduce(function (p, c) {
        return p.replace(/%s/, c);
      }, str);
    }

    var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
    var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
    var VALID_PROPERTIES = ['name', 'enabled', 'phase', 'fn', 'effect', 'requires', 'options'];
    function validateModifiers(modifiers) {
      modifiers.forEach(function (modifier) {
        [].concat(Object.keys(modifier), VALID_PROPERTIES) // IE11-compatible replacement for `new Set(iterable)`
        .filter(function (value, index, self) {
          return self.indexOf(value) === index;
        }).forEach(function (key) {
          switch (key) {
            case 'name':
              if (typeof modifier.name !== 'string') {
                console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', "\"" + String(modifier.name) + "\""));
              }

              break;

            case 'enabled':
              if (typeof modifier.enabled !== 'boolean') {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', "\"" + String(modifier.enabled) + "\""));
              }

              break;

            case 'phase':
              if (modifierPhases.indexOf(modifier.phase) < 0) {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(', '), "\"" + String(modifier.phase) + "\""));
              }

              break;

            case 'fn':
              if (typeof modifier.fn !== 'function') {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', "\"" + String(modifier.fn) + "\""));
              }

              break;

            case 'effect':
              if (modifier.effect != null && typeof modifier.effect !== 'function') {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', "\"" + String(modifier.fn) + "\""));
              }

              break;

            case 'requires':
              if (modifier.requires != null && !Array.isArray(modifier.requires)) {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', "\"" + String(modifier.requires) + "\""));
              }

              break;

            case 'requiresIfExists':
              if (!Array.isArray(modifier.requiresIfExists)) {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', "\"" + String(modifier.requiresIfExists) + "\""));
              }

              break;

            case 'options':
            case 'data':
              break;

            default:
              console.error("PopperJS: an invalid property has been provided to the \"" + modifier.name + "\" modifier, valid properties are " + VALID_PROPERTIES.map(function (s) {
                return "\"" + s + "\"";
              }).join(', ') + "; but \"" + key + "\" was provided.");
          }

          modifier.requires && modifier.requires.forEach(function (requirement) {
            if (modifiers.find(function (mod) {
              return mod.name === requirement;
            }) == null) {
              console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
            }
          });
        });
      });
    }

    function uniqueBy(arr, fn) {
      var identifiers = new Set();
      return arr.filter(function (item) {
        var identifier = fn(item);

        if (!identifiers.has(identifier)) {
          identifiers.add(identifier);
          return true;
        }
      });
    }

    function mergeByName(modifiers) {
      var merged = modifiers.reduce(function (merged, current) {
        var existing = merged[current.name];
        merged[current.name] = existing ? Object.assign({}, existing, current, {
          options: Object.assign({}, existing.options, current.options),
          data: Object.assign({}, existing.data, current.data)
        }) : current;
        return merged;
      }, {}); // IE11 does not support Object.values

      return Object.keys(merged).map(function (key) {
        return merged[key];
      });
    }

    var INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';
    var INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';
    var DEFAULT_OPTIONS = {
      placement: 'bottom',
      modifiers: [],
      strategy: 'absolute'
    };

    function areValidElements() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return !args.some(function (element) {
        return !(element && typeof element.getBoundingClientRect === 'function');
      });
    }

    function popperGenerator(generatorOptions) {
      if (generatorOptions === void 0) {
        generatorOptions = {};
      }

      var _generatorOptions = generatorOptions,
          _generatorOptions$def = _generatorOptions.defaultModifiers,
          defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
          _generatorOptions$def2 = _generatorOptions.defaultOptions,
          defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
      return function createPopper(reference, popper, options) {
        if (options === void 0) {
          options = defaultOptions;
        }

        var state = {
          placement: 'bottom',
          orderedModifiers: [],
          options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
          modifiersData: {},
          elements: {
            reference: reference,
            popper: popper
          },
          attributes: {},
          styles: {}
        };
        var effectCleanupFns = [];
        var isDestroyed = false;
        var instance = {
          state: state,
          setOptions: function setOptions(setOptionsAction) {
            var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
            cleanupModifierEffects();
            state.options = Object.assign({}, defaultOptions, state.options, options);
            state.scrollParents = {
              reference: isElement$1(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
              popper: listScrollParents(popper)
            }; // Orders the modifiers based on their dependencies and `phase`
            // properties

            var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

            state.orderedModifiers = orderedModifiers.filter(function (m) {
              return m.enabled;
            }); // Validate the provided modifiers so that the consumer will get warned
            // if one of the modifiers is invalid for any reason

            {
              var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function (_ref) {
                var name = _ref.name;
                return name;
              });
              validateModifiers(modifiers);

              if (getBasePlacement$1(state.options.placement) === auto) {
                var flipModifier = state.orderedModifiers.find(function (_ref2) {
                  var name = _ref2.name;
                  return name === 'flip';
                });

                if (!flipModifier) {
                  console.error(['Popper: "auto" placements require the "flip" modifier be', 'present and enabled to work.'].join(' '));
                }
              }

              var _getComputedStyle = getComputedStyle$1(popper),
                  marginTop = _getComputedStyle.marginTop,
                  marginRight = _getComputedStyle.marginRight,
                  marginBottom = _getComputedStyle.marginBottom,
                  marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can
              // cause bugs with positioning, so we'll warn the consumer


              if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {
                return parseFloat(margin);
              })) {
                console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));
              }
            }

            runModifierEffects();
            return instance.update();
          },
          // Sync update – it will always be executed, even if not necessary. This
          // is useful for low frequency updates where sync behavior simplifies the
          // logic.
          // For high frequency updates (e.g. `resize` and `scroll` events), always
          // prefer the async Popper#update method
          forceUpdate: function forceUpdate() {
            if (isDestroyed) {
              return;
            }

            var _state$elements = state.elements,
                reference = _state$elements.reference,
                popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
            // anymore

            if (!areValidElements(reference, popper)) {
              {
                console.error(INVALID_ELEMENT_ERROR);
              }

              return;
            } // Store the reference and popper rects to be read by modifiers


            state.rects = {
              reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
              popper: getLayoutRect(popper)
            }; // Modifiers have the ability to reset the current update cycle. The
            // most common use case for this is the `flip` modifier changing the
            // placement, which then needs to re-run all the modifiers, because the
            // logic was previously ran for the previous placement and is therefore
            // stale/incorrect

            state.reset = false;
            state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
            // is filled with the initial data specified by the modifier. This means
            // it doesn't persist and is fresh on each update.
            // To ensure persistent data, use `${name}#persistent`

            state.orderedModifiers.forEach(function (modifier) {
              return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
            });
            var __debug_loops__ = 0;

            for (var index = 0; index < state.orderedModifiers.length; index++) {
              {
                __debug_loops__ += 1;

                if (__debug_loops__ > 100) {
                  console.error(INFINITE_LOOP_ERROR);
                  break;
                }
              }

              if (state.reset === true) {
                state.reset = false;
                index = -1;
                continue;
              }

              var _state$orderedModifie = state.orderedModifiers[index],
                  fn = _state$orderedModifie.fn,
                  _state$orderedModifie2 = _state$orderedModifie.options,
                  _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
                  name = _state$orderedModifie.name;

              if (typeof fn === 'function') {
                state = fn({
                  state: state,
                  options: _options,
                  name: name,
                  instance: instance
                }) || state;
              }
            }
          },
          // Async and optimistically optimized update – it will not be executed if
          // not necessary (debounced to run at most once-per-tick)
          update: debounce$1(function () {
            return new Promise(function (resolve) {
              instance.forceUpdate();
              resolve(state);
            });
          }),
          destroy: function destroy() {
            cleanupModifierEffects();
            isDestroyed = true;
          }
        };

        if (!areValidElements(reference, popper)) {
          {
            console.error(INVALID_ELEMENT_ERROR);
          }

          return instance;
        }

        instance.setOptions(options).then(function (state) {
          if (!isDestroyed && options.onFirstUpdate) {
            options.onFirstUpdate(state);
          }
        }); // Modifiers have the ability to execute arbitrary code before the first
        // update cycle runs. They will be executed in the same order as the update
        // cycle. This is useful when a modifier adds some persistent data that
        // other modifiers need to use, but the modifier is run after the dependent
        // one.

        function runModifierEffects() {
          state.orderedModifiers.forEach(function (_ref3) {
            var name = _ref3.name,
                _ref3$options = _ref3.options,
                options = _ref3$options === void 0 ? {} : _ref3$options,
                effect = _ref3.effect;

            if (typeof effect === 'function') {
              var cleanupFn = effect({
                state: state,
                name: name,
                instance: instance,
                options: options
              });

              var noopFn = function noopFn() {};

              effectCleanupFns.push(cleanupFn || noopFn);
            }
          });
        }

        function cleanupModifierEffects() {
          effectCleanupFns.forEach(function (fn) {
            return fn();
          });
          effectCleanupFns = [];
        }

        return instance;
      };
    }

    var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
    var createPopper = /*#__PURE__*/popperGenerator({
      defaultModifiers: defaultModifiers
    }); // eslint-disable-next-line import/no-unused-modules

    /**!
    * tippy.js v6.3.7
    * (c) 2017-2021 atomiks
    * MIT License
    */

    var ROUND_ARROW = '<svg width="16" height="6" xmlns="http://www.w3.org/2000/svg"><path d="M0 6s1.796-.013 4.67-3.615C5.851.9 6.93.006 8 0c1.07-.006 2.148.887 3.343 2.385C14.233 6.005 16 6 16 6H0z"></svg>';
    var CONTENT_CLASS = "tippy-content";
    var BACKDROP_CLASS = "tippy-backdrop";
    var ARROW_CLASS = "tippy-arrow";
    var SVG_ARROW_CLASS = "tippy-svg-arrow";
    var TOUCH_OPTIONS = {
      passive: true,
      capture: true
    };
    var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO() {
      return document.body;
    };

    function hasOwnProperty(obj, key) {
      return {}.hasOwnProperty.call(obj, key);
    }
    function getValueAtIndexOrReturn(value, index, defaultValue) {
      if (Array.isArray(value)) {
        var v = value[index];
        return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;
      }

      return value;
    }
    function isType(value, type) {
      var str = {}.toString.call(value);
      return str.indexOf('[object') === 0 && str.indexOf(type + "]") > -1;
    }
    function invokeWithArgsOrReturn(value, args) {
      return typeof value === 'function' ? value.apply(void 0, args) : value;
    }
    function debounce(fn, ms) {
      // Avoid wrapping in `setTimeout` if ms is 0 anyway
      if (ms === 0) {
        return fn;
      }

      var timeout;
      return function (arg) {
        clearTimeout(timeout);
        timeout = setTimeout(function () {
          fn(arg);
        }, ms);
      };
    }
    function removeProperties(obj, keys) {
      var clone = Object.assign({}, obj);
      keys.forEach(function (key) {
        delete clone[key];
      });
      return clone;
    }
    function splitBySpaces(value) {
      return value.split(/\s+/).filter(Boolean);
    }
    function normalizeToArray(value) {
      return [].concat(value);
    }
    function pushIfUnique(arr, value) {
      if (arr.indexOf(value) === -1) {
        arr.push(value);
      }
    }
    function unique(arr) {
      return arr.filter(function (item, index) {
        return arr.indexOf(item) === index;
      });
    }
    function getBasePlacement(placement) {
      return placement.split('-')[0];
    }
    function arrayFrom(value) {
      return [].slice.call(value);
    }
    function removeUndefinedProps(obj) {
      return Object.keys(obj).reduce(function (acc, key) {
        if (obj[key] !== undefined) {
          acc[key] = obj[key];
        }

        return acc;
      }, {});
    }

    function div() {
      return document.createElement('div');
    }
    function isElement(value) {
      return ['Element', 'Fragment'].some(function (type) {
        return isType(value, type);
      });
    }
    function isNodeList(value) {
      return isType(value, 'NodeList');
    }
    function isMouseEvent(value) {
      return isType(value, 'MouseEvent');
    }
    function isReferenceElement(value) {
      return !!(value && value._tippy && value._tippy.reference === value);
    }
    function getArrayOfElements(value) {
      if (isElement(value)) {
        return [value];
      }

      if (isNodeList(value)) {
        return arrayFrom(value);
      }

      if (Array.isArray(value)) {
        return value;
      }

      return arrayFrom(document.querySelectorAll(value));
    }
    function setTransitionDuration(els, value) {
      els.forEach(function (el) {
        if (el) {
          el.style.transitionDuration = value + "ms";
        }
      });
    }
    function setVisibilityState(els, state) {
      els.forEach(function (el) {
        if (el) {
          el.setAttribute('data-state', state);
        }
      });
    }
    function getOwnerDocument(elementOrElements) {
      var _element$ownerDocumen;

      var _normalizeToArray = normalizeToArray(elementOrElements),
          element = _normalizeToArray[0]; // Elements created via a <template> have an ownerDocument with no reference to the body


      return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;
    }
    function isCursorOutsideInteractiveBorder(popperTreeData, event) {
      var clientX = event.clientX,
          clientY = event.clientY;
      return popperTreeData.every(function (_ref) {
        var popperRect = _ref.popperRect,
            popperState = _ref.popperState,
            props = _ref.props;
        var interactiveBorder = props.interactiveBorder;
        var basePlacement = getBasePlacement(popperState.placement);
        var offsetData = popperState.modifiersData.offset;

        if (!offsetData) {
          return true;
        }

        var topDistance = basePlacement === 'bottom' ? offsetData.top.y : 0;
        var bottomDistance = basePlacement === 'top' ? offsetData.bottom.y : 0;
        var leftDistance = basePlacement === 'right' ? offsetData.left.x : 0;
        var rightDistance = basePlacement === 'left' ? offsetData.right.x : 0;
        var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
        var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
        var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
        var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
        return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
      });
    }
    function updateTransitionEndListener(box, action, listener) {
      var method = action + "EventListener"; // some browsers apparently support `transition` (unprefixed) but only fire
      // `webkitTransitionEnd`...

      ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {
        box[method](event, listener);
      });
    }
    /**
     * Compared to xxx.contains, this function works for dom structures with shadow
     * dom
     */

    function actualContains(parent, child) {
      var target = child;

      while (target) {
        var _target$getRootNode;

        if (parent.contains(target)) {
          return true;
        }

        target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;
      }

      return false;
    }

    var currentInput = {
      isTouch: false
    };
    var lastMouseMoveTime = 0;
    /**
     * When a `touchstart` event is fired, it's assumed the user is using touch
     * input. We'll bind a `mousemove` event listener to listen for mouse input in
     * the future. This way, the `isTouch` property is fully dynamic and will handle
     * hybrid devices that use a mix of touch + mouse input.
     */

    function onDocumentTouchStart() {
      if (currentInput.isTouch) {
        return;
      }

      currentInput.isTouch = true;

      if (window.performance) {
        document.addEventListener('mousemove', onDocumentMouseMove);
      }
    }
    /**
     * When two `mousemove` event are fired consecutively within 20ms, it's assumed
     * the user is using mouse input again. `mousemove` can fire on touch devices as
     * well, but very rarely that quickly.
     */

    function onDocumentMouseMove() {
      var now = performance.now();

      if (now - lastMouseMoveTime < 20) {
        currentInput.isTouch = false;
        document.removeEventListener('mousemove', onDocumentMouseMove);
      }

      lastMouseMoveTime = now;
    }
    /**
     * When an element is in focus and has a tippy, leaving the tab/window and
     * returning causes it to show again. For mouse users this is unexpected, but
     * for keyboard use it makes sense.
     * TODO: find a better technique to solve this problem
     */

    function onWindowBlur() {
      var activeElement = document.activeElement;

      if (isReferenceElement(activeElement)) {
        var instance = activeElement._tippy;

        if (activeElement.blur && !instance.state.isVisible) {
          activeElement.blur();
        }
      }
    }
    function bindGlobalEventListeners() {
      document.addEventListener('touchstart', onDocumentTouchStart, TOUCH_OPTIONS);
      window.addEventListener('blur', onWindowBlur);
    }

    var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
    var isIE11 = isBrowser ? // @ts-ignore
    !!window.msCrypto : false;

    function createMemoryLeakWarning(method) {
      var txt = method === 'destroy' ? 'n already-' : ' ';
      return [method + "() was called on a" + txt + "destroyed instance. This is a no-op but", 'indicates a potential memory leak.'].join(' ');
    }
    function clean(value) {
      var spacesAndTabs = /[ \t]{2,}/g;
      var lineStartWithSpaces = /^[ \t]*/gm;
      return value.replace(spacesAndTabs, ' ').replace(lineStartWithSpaces, '').trim();
    }

    function getDevMessage(message) {
      return clean("\n  %ctippy.js\n\n  %c" + clean(message) + "\n\n  %c\uD83D\uDC77\u200D This is a development-only message. It will be removed in production.\n  ");
    }

    function getFormattedMessage(message) {
      return [getDevMessage(message), // title
      'color: #00C584; font-size: 1.3em; font-weight: bold;', // message
      'line-height: 1.5', // footer
      'color: #a6a095;'];
    } // Assume warnings and errors never have the same message

    var visitedMessages;

    {
      resetVisitedMessages();
    }

    function resetVisitedMessages() {
      visitedMessages = new Set();
    }
    function warnWhen(condition, message) {
      if (condition && !visitedMessages.has(message)) {
        var _console;

        visitedMessages.add(message);

        (_console = console).warn.apply(_console, getFormattedMessage(message));
      }
    }
    function errorWhen(condition, message) {
      if (condition && !visitedMessages.has(message)) {
        var _console2;

        visitedMessages.add(message);

        (_console2 = console).error.apply(_console2, getFormattedMessage(message));
      }
    }
    function validateTargets(targets) {
      var didPassFalsyValue = !targets;
      var didPassPlainObject = Object.prototype.toString.call(targets) === '[object Object]' && !targets.addEventListener;
      errorWhen(didPassFalsyValue, ['tippy() was passed', '`' + String(targets) + '`', 'as its targets (first) argument. Valid types are: String, Element,', 'Element[], or NodeList.'].join(' '));
      errorWhen(didPassPlainObject, ['tippy() was passed a plain object which is not supported as an argument', 'for virtual positioning. Use props.getReferenceClientRect instead.'].join(' '));
    }

    var pluginProps = {
      animateFill: false,
      followCursor: false,
      inlinePositioning: false,
      sticky: false
    };
    var renderProps = {
      allowHTML: false,
      animation: 'fade',
      arrow: true,
      content: '',
      inertia: false,
      maxWidth: 350,
      role: 'tooltip',
      theme: '',
      zIndex: 9999
    };
    var defaultProps = Object.assign({
      appendTo: TIPPY_DEFAULT_APPEND_TO,
      aria: {
        content: 'auto',
        expanded: 'auto'
      },
      delay: 0,
      duration: [300, 250],
      getReferenceClientRect: null,
      hideOnClick: true,
      ignoreAttributes: false,
      interactive: false,
      interactiveBorder: 2,
      interactiveDebounce: 0,
      moveTransition: '',
      offset: [0, 10],
      onAfterUpdate: function onAfterUpdate() {},
      onBeforeUpdate: function onBeforeUpdate() {},
      onCreate: function onCreate() {},
      onDestroy: function onDestroy() {},
      onHidden: function onHidden() {},
      onHide: function onHide() {},
      onMount: function onMount() {},
      onShow: function onShow() {},
      onShown: function onShown() {},
      onTrigger: function onTrigger() {},
      onUntrigger: function onUntrigger() {},
      onClickOutside: function onClickOutside() {},
      placement: 'top',
      plugins: [],
      popperOptions: {},
      render: null,
      showOnCreate: false,
      touch: true,
      trigger: 'mouseenter focus',
      triggerTarget: null
    }, pluginProps, renderProps);
    var defaultKeys = Object.keys(defaultProps);
    var setDefaultProps = function setDefaultProps(partialProps) {
      /* istanbul ignore else */
      {
        validateProps(partialProps, []);
      }

      var keys = Object.keys(partialProps);
      keys.forEach(function (key) {
        defaultProps[key] = partialProps[key];
      });
    };
    function getExtendedPassedProps(passedProps) {
      var plugins = passedProps.plugins || [];
      var pluginProps = plugins.reduce(function (acc, plugin) {
        var name = plugin.name,
            defaultValue = plugin.defaultValue;

        if (name) {
          var _name;

          acc[name] = passedProps[name] !== undefined ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;
        }

        return acc;
      }, {});
      return Object.assign({}, passedProps, pluginProps);
    }
    function getDataAttributeProps(reference, plugins) {
      var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
        plugins: plugins
      }))) : defaultKeys;
      var props = propKeys.reduce(function (acc, key) {
        var valueAsString = (reference.getAttribute("data-tippy-" + key) || '').trim();

        if (!valueAsString) {
          return acc;
        }

        if (key === 'content') {
          acc[key] = valueAsString;
        } else {
          try {
            acc[key] = JSON.parse(valueAsString);
          } catch (e) {
            acc[key] = valueAsString;
          }
        }

        return acc;
      }, {});
      return props;
    }
    function evaluateProps(reference, props) {
      var out = Object.assign({}, props, {
        content: invokeWithArgsOrReturn(props.content, [reference])
      }, props.ignoreAttributes ? {} : getDataAttributeProps(reference, props.plugins));
      out.aria = Object.assign({}, defaultProps.aria, out.aria);
      out.aria = {
        expanded: out.aria.expanded === 'auto' ? props.interactive : out.aria.expanded,
        content: out.aria.content === 'auto' ? props.interactive ? null : 'describedby' : out.aria.content
      };
      return out;
    }
    function validateProps(partialProps, plugins) {
      if (partialProps === void 0) {
        partialProps = {};
      }

      if (plugins === void 0) {
        plugins = [];
      }

      var keys = Object.keys(partialProps);
      keys.forEach(function (prop) {
        var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));
        var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop); // Check if the prop exists in `plugins`

        if (didPassUnknownProp) {
          didPassUnknownProp = plugins.filter(function (plugin) {
            return plugin.name === prop;
          }).length === 0;
        }

        warnWhen(didPassUnknownProp, ["`" + prop + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", 'a plugin, forgot to pass it in an array as props.plugins.', '\n\n', 'All props: https://atomiks.github.io/tippyjs/v6/all-props/\n', 'Plugins: https://atomiks.github.io/tippyjs/v6/plugins/'].join(' '));
      });
    }

    function getChildren(popper) {
      var box = popper.firstElementChild;
      var boxChildren = arrayFrom(box.children);
      return {
        box: box,
        content: boxChildren.find(function (node) {
          return node.classList.contains(CONTENT_CLASS);
        }),
        arrow: boxChildren.find(function (node) {
          return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
        }),
        backdrop: boxChildren.find(function (node) {
          return node.classList.contains(BACKDROP_CLASS);
        })
      };
    }

    var idCounter = 1;
    var mouseMoveListeners = []; // Used by `hideAll()`

    var mountedInstances = [];
    function createTippy(reference, passedProps) {
      var props = evaluateProps(reference, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps)))); // ===========================================================================
      // 🔒 Private members
      // ===========================================================================

      var showTimeout;
      var hideTimeout;
      var scheduleHideAnimationFrame;
      var isVisibleFromClick = false;
      var didHideDueToDocumentMouseDown = false;
      var didTouchMove = false;
      var ignoreOnFirstUpdate = false;
      var lastTriggerEvent;
      var currentTransitionEndListener;
      var onFirstUpdate;
      var listeners = [];
      var debouncedOnMouseMove = debounce(onMouseMove, props.interactiveDebounce);
      var currentTarget; // ===========================================================================
      // 🔑 Public members
      // ===========================================================================

      var id = idCounter++;
      var popperInstance = null;
      var plugins = unique(props.plugins);
      var state = {
        // Is the instance currently enabled?
        isEnabled: true,
        // Is the tippy currently showing and not transitioning out?
        isVisible: false,
        // Has the instance been destroyed?
        isDestroyed: false,
        // Is the tippy currently mounted to the DOM?
        isMounted: false,
        // Has the tippy finished transitioning in?
        isShown: false
      };
      var instance = {
        // properties
        id: id,
        reference: reference,
        popper: div(),
        popperInstance: popperInstance,
        props: props,
        state: state,
        plugins: plugins,
        // methods
        clearDelayTimeouts: clearDelayTimeouts,
        setProps: setProps,
        setContent: setContent,
        show: show,
        hide: hide,
        hideWithInteractivity: hideWithInteractivity,
        enable: enable,
        disable: disable,
        unmount: unmount,
        destroy: destroy
      }; // TODO: Investigate why this early return causes a TDZ error in the tests —
      // it doesn't seem to happen in the browser

      /* istanbul ignore if */

      if (!props.render) {
        {
          errorWhen(true, 'render() function has not been supplied.');
        }

        return instance;
      } // ===========================================================================
      // Initial mutations
      // ===========================================================================


      var _props$render = props.render(instance),
          popper = _props$render.popper,
          onUpdate = _props$render.onUpdate;

      popper.setAttribute('data-tippy-root', '');
      popper.id = "tippy-" + instance.id;
      instance.popper = popper;
      reference._tippy = instance;
      popper._tippy = instance;
      var pluginsHooks = plugins.map(function (plugin) {
        return plugin.fn(instance);
      });
      var hasAriaExpanded = reference.hasAttribute('aria-expanded');
      addListeners();
      handleAriaExpandedAttribute();
      handleStyles();
      invokeHook('onCreate', [instance]);

      if (props.showOnCreate) {
        scheduleShow();
      } // Prevent a tippy with a delay from hiding if the cursor left then returned
      // before it started hiding


      popper.addEventListener('mouseenter', function () {
        if (instance.props.interactive && instance.state.isVisible) {
          instance.clearDelayTimeouts();
        }
      });
      popper.addEventListener('mouseleave', function () {
        if (instance.props.interactive && instance.props.trigger.indexOf('mouseenter') >= 0) {
          getDocument().addEventListener('mousemove', debouncedOnMouseMove);
        }
      });
      return instance; // ===========================================================================
      // 🔒 Private methods
      // ===========================================================================

      function getNormalizedTouchSettings() {
        var touch = instance.props.touch;
        return Array.isArray(touch) ? touch : [touch, 0];
      }

      function getIsCustomTouchBehavior() {
        return getNormalizedTouchSettings()[0] === 'hold';
      }

      function getIsDefaultRenderFn() {
        var _instance$props$rende;

        // @ts-ignore
        return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);
      }

      function getCurrentTarget() {
        return currentTarget || reference;
      }

      function getDocument() {
        var parent = getCurrentTarget().parentNode;
        return parent ? getOwnerDocument(parent) : document;
      }

      function getDefaultTemplateChildren() {
        return getChildren(popper);
      }

      function getDelay(isShow) {
        // For touch or keyboard input, force `0` delay for UX reasons
        // Also if the instance is mounted but not visible (transitioning out),
        // ignore delay
        if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === 'focus') {
          return 0;
        }

        return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
      }

      function handleStyles(fromHide) {
        if (fromHide === void 0) {
          fromHide = false;
        }

        popper.style.pointerEvents = instance.props.interactive && !fromHide ? '' : 'none';
        popper.style.zIndex = "" + instance.props.zIndex;
      }

      function invokeHook(hook, args, shouldInvokePropsHook) {
        if (shouldInvokePropsHook === void 0) {
          shouldInvokePropsHook = true;
        }

        pluginsHooks.forEach(function (pluginHooks) {
          if (pluginHooks[hook]) {
            pluginHooks[hook].apply(pluginHooks, args);
          }
        });

        if (shouldInvokePropsHook) {
          var _instance$props;

          (_instance$props = instance.props)[hook].apply(_instance$props, args);
        }
      }

      function handleAriaContentAttribute() {
        var aria = instance.props.aria;

        if (!aria.content) {
          return;
        }

        var attr = "aria-" + aria.content;
        var id = popper.id;
        var nodes = normalizeToArray(instance.props.triggerTarget || reference);
        nodes.forEach(function (node) {
          var currentValue = node.getAttribute(attr);

          if (instance.state.isVisible) {
            node.setAttribute(attr, currentValue ? currentValue + " " + id : id);
          } else {
            var nextValue = currentValue && currentValue.replace(id, '').trim();

            if (nextValue) {
              node.setAttribute(attr, nextValue);
            } else {
              node.removeAttribute(attr);
            }
          }
        });
      }

      function handleAriaExpandedAttribute() {
        if (hasAriaExpanded || !instance.props.aria.expanded) {
          return;
        }

        var nodes = normalizeToArray(instance.props.triggerTarget || reference);
        nodes.forEach(function (node) {
          if (instance.props.interactive) {
            node.setAttribute('aria-expanded', instance.state.isVisible && node === getCurrentTarget() ? 'true' : 'false');
          } else {
            node.removeAttribute('aria-expanded');
          }
        });
      }

      function cleanupInteractiveMouseListeners() {
        getDocument().removeEventListener('mousemove', debouncedOnMouseMove);
        mouseMoveListeners = mouseMoveListeners.filter(function (listener) {
          return listener !== debouncedOnMouseMove;
        });
      }

      function onDocumentPress(event) {
        // Moved finger to scroll instead of an intentional tap outside
        if (currentInput.isTouch) {
          if (didTouchMove || event.type === 'mousedown') {
            return;
          }
        }

        var actualTarget = event.composedPath && event.composedPath()[0] || event.target; // Clicked on interactive popper

        if (instance.props.interactive && actualContains(popper, actualTarget)) {
          return;
        } // Clicked on the event listeners target


        if (normalizeToArray(instance.props.triggerTarget || reference).some(function (el) {
          return actualContains(el, actualTarget);
        })) {
          if (currentInput.isTouch) {
            return;
          }

          if (instance.state.isVisible && instance.props.trigger.indexOf('click') >= 0) {
            return;
          }
        } else {
          invokeHook('onClickOutside', [instance, event]);
        }

        if (instance.props.hideOnClick === true) {
          instance.clearDelayTimeouts();
          instance.hide(); // `mousedown` event is fired right before `focus` if pressing the
          // currentTarget. This lets a tippy with `focus` trigger know that it
          // should not show

          didHideDueToDocumentMouseDown = true;
          setTimeout(function () {
            didHideDueToDocumentMouseDown = false;
          }); // The listener gets added in `scheduleShow()`, but this may be hiding it
          // before it shows, and hide()'s early bail-out behavior can prevent it
          // from being cleaned up

          if (!instance.state.isMounted) {
            removeDocumentPress();
          }
        }
      }

      function onTouchMove() {
        didTouchMove = true;
      }

      function onTouchStart() {
        didTouchMove = false;
      }

      function addDocumentPress() {
        var doc = getDocument();
        doc.addEventListener('mousedown', onDocumentPress, true);
        doc.addEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
        doc.addEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
        doc.addEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
      }

      function removeDocumentPress() {
        var doc = getDocument();
        doc.removeEventListener('mousedown', onDocumentPress, true);
        doc.removeEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
        doc.removeEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
        doc.removeEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
      }

      function onTransitionedOut(duration, callback) {
        onTransitionEnd(duration, function () {
          if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {
            callback();
          }
        });
      }

      function onTransitionedIn(duration, callback) {
        onTransitionEnd(duration, callback);
      }

      function onTransitionEnd(duration, callback) {
        var box = getDefaultTemplateChildren().box;

        function listener(event) {
          if (event.target === box) {
            updateTransitionEndListener(box, 'remove', listener);
            callback();
          }
        } // Make callback synchronous if duration is 0
        // `transitionend` won't fire otherwise


        if (duration === 0) {
          return callback();
        }

        updateTransitionEndListener(box, 'remove', currentTransitionEndListener);
        updateTransitionEndListener(box, 'add', listener);
        currentTransitionEndListener = listener;
      }

      function on(eventType, handler, options) {
        if (options === void 0) {
          options = false;
        }

        var nodes = normalizeToArray(instance.props.triggerTarget || reference);
        nodes.forEach(function (node) {
          node.addEventListener(eventType, handler, options);
          listeners.push({
            node: node,
            eventType: eventType,
            handler: handler,
            options: options
          });
        });
      }

      function addListeners() {
        if (getIsCustomTouchBehavior()) {
          on('touchstart', onTrigger, {
            passive: true
          });
          on('touchend', onMouseLeave, {
            passive: true
          });
        }

        splitBySpaces(instance.props.trigger).forEach(function (eventType) {
          if (eventType === 'manual') {
            return;
          }

          on(eventType, onTrigger);

          switch (eventType) {
            case 'mouseenter':
              on('mouseleave', onMouseLeave);
              break;

            case 'focus':
              on(isIE11 ? 'focusout' : 'blur', onBlurOrFocusOut);
              break;

            case 'focusin':
              on('focusout', onBlurOrFocusOut);
              break;
          }
        });
      }

      function removeListeners() {
        listeners.forEach(function (_ref) {
          var node = _ref.node,
              eventType = _ref.eventType,
              handler = _ref.handler,
              options = _ref.options;
          node.removeEventListener(eventType, handler, options);
        });
        listeners = [];
      }

      function onTrigger(event) {
        var _lastTriggerEvent;

        var shouldScheduleClickHide = false;

        if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
          return;
        }

        var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === 'focus';
        lastTriggerEvent = event;
        currentTarget = event.currentTarget;
        handleAriaExpandedAttribute();

        if (!instance.state.isVisible && isMouseEvent(event)) {
          // If scrolling, `mouseenter` events can be fired if the cursor lands
          // over a new target, but `mousemove` events don't get fired. This
          // causes interactive tooltips to get stuck open until the cursor is
          // moved
          mouseMoveListeners.forEach(function (listener) {
            return listener(event);
          });
        } // Toggle show/hide when clicking click-triggered tooltips


        if (event.type === 'click' && (instance.props.trigger.indexOf('mouseenter') < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
          shouldScheduleClickHide = true;
        } else {
          scheduleShow(event);
        }

        if (event.type === 'click') {
          isVisibleFromClick = !shouldScheduleClickHide;
        }

        if (shouldScheduleClickHide && !wasFocused) {
          scheduleHide(event);
        }
      }

      function onMouseMove(event) {
        var target = event.target;
        var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper.contains(target);

        if (event.type === 'mousemove' && isCursorOverReferenceOrPopper) {
          return;
        }

        var popperTreeData = getNestedPopperTree().concat(popper).map(function (popper) {
          var _instance$popperInsta;

          var instance = popper._tippy;
          var state = (_instance$popperInsta = instance.popperInstance) == null ? void 0 : _instance$popperInsta.state;

          if (state) {
            return {
              popperRect: popper.getBoundingClientRect(),
              popperState: state,
              props: props
            };
          }

          return null;
        }).filter(Boolean);

        if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
          cleanupInteractiveMouseListeners();
          scheduleHide(event);
        }
      }

      function onMouseLeave(event) {
        var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf('click') >= 0 && isVisibleFromClick;

        if (shouldBail) {
          return;
        }

        if (instance.props.interactive) {
          instance.hideWithInteractivity(event);
          return;
        }

        scheduleHide(event);
      }

      function onBlurOrFocusOut(event) {
        if (instance.props.trigger.indexOf('focusin') < 0 && event.target !== getCurrentTarget()) {
          return;
        } // If focus was moved to within the popper


        if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {
          return;
        }

        scheduleHide(event);
      }

      function isEventListenerStopped(event) {
        return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf('touch') >= 0 : false;
      }

      function createPopperInstance() {
        destroyPopperInstance();
        var _instance$props2 = instance.props,
            popperOptions = _instance$props2.popperOptions,
            placement = _instance$props2.placement,
            offset = _instance$props2.offset,
            getReferenceClientRect = _instance$props2.getReferenceClientRect,
            moveTransition = _instance$props2.moveTransition;
        var arrow = getIsDefaultRenderFn() ? getChildren(popper).arrow : null;
        var computedReference = getReferenceClientRect ? {
          getBoundingClientRect: getReferenceClientRect,
          contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
        } : reference;
        var tippyModifier = {
          name: '$$tippy',
          enabled: true,
          phase: 'beforeWrite',
          requires: ['computeStyles'],
          fn: function fn(_ref2) {
            var state = _ref2.state;

            if (getIsDefaultRenderFn()) {
              var _getDefaultTemplateCh = getDefaultTemplateChildren(),
                  box = _getDefaultTemplateCh.box;

              ['placement', 'reference-hidden', 'escaped'].forEach(function (attr) {
                if (attr === 'placement') {
                  box.setAttribute('data-placement', state.placement);
                } else {
                  if (state.attributes.popper["data-popper-" + attr]) {
                    box.setAttribute("data-" + attr, '');
                  } else {
                    box.removeAttribute("data-" + attr);
                  }
                }
              });
              state.attributes.popper = {};
            }
          }
        };
        var modifiers = [{
          name: 'offset',
          options: {
            offset: offset
          }
        }, {
          name: 'preventOverflow',
          options: {
            padding: {
              top: 2,
              bottom: 2,
              left: 5,
              right: 5
            }
          }
        }, {
          name: 'flip',
          options: {
            padding: 5
          }
        }, {
          name: 'computeStyles',
          options: {
            adaptive: !moveTransition
          }
        }, tippyModifier];

        if (getIsDefaultRenderFn() && arrow) {
          modifiers.push({
            name: 'arrow',
            options: {
              element: arrow,
              padding: 3
            }
          });
        }

        modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
        instance.popperInstance = createPopper(computedReference, popper, Object.assign({}, popperOptions, {
          placement: placement,
          onFirstUpdate: onFirstUpdate,
          modifiers: modifiers
        }));
      }

      function destroyPopperInstance() {
        if (instance.popperInstance) {
          instance.popperInstance.destroy();
          instance.popperInstance = null;
        }
      }

      function mount() {
        var appendTo = instance.props.appendTo;
        var parentNode; // By default, we'll append the popper to the triggerTargets's parentNode so
        // it's directly after the reference element so the elements inside the
        // tippy can be tabbed to
        // If there are clipping issues, the user can specify a different appendTo
        // and ensure focus management is handled correctly manually

        var node = getCurrentTarget();

        if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === 'parent') {
          parentNode = node.parentNode;
        } else {
          parentNode = invokeWithArgsOrReturn(appendTo, [node]);
        } // The popper element needs to exist on the DOM before its position can be
        // updated as Popper needs to read its dimensions


        if (!parentNode.contains(popper)) {
          parentNode.appendChild(popper);
        }

        instance.state.isMounted = true;
        createPopperInstance();
        /* istanbul ignore else */

        {
          // Accessibility check
          warnWhen(instance.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper, ['Interactive tippy element may not be accessible via keyboard', 'navigation because it is not directly after the reference element', 'in the DOM source order.', '\n\n', 'Using a wrapper <div> or <span> tag around the reference element', 'solves this by creating a new parentNode context.', '\n\n', 'Specifying `appendTo: document.body` silences this warning, but it', 'assumes you are using a focus management solution to handle', 'keyboard navigation.', '\n\n', 'See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity'].join(' '));
        }
      }

      function getNestedPopperTree() {
        return arrayFrom(popper.querySelectorAll('[data-tippy-root]'));
      }

      function scheduleShow(event) {
        instance.clearDelayTimeouts();

        if (event) {
          invokeHook('onTrigger', [instance, event]);
        }

        addDocumentPress();
        var delay = getDelay(true);

        var _getNormalizedTouchSe = getNormalizedTouchSettings(),
            touchValue = _getNormalizedTouchSe[0],
            touchDelay = _getNormalizedTouchSe[1];

        if (currentInput.isTouch && touchValue === 'hold' && touchDelay) {
          delay = touchDelay;
        }

        if (delay) {
          showTimeout = setTimeout(function () {
            instance.show();
          }, delay);
        } else {
          instance.show();
        }
      }

      function scheduleHide(event) {
        instance.clearDelayTimeouts();
        invokeHook('onUntrigger', [instance, event]);

        if (!instance.state.isVisible) {
          removeDocumentPress();
          return;
        } // For interactive tippies, scheduleHide is added to a document.body handler
        // from onMouseLeave so must intercept scheduled hides from mousemove/leave
        // events when trigger contains mouseenter and click, and the tip is
        // currently shown as a result of a click.


        if (instance.props.trigger.indexOf('mouseenter') >= 0 && instance.props.trigger.indexOf('click') >= 0 && ['mouseleave', 'mousemove'].indexOf(event.type) >= 0 && isVisibleFromClick) {
          return;
        }

        var delay = getDelay(false);

        if (delay) {
          hideTimeout = setTimeout(function () {
            if (instance.state.isVisible) {
              instance.hide();
            }
          }, delay);
        } else {
          // Fixes a `transitionend` problem when it fires 1 frame too
          // late sometimes, we don't want hide() to be called.
          scheduleHideAnimationFrame = requestAnimationFrame(function () {
            instance.hide();
          });
        }
      } // ===========================================================================
      // 🔑 Public methods
      // ===========================================================================


      function enable() {
        instance.state.isEnabled = true;
      }

      function disable() {
        // Disabling the instance should also hide it
        // https://github.com/atomiks/tippy.js-react/issues/106
        instance.hide();
        instance.state.isEnabled = false;
      }

      function clearDelayTimeouts() {
        clearTimeout(showTimeout);
        clearTimeout(hideTimeout);
        cancelAnimationFrame(scheduleHideAnimationFrame);
      }

      function setProps(partialProps) {
        /* istanbul ignore else */
        {
          warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('setProps'));
        }

        if (instance.state.isDestroyed) {
          return;
        }

        invokeHook('onBeforeUpdate', [instance, partialProps]);
        removeListeners();
        var prevProps = instance.props;
        var nextProps = evaluateProps(reference, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
          ignoreAttributes: true
        }));
        instance.props = nextProps;
        addListeners();

        if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
          cleanupInteractiveMouseListeners();
          debouncedOnMouseMove = debounce(onMouseMove, nextProps.interactiveDebounce);
        } // Ensure stale aria-expanded attributes are removed


        if (prevProps.triggerTarget && !nextProps.triggerTarget) {
          normalizeToArray(prevProps.triggerTarget).forEach(function (node) {
            node.removeAttribute('aria-expanded');
          });
        } else if (nextProps.triggerTarget) {
          reference.removeAttribute('aria-expanded');
        }

        handleAriaExpandedAttribute();
        handleStyles();

        if (onUpdate) {
          onUpdate(prevProps, nextProps);
        }

        if (instance.popperInstance) {
          createPopperInstance(); // Fixes an issue with nested tippies if they are all getting re-rendered,
          // and the nested ones get re-rendered first.
          // https://github.com/atomiks/tippyjs-react/issues/177
          // TODO: find a cleaner / more efficient solution(!)

          getNestedPopperTree().forEach(function (nestedPopper) {
            // React (and other UI libs likely) requires a rAF wrapper as it flushes
            // its work in one
            requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
          });
        }

        invokeHook('onAfterUpdate', [instance, partialProps]);
      }

      function setContent(content) {
        instance.setProps({
          content: content
        });
      }

      function show() {
        /* istanbul ignore else */
        {
          warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('show'));
        } // Early bail-out


        var isAlreadyVisible = instance.state.isVisible;
        var isDestroyed = instance.state.isDestroyed;
        var isDisabled = !instance.state.isEnabled;
        var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
        var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);

        if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
          return;
        } // Normalize `disabled` behavior across browsers.
        // Firefox allows events on disabled elements, but Chrome doesn't.
        // Using a wrapper element (i.e. <span>) is recommended.


        if (getCurrentTarget().hasAttribute('disabled')) {
          return;
        }

        invokeHook('onShow', [instance], false);

        if (instance.props.onShow(instance) === false) {
          return;
        }

        instance.state.isVisible = true;

        if (getIsDefaultRenderFn()) {
          popper.style.visibility = 'visible';
        }

        handleStyles();
        addDocumentPress();

        if (!instance.state.isMounted) {
          popper.style.transition = 'none';
        } // If flipping to the opposite side after hiding at least once, the
        // animation will use the wrong placement without resetting the duration


        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh2 = getDefaultTemplateChildren(),
              box = _getDefaultTemplateCh2.box,
              content = _getDefaultTemplateCh2.content;

          setTransitionDuration([box, content], 0);
        }

        onFirstUpdate = function onFirstUpdate() {
          var _instance$popperInsta2;

          if (!instance.state.isVisible || ignoreOnFirstUpdate) {
            return;
          }

          ignoreOnFirstUpdate = true; // reflow

          void popper.offsetHeight;
          popper.style.transition = instance.props.moveTransition;

          if (getIsDefaultRenderFn() && instance.props.animation) {
            var _getDefaultTemplateCh3 = getDefaultTemplateChildren(),
                _box = _getDefaultTemplateCh3.box,
                _content = _getDefaultTemplateCh3.content;

            setTransitionDuration([_box, _content], duration);
            setVisibilityState([_box, _content], 'visible');
          }

          handleAriaContentAttribute();
          handleAriaExpandedAttribute();
          pushIfUnique(mountedInstances, instance); // certain modifiers (e.g. `maxSize`) require a second update after the
          // popper has been positioned for the first time

          (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
          invokeHook('onMount', [instance]);

          if (instance.props.animation && getIsDefaultRenderFn()) {
            onTransitionedIn(duration, function () {
              instance.state.isShown = true;
              invokeHook('onShown', [instance]);
            });
          }
        };

        mount();
      }

      function hide() {
        /* istanbul ignore else */
        {
          warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('hide'));
        } // Early bail-out


        var isAlreadyHidden = !instance.state.isVisible;
        var isDestroyed = instance.state.isDestroyed;
        var isDisabled = !instance.state.isEnabled;
        var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);

        if (isAlreadyHidden || isDestroyed || isDisabled) {
          return;
        }

        invokeHook('onHide', [instance], false);

        if (instance.props.onHide(instance) === false) {
          return;
        }

        instance.state.isVisible = false;
        instance.state.isShown = false;
        ignoreOnFirstUpdate = false;
        isVisibleFromClick = false;

        if (getIsDefaultRenderFn()) {
          popper.style.visibility = 'hidden';
        }

        cleanupInteractiveMouseListeners();
        removeDocumentPress();
        handleStyles(true);

        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh4 = getDefaultTemplateChildren(),
              box = _getDefaultTemplateCh4.box,
              content = _getDefaultTemplateCh4.content;

          if (instance.props.animation) {
            setTransitionDuration([box, content], duration);
            setVisibilityState([box, content], 'hidden');
          }
        }

        handleAriaContentAttribute();
        handleAriaExpandedAttribute();

        if (instance.props.animation) {
          if (getIsDefaultRenderFn()) {
            onTransitionedOut(duration, instance.unmount);
          }
        } else {
          instance.unmount();
        }
      }

      function hideWithInteractivity(event) {
        /* istanbul ignore else */
        {
          warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('hideWithInteractivity'));
        }

        getDocument().addEventListener('mousemove', debouncedOnMouseMove);
        pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
        debouncedOnMouseMove(event);
      }

      function unmount() {
        /* istanbul ignore else */
        {
          warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('unmount'));
        }

        if (instance.state.isVisible) {
          instance.hide();
        }

        if (!instance.state.isMounted) {
          return;
        }

        destroyPopperInstance(); // If a popper is not interactive, it will be appended outside the popper
        // tree by default. This seems mainly for interactive tippies, but we should
        // find a workaround if possible

        getNestedPopperTree().forEach(function (nestedPopper) {
          nestedPopper._tippy.unmount();
        });

        if (popper.parentNode) {
          popper.parentNode.removeChild(popper);
        }

        mountedInstances = mountedInstances.filter(function (i) {
          return i !== instance;
        });
        instance.state.isMounted = false;
        invokeHook('onHidden', [instance]);
      }

      function destroy() {
        /* istanbul ignore else */
        {
          warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('destroy'));
        }

        if (instance.state.isDestroyed) {
          return;
        }

        instance.clearDelayTimeouts();
        instance.unmount();
        removeListeners();
        delete reference._tippy;
        instance.state.isDestroyed = true;
        invokeHook('onDestroy', [instance]);
      }
    }

    function tippy(targets, optionalProps) {
      if (optionalProps === void 0) {
        optionalProps = {};
      }

      var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
      /* istanbul ignore else */

      {
        validateTargets(targets);
        validateProps(optionalProps, plugins);
      }

      bindGlobalEventListeners();
      var passedProps = Object.assign({}, optionalProps, {
        plugins: plugins
      });
      var elements = getArrayOfElements(targets);
      /* istanbul ignore else */

      {
        var isSingleContentElement = isElement(passedProps.content);
        var isMoreThanOneReferenceElement = elements.length > 1;
        warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ['tippy() was passed an Element as the `content` prop, but more than', 'one tippy instance was created by this invocation. This means the', 'content element will only be appended to the last tippy instance.', '\n\n', 'Instead, pass the .innerHTML of the element, or use a function that', 'returns a cloned version of the element instead.', '\n\n', '1) content: element.innerHTML\n', '2) content: () => element.cloneNode(true)'].join(' '));
      }

      var instances = elements.reduce(function (acc, reference) {
        var instance = reference && createTippy(reference, passedProps);

        if (instance) {
          acc.push(instance);
        }

        return acc;
      }, []);
      return isElement(targets) ? instances[0] : instances;
    }

    tippy.defaultProps = defaultProps;
    tippy.setDefaultProps = setDefaultProps;
    tippy.currentInput = currentInput;
    var hideAll = function hideAll(_temp) {
      var _ref = _temp === void 0 ? {} : _temp,
          excludedReferenceOrInstance = _ref.exclude,
          duration = _ref.duration;

      mountedInstances.forEach(function (instance) {
        var isExcluded = false;

        if (excludedReferenceOrInstance) {
          isExcluded = isReferenceElement(excludedReferenceOrInstance) ? instance.reference === excludedReferenceOrInstance : instance.popper === excludedReferenceOrInstance.popper;
        }

        if (!isExcluded) {
          var originalDuration = instance.props.duration;
          instance.setProps({
            duration: duration
          });
          instance.hide();

          if (!instance.state.isDestroyed) {
            instance.setProps({
              duration: originalDuration
            });
          }
        }
      });
    };

    // every time the popper is destroyed (i.e. a new target), removing the styles
    // and causing transitions to break for singletons when the console is open, but
    // most notably for non-transform styles being used, `gpuAcceleration: false`.

    var applyStylesModifier = Object.assign({}, applyStyles$1, {
      effect: function effect(_ref) {
        var state = _ref.state;
        var initialStyles = {
          popper: {
            position: state.options.strategy,
            left: '0',
            top: '0',
            margin: '0'
          },
          arrow: {
            position: 'absolute'
          },
          reference: {}
        };
        Object.assign(state.elements.popper.style, initialStyles.popper);
        state.styles = initialStyles;

        if (state.elements.arrow) {
          Object.assign(state.elements.arrow.style, initialStyles.arrow);
        } // intentionally return no cleanup function
        // return () => { ... }

      }
    });

    var createSingleton = function createSingleton(tippyInstances, optionalProps) {
      var _optionalProps$popper;

      if (optionalProps === void 0) {
        optionalProps = {};
      }

      /* istanbul ignore else */
      {
        errorWhen(!Array.isArray(tippyInstances), ['The first argument passed to createSingleton() must be an array of', 'tippy instances. The passed value was', String(tippyInstances)].join(' '));
      }

      var individualInstances = tippyInstances;
      var references = [];
      var triggerTargets = [];
      var currentTarget;
      var overrides = optionalProps.overrides;
      var interceptSetPropsCleanups = [];
      var shownOnCreate = false;

      function setTriggerTargets() {
        triggerTargets = individualInstances.map(function (instance) {
          return normalizeToArray(instance.props.triggerTarget || instance.reference);
        }).reduce(function (acc, item) {
          return acc.concat(item);
        }, []);
      }

      function setReferences() {
        references = individualInstances.map(function (instance) {
          return instance.reference;
        });
      }

      function enableInstances(isEnabled) {
        individualInstances.forEach(function (instance) {
          if (isEnabled) {
            instance.enable();
          } else {
            instance.disable();
          }
        });
      }

      function interceptSetProps(singleton) {
        return individualInstances.map(function (instance) {
          var originalSetProps = instance.setProps;

          instance.setProps = function (props) {
            originalSetProps(props);

            if (instance.reference === currentTarget) {
              singleton.setProps(props);
            }
          };

          return function () {
            instance.setProps = originalSetProps;
          };
        });
      } // have to pass singleton, as it maybe undefined on first call


      function prepareInstance(singleton, target) {
        var index = triggerTargets.indexOf(target); // bail-out

        if (target === currentTarget) {
          return;
        }

        currentTarget = target;
        var overrideProps = (overrides || []).concat('content').reduce(function (acc, prop) {
          acc[prop] = individualInstances[index].props[prop];
          return acc;
        }, {});
        singleton.setProps(Object.assign({}, overrideProps, {
          getReferenceClientRect: typeof overrideProps.getReferenceClientRect === 'function' ? overrideProps.getReferenceClientRect : function () {
            var _references$index;

            return (_references$index = references[index]) == null ? void 0 : _references$index.getBoundingClientRect();
          }
        }));
      }

      enableInstances(false);
      setReferences();
      setTriggerTargets();
      var plugin = {
        fn: function fn() {
          return {
            onDestroy: function onDestroy() {
              enableInstances(true);
            },
            onHidden: function onHidden() {
              currentTarget = null;
            },
            onClickOutside: function onClickOutside(instance) {
              if (instance.props.showOnCreate && !shownOnCreate) {
                shownOnCreate = true;
                currentTarget = null;
              }
            },
            onShow: function onShow(instance) {
              if (instance.props.showOnCreate && !shownOnCreate) {
                shownOnCreate = true;
                prepareInstance(instance, references[0]);
              }
            },
            onTrigger: function onTrigger(instance, event) {
              prepareInstance(instance, event.currentTarget);
            }
          };
        }
      };
      var singleton = tippy(div(), Object.assign({}, removeProperties(optionalProps, ['overrides']), {
        plugins: [plugin].concat(optionalProps.plugins || []),
        triggerTarget: triggerTargets,
        popperOptions: Object.assign({}, optionalProps.popperOptions, {
          modifiers: [].concat(((_optionalProps$popper = optionalProps.popperOptions) == null ? void 0 : _optionalProps$popper.modifiers) || [], [applyStylesModifier])
        })
      }));
      var originalShow = singleton.show;

      singleton.show = function (target) {
        originalShow(); // first time, showOnCreate or programmatic call with no params
        // default to showing first instance

        if (!currentTarget && target == null) {
          return prepareInstance(singleton, references[0]);
        } // triggered from event (do nothing as prepareInstance already called by onTrigger)
        // programmatic call with no params when already visible (do nothing again)


        if (currentTarget && target == null) {
          return;
        } // target is index of instance


        if (typeof target === 'number') {
          return references[target] && prepareInstance(singleton, references[target]);
        } // target is a child tippy instance


        if (individualInstances.indexOf(target) >= 0) {
          var ref = target.reference;
          return prepareInstance(singleton, ref);
        } // target is a ReferenceElement


        if (references.indexOf(target) >= 0) {
          return prepareInstance(singleton, target);
        }
      };

      singleton.showNext = function () {
        var first = references[0];

        if (!currentTarget) {
          return singleton.show(0);
        }

        var index = references.indexOf(currentTarget);
        singleton.show(references[index + 1] || first);
      };

      singleton.showPrevious = function () {
        var last = references[references.length - 1];

        if (!currentTarget) {
          return singleton.show(last);
        }

        var index = references.indexOf(currentTarget);
        var target = references[index - 1] || last;
        singleton.show(target);
      };

      var originalSetProps = singleton.setProps;

      singleton.setProps = function (props) {
        overrides = props.overrides || overrides;
        originalSetProps(props);
      };

      singleton.setInstances = function (nextInstances) {
        enableInstances(true);
        interceptSetPropsCleanups.forEach(function (fn) {
          return fn();
        });
        individualInstances = nextInstances;
        enableInstances(false);
        setReferences();
        setTriggerTargets();
        interceptSetPropsCleanups = interceptSetProps(singleton);
        singleton.setProps({
          triggerTarget: triggerTargets
        });
      };

      interceptSetPropsCleanups = interceptSetProps(singleton);
      return singleton;
    };

    var BUBBLING_EVENTS_MAP = {
      mouseover: 'mouseenter',
      focusin: 'focus',
      click: 'click'
    };
    /**
     * Creates a delegate instance that controls the creation of tippy instances
     * for child elements (`target` CSS selector).
     */

    function delegate(targets, props) {
      /* istanbul ignore else */
      {
        errorWhen(!(props && props.target), ['You must specity a `target` prop indicating a CSS selector string matching', 'the target elements that should receive a tippy.'].join(' '));
      }

      var listeners = [];
      var childTippyInstances = [];
      var disabled = false;
      var target = props.target;
      var nativeProps = removeProperties(props, ['target']);
      var parentProps = Object.assign({}, nativeProps, {
        trigger: 'manual',
        touch: false
      });
      var childProps = Object.assign({
        touch: defaultProps.touch
      }, nativeProps, {
        showOnCreate: true
      });
      var returnValue = tippy(targets, parentProps);
      var normalizedReturnValue = normalizeToArray(returnValue);

      function onTrigger(event) {
        if (!event.target || disabled) {
          return;
        }

        var targetNode = event.target.closest(target);

        if (!targetNode) {
          return;
        } // Get relevant trigger with fallbacks:
        // 1. Check `data-tippy-trigger` attribute on target node
        // 2. Fallback to `trigger` passed to `delegate()`
        // 3. Fallback to `defaultProps.trigger`


        var trigger = targetNode.getAttribute('data-tippy-trigger') || props.trigger || defaultProps.trigger; // @ts-ignore

        if (targetNode._tippy) {
          return;
        }

        if (event.type === 'touchstart' && typeof childProps.touch === 'boolean') {
          return;
        }

        if (event.type !== 'touchstart' && trigger.indexOf(BUBBLING_EVENTS_MAP[event.type]) < 0) {
          return;
        }

        var instance = tippy(targetNode, childProps);

        if (instance) {
          childTippyInstances = childTippyInstances.concat(instance);
        }
      }

      function on(node, eventType, handler, options) {
        if (options === void 0) {
          options = false;
        }

        node.addEventListener(eventType, handler, options);
        listeners.push({
          node: node,
          eventType: eventType,
          handler: handler,
          options: options
        });
      }

      function addEventListeners(instance) {
        var reference = instance.reference;
        on(reference, 'touchstart', onTrigger, TOUCH_OPTIONS);
        on(reference, 'mouseover', onTrigger);
        on(reference, 'focusin', onTrigger);
        on(reference, 'click', onTrigger);
      }

      function removeEventListeners() {
        listeners.forEach(function (_ref) {
          var node = _ref.node,
              eventType = _ref.eventType,
              handler = _ref.handler,
              options = _ref.options;
          node.removeEventListener(eventType, handler, options);
        });
        listeners = [];
      }

      function applyMutations(instance) {
        var originalDestroy = instance.destroy;
        var originalEnable = instance.enable;
        var originalDisable = instance.disable;

        instance.destroy = function (shouldDestroyChildInstances) {
          if (shouldDestroyChildInstances === void 0) {
            shouldDestroyChildInstances = true;
          }

          if (shouldDestroyChildInstances) {
            childTippyInstances.forEach(function (instance) {
              instance.destroy();
            });
          }

          childTippyInstances = [];
          removeEventListeners();
          originalDestroy();
        };

        instance.enable = function () {
          originalEnable();
          childTippyInstances.forEach(function (instance) {
            return instance.enable();
          });
          disabled = false;
        };

        instance.disable = function () {
          originalDisable();
          childTippyInstances.forEach(function (instance) {
            return instance.disable();
          });
          disabled = true;
        };

        addEventListeners(instance);
      }

      normalizedReturnValue.forEach(applyMutations);
      return returnValue;
    }

    var animateFill = {
      name: 'animateFill',
      defaultValue: false,
      fn: function fn(instance) {
        var _instance$props$rende;

        // @ts-ignore
        if (!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy)) {
          {
            errorWhen(instance.props.animateFill, 'The `animateFill` plugin requires the default render function.');
          }

          return {};
        }

        var _getChildren = getChildren(instance.popper),
            box = _getChildren.box,
            content = _getChildren.content;

        var backdrop = instance.props.animateFill ? createBackdropElement() : null;
        return {
          onCreate: function onCreate() {
            if (backdrop) {
              box.insertBefore(backdrop, box.firstElementChild);
              box.setAttribute('data-animatefill', '');
              box.style.overflow = 'hidden';
              instance.setProps({
                arrow: false,
                animation: 'shift-away'
              });
            }
          },
          onMount: function onMount() {
            if (backdrop) {
              var transitionDuration = box.style.transitionDuration;
              var duration = Number(transitionDuration.replace('ms', '')); // The content should fade in after the backdrop has mostly filled the
              // tooltip element. `clip-path` is the other alternative but is not
              // well-supported and is buggy on some devices.

              content.style.transitionDelay = Math.round(duration / 10) + "ms";
              backdrop.style.transitionDuration = transitionDuration;
              setVisibilityState([backdrop], 'visible');
            }
          },
          onShow: function onShow() {
            if (backdrop) {
              backdrop.style.transitionDuration = '0ms';
            }
          },
          onHide: function onHide() {
            if (backdrop) {
              setVisibilityState([backdrop], 'hidden');
            }
          }
        };
      }
    };

    function createBackdropElement() {
      var backdrop = div();
      backdrop.className = BACKDROP_CLASS;
      setVisibilityState([backdrop], 'hidden');
      return backdrop;
    }

    var mouseCoords = {
      clientX: 0,
      clientY: 0
    };
    var activeInstances = [];

    function storeMouseCoords(_ref) {
      var clientX = _ref.clientX,
          clientY = _ref.clientY;
      mouseCoords = {
        clientX: clientX,
        clientY: clientY
      };
    }

    function addMouseCoordsListener(doc) {
      doc.addEventListener('mousemove', storeMouseCoords);
    }

    function removeMouseCoordsListener(doc) {
      doc.removeEventListener('mousemove', storeMouseCoords);
    }

    var followCursor = {
      name: 'followCursor',
      defaultValue: false,
      fn: function fn(instance) {
        var reference = instance.reference;
        var doc = getOwnerDocument(instance.props.triggerTarget || reference);
        var isInternalUpdate = false;
        var wasFocusEvent = false;
        var isUnmounted = true;
        var prevProps = instance.props;

        function getIsInitialBehavior() {
          return instance.props.followCursor === 'initial' && instance.state.isVisible;
        }

        function addListener() {
          doc.addEventListener('mousemove', onMouseMove);
        }

        function removeListener() {
          doc.removeEventListener('mousemove', onMouseMove);
        }

        function unsetGetReferenceClientRect() {
          isInternalUpdate = true;
          instance.setProps({
            getReferenceClientRect: null
          });
          isInternalUpdate = false;
        }

        function onMouseMove(event) {
          // If the instance is interactive, avoid updating the position unless it's
          // over the reference element
          var isCursorOverReference = event.target ? reference.contains(event.target) : true;
          var followCursor = instance.props.followCursor;
          var clientX = event.clientX,
              clientY = event.clientY;
          var rect = reference.getBoundingClientRect();
          var relativeX = clientX - rect.left;
          var relativeY = clientY - rect.top;

          if (isCursorOverReference || !instance.props.interactive) {
            instance.setProps({
              // @ts-ignore - unneeded DOMRect properties
              getReferenceClientRect: function getReferenceClientRect() {
                var rect = reference.getBoundingClientRect();
                var x = clientX;
                var y = clientY;

                if (followCursor === 'initial') {
                  x = rect.left + relativeX;
                  y = rect.top + relativeY;
                }

                var top = followCursor === 'horizontal' ? rect.top : y;
                var right = followCursor === 'vertical' ? rect.right : x;
                var bottom = followCursor === 'horizontal' ? rect.bottom : y;
                var left = followCursor === 'vertical' ? rect.left : x;
                return {
                  width: right - left,
                  height: bottom - top,
                  top: top,
                  right: right,
                  bottom: bottom,
                  left: left
                };
              }
            });
          }
        }

        function create() {
          if (instance.props.followCursor) {
            activeInstances.push({
              instance: instance,
              doc: doc
            });
            addMouseCoordsListener(doc);
          }
        }

        function destroy() {
          activeInstances = activeInstances.filter(function (data) {
            return data.instance !== instance;
          });

          if (activeInstances.filter(function (data) {
            return data.doc === doc;
          }).length === 0) {
            removeMouseCoordsListener(doc);
          }
        }

        return {
          onCreate: create,
          onDestroy: destroy,
          onBeforeUpdate: function onBeforeUpdate() {
            prevProps = instance.props;
          },
          onAfterUpdate: function onAfterUpdate(_, _ref2) {
            var followCursor = _ref2.followCursor;

            if (isInternalUpdate) {
              return;
            }

            if (followCursor !== undefined && prevProps.followCursor !== followCursor) {
              destroy();

              if (followCursor) {
                create();

                if (instance.state.isMounted && !wasFocusEvent && !getIsInitialBehavior()) {
                  addListener();
                }
              } else {
                removeListener();
                unsetGetReferenceClientRect();
              }
            }
          },
          onMount: function onMount() {
            if (instance.props.followCursor && !wasFocusEvent) {
              if (isUnmounted) {
                onMouseMove(mouseCoords);
                isUnmounted = false;
              }

              if (!getIsInitialBehavior()) {
                addListener();
              }
            }
          },
          onTrigger: function onTrigger(_, event) {
            if (isMouseEvent(event)) {
              mouseCoords = {
                clientX: event.clientX,
                clientY: event.clientY
              };
            }

            wasFocusEvent = event.type === 'focus';
          },
          onHidden: function onHidden() {
            if (instance.props.followCursor) {
              unsetGetReferenceClientRect();
              removeListener();
              isUnmounted = true;
            }
          }
        };
      }
    };

    function getProps(props, modifier) {
      var _props$popperOptions;

      return {
        popperOptions: Object.assign({}, props.popperOptions, {
          modifiers: [].concat((((_props$popperOptions = props.popperOptions) == null ? void 0 : _props$popperOptions.modifiers) || []).filter(function (_ref) {
            var name = _ref.name;
            return name !== modifier.name;
          }), [modifier])
        })
      };
    }

    var inlinePositioning = {
      name: 'inlinePositioning',
      defaultValue: false,
      fn: function fn(instance) {
        var reference = instance.reference;

        function isEnabled() {
          return !!instance.props.inlinePositioning;
        }

        var placement;
        var cursorRectIndex = -1;
        var isInternalUpdate = false;
        var triedPlacements = [];
        var modifier = {
          name: 'tippyInlinePositioning',
          enabled: true,
          phase: 'afterWrite',
          fn: function fn(_ref2) {
            var state = _ref2.state;

            if (isEnabled()) {
              if (triedPlacements.indexOf(state.placement) !== -1) {
                triedPlacements = [];
              }

              if (placement !== state.placement && triedPlacements.indexOf(state.placement) === -1) {
                triedPlacements.push(state.placement);
                instance.setProps({
                  // @ts-ignore - unneeded DOMRect properties
                  getReferenceClientRect: function getReferenceClientRect() {
                    return _getReferenceClientRect(state.placement);
                  }
                });
              }

              placement = state.placement;
            }
          }
        };

        function _getReferenceClientRect(placement) {
          return getInlineBoundingClientRect(getBasePlacement(placement), reference.getBoundingClientRect(), arrayFrom(reference.getClientRects()), cursorRectIndex);
        }

        function setInternalProps(partialProps) {
          isInternalUpdate = true;
          instance.setProps(partialProps);
          isInternalUpdate = false;
        }

        function addModifier() {
          if (!isInternalUpdate) {
            setInternalProps(getProps(instance.props, modifier));
          }
        }

        return {
          onCreate: addModifier,
          onAfterUpdate: addModifier,
          onTrigger: function onTrigger(_, event) {
            if (isMouseEvent(event)) {
              var rects = arrayFrom(instance.reference.getClientRects());
              var cursorRect = rects.find(function (rect) {
                return rect.left - 2 <= event.clientX && rect.right + 2 >= event.clientX && rect.top - 2 <= event.clientY && rect.bottom + 2 >= event.clientY;
              });
              var index = rects.indexOf(cursorRect);
              cursorRectIndex = index > -1 ? index : cursorRectIndex;
            }
          },
          onHidden: function onHidden() {
            cursorRectIndex = -1;
          }
        };
      }
    };
    function getInlineBoundingClientRect(currentBasePlacement, boundingRect, clientRects, cursorRectIndex) {
      // Not an inline element, or placement is not yet known
      if (clientRects.length < 2 || currentBasePlacement === null) {
        return boundingRect;
      } // There are two rects and they are disjoined


      if (clientRects.length === 2 && cursorRectIndex >= 0 && clientRects[0].left > clientRects[1].right) {
        return clientRects[cursorRectIndex] || boundingRect;
      }

      switch (currentBasePlacement) {
        case 'top':
        case 'bottom':
          {
            var firstRect = clientRects[0];
            var lastRect = clientRects[clientRects.length - 1];
            var isTop = currentBasePlacement === 'top';
            var top = firstRect.top;
            var bottom = lastRect.bottom;
            var left = isTop ? firstRect.left : lastRect.left;
            var right = isTop ? firstRect.right : lastRect.right;
            var width = right - left;
            var height = bottom - top;
            return {
              top: top,
              bottom: bottom,
              left: left,
              right: right,
              width: width,
              height: height
            };
          }

        case 'left':
        case 'right':
          {
            var minLeft = Math.min.apply(Math, clientRects.map(function (rects) {
              return rects.left;
            }));
            var maxRight = Math.max.apply(Math, clientRects.map(function (rects) {
              return rects.right;
            }));
            var measureRects = clientRects.filter(function (rect) {
              return currentBasePlacement === 'left' ? rect.left === minLeft : rect.right === maxRight;
            });
            var _top = measureRects[0].top;
            var _bottom = measureRects[measureRects.length - 1].bottom;
            var _left = minLeft;
            var _right = maxRight;

            var _width = _right - _left;

            var _height = _bottom - _top;

            return {
              top: _top,
              bottom: _bottom,
              left: _left,
              right: _right,
              width: _width,
              height: _height
            };
          }

        default:
          {
            return boundingRect;
          }
      }
    }

    var sticky = {
      name: 'sticky',
      defaultValue: false,
      fn: function fn(instance) {
        var reference = instance.reference,
            popper = instance.popper;

        function getReference() {
          return instance.popperInstance ? instance.popperInstance.state.elements.reference : reference;
        }

        function shouldCheck(value) {
          return instance.props.sticky === true || instance.props.sticky === value;
        }

        var prevRefRect = null;
        var prevPopRect = null;

        function updatePosition() {
          var currentRefRect = shouldCheck('reference') ? getReference().getBoundingClientRect() : null;
          var currentPopRect = shouldCheck('popper') ? popper.getBoundingClientRect() : null;

          if (currentRefRect && areRectsDifferent(prevRefRect, currentRefRect) || currentPopRect && areRectsDifferent(prevPopRect, currentPopRect)) {
            if (instance.popperInstance) {
              instance.popperInstance.update();
            }
          }

          prevRefRect = currentRefRect;
          prevPopRect = currentPopRect;

          if (instance.state.isMounted) {
            requestAnimationFrame(updatePosition);
          }
        }

        return {
          onMount: function onMount() {
            if (instance.props.sticky) {
              updatePosition();
            }
          }
        };
      }
    };

    function areRectsDifferent(rectA, rectB) {
      if (rectA && rectB) {
        return rectA.top !== rectB.top || rectA.right !== rectB.right || rectA.bottom !== rectB.bottom || rectA.left !== rectB.left;
      }

      return true;
    }

    tippy.setDefaultProps({
      animation: false
    });

    var tippyHeadless_esm = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': tippy,
        animateFill: animateFill,
        createSingleton: createSingleton,
        delegate: delegate,
        followCursor: followCursor,
        hideAll: hideAll,
        inlinePositioning: inlinePositioning,
        roundArrow: ROUND_ARROW,
        sticky: sticky
    });

    var require$$0$2 = /*@__PURE__*/getAugmentedNamespace(tippyHeadless_esm);

    Object.defineProperty(tooltipRender$1, "__esModule", { value: true });
    var tooltipRender_2 = tooltipRender$1.tooltipRender = void 0;
    const headless_1 = require$$0$2;
    function tooltipRender(anchorNode, tooltipNode, tippyOptions = {}) {
        return (0, headless_1.default)(anchorNode, Object.assign({ render(_instance) {
                const popperElem = document.createElement('div');
                const arrowElem = document.createElement('div');
                popperElem.className = 'tooltip-container';
                arrowElem.className = 'tooltip-arrow';
                arrowElem.setAttribute('data-popper-arrow', '');
                popperElem.appendChild(tooltipNode);
                popperElem.appendChild(arrowElem);
                return {
                    popper: popperElem,
                };
            }, zIndex: 9999999 }, tippyOptions));
    }
    tooltipRender_2 = tooltipRender$1.tooltipRender = tooltipRender;

    var tooltipStore = {};

    var store = {};

    var internal = {};

    (function (exports) {

    Object.defineProperty(exports, '__esModule', { value: true });

    function noop() { }
    const identity = x => x;
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function is_promise(value) {
        return value && typeof value === 'object' && typeof value.then === 'function';
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    let src_url_equal_anchor;
    function src_url_equal(element_src, url) {
        if (!src_url_equal_anchor) {
            src_url_equal_anchor = document.createElement('a');
        }
        src_url_equal_anchor.href = url;
        return element_src === src_url_equal_anchor.href;
    }
    function not_equal(a, b) {
        return a != a ? b == b : a !== b;
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function get_store_value(store) {
        let value;
        subscribe(store, _ => value = _)();
        return value;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
        const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
        update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);
    }
    function get_all_dirty_from_scope($$scope) {
        if ($$scope.ctx.length > 32) {
            const dirty = [];
            const length = $$scope.ctx.length / 32;
            for (let i = 0; i < length; i++) {
                dirty[i] = -1;
            }
            return dirty;
        }
        return -1;
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }
    function compute_rest_props(props, keys) {
        const rest = {};
        keys = new Set(keys);
        for (const k in props)
            if (!keys.has(k) && k[0] !== '$')
                rest[k] = props[k];
        return rest;
    }
    function compute_slots(slots) {
        const result = {};
        for (const key in slots) {
            result[key] = true;
        }
        return result;
    }
    function once(fn) {
        let ran = false;
        return function (...args) {
            if (ran)
                return;
            ran = true;
            fn.call(this, ...args);
        };
    }
    function null_to_empty(value) {
        return value == null ? '' : value;
    }
    function set_store_value(store, ret, value) {
        store.set(value);
        return ret;
    }
    const has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
    function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
    }

    const is_client = typeof window !== 'undefined';
    exports.now = is_client
        ? () => window.performance.now()
        : () => Date.now();
    exports.raf = is_client ? cb => requestAnimationFrame(cb) : noop;
    // used internally for testing
    function set_now(fn) {
        exports.now = fn;
    }
    function set_raf(fn) {
        exports.raf = fn;
    }

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            exports.raf(run_tasks);
    }
    /**
     * For testing purposes only!
     */
    function clear_loops() {
        tasks.clear();
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            exports.raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }

    // Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM
    // at the end of hydration without touching the remaining nodes.
    let is_hydrating = false;
    function start_hydrating() {
        is_hydrating = true;
    }
    function end_hydrating() {
        is_hydrating = false;
    }
    function upper_bound(low, high, key, value) {
        // Return first index of value larger than input value in the range [low, high)
        while (low < high) {
            const mid = low + ((high - low) >> 1);
            if (key(mid) <= value) {
                low = mid + 1;
            }
            else {
                high = mid;
            }
        }
        return low;
    }
    function init_hydrate(target) {
        if (target.hydrate_init)
            return;
        target.hydrate_init = true;
        // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>
        let children = target.childNodes;
        // If target is <head>, there may be children without claim_order
        if (target.nodeName === 'HEAD') {
            const myChildren = [];
            for (let i = 0; i < children.length; i++) {
                const node = children[i];
                if (node.claim_order !== undefined) {
                    myChildren.push(node);
                }
            }
            children = myChildren;
        }
        /*
        * Reorder claimed children optimally.
        * We can reorder claimed children optimally by finding the longest subsequence of
        * nodes that are already claimed in order and only moving the rest. The longest
        * subsequence subsequence of nodes that are claimed in order can be found by
        * computing the longest increasing subsequence of .claim_order values.
        *
        * This algorithm is optimal in generating the least amount of reorder operations
        * possible.
        *
        * Proof:
        * We know that, given a set of reordering operations, the nodes that do not move
        * always form an increasing subsequence, since they do not move among each other
        * meaning that they must be already ordered among each other. Thus, the maximal
        * set of nodes that do not move form a longest increasing subsequence.
        */
        // Compute longest increasing subsequence
        // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j
        const m = new Int32Array(children.length + 1);
        // Predecessor indices + 1
        const p = new Int32Array(children.length);
        m[0] = -1;
        let longest = 0;
        for (let i = 0; i < children.length; i++) {
            const current = children[i].claim_order;
            // Find the largest subsequence length such that it ends in a value less than our current value
            // upper_bound returns first greater value, so we subtract one
            // with fast path for when we are on the current longest subsequence
            const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;
            p[i] = m[seqLen] + 1;
            const newLen = seqLen + 1;
            // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.
            m[newLen] = i;
            longest = Math.max(newLen, longest);
        }
        // The longest increasing subsequence of nodes (initially reversed)
        const lis = [];
        // The rest of the nodes, nodes that will be moved
        const toMove = [];
        let last = children.length - 1;
        for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {
            lis.push(children[cur - 1]);
            for (; last >= cur; last--) {
                toMove.push(children[last]);
            }
            last--;
        }
        for (; last >= 0; last--) {
            toMove.push(children[last]);
        }
        lis.reverse();
        // We sort the nodes being moved to guarantee that their insertion order matches the claim order
        toMove.sort((a, b) => a.claim_order - b.claim_order);
        // Finally, we move the nodes
        for (let i = 0, j = 0; i < toMove.length; i++) {
            while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {
                j++;
            }
            const anchor = j < lis.length ? lis[j] : null;
            target.insertBefore(toMove[i], anchor);
        }
    }
    function append(target, node) {
        target.appendChild(node);
    }
    function append_styles(target, style_sheet_id, styles) {
        const append_styles_to = get_root_for_style(target);
        if (!append_styles_to.getElementById(style_sheet_id)) {
            const style = element('style');
            style.id = style_sheet_id;
            style.textContent = styles;
            append_stylesheet(append_styles_to, style);
        }
    }
    function get_root_for_style(node) {
        if (!node)
            return document;
        const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
        if (root && root.host) {
            return root;
        }
        return node.ownerDocument;
    }
    function append_empty_stylesheet(node) {
        const style_element = element('style');
        append_stylesheet(get_root_for_style(node), style_element);
        return style_element.sheet;
    }
    function append_stylesheet(node, style) {
        append(node.head || node, style);
    }
    function append_hydration(target, node) {
        if (is_hydrating) {
            init_hydrate(target);
            if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentElement !== target))) {
                target.actual_end_child = target.firstChild;
            }
            // Skip nodes of undefined ordering
            while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {
                target.actual_end_child = target.actual_end_child.nextSibling;
            }
            if (node !== target.actual_end_child) {
                // We only insert if the ordering of this node should be modified or the parent node is not target
                if (node.claim_order !== undefined || node.parentNode !== target) {
                    target.insertBefore(node, target.actual_end_child);
                }
            }
            else {
                target.actual_end_child = node.nextSibling;
            }
        }
        else if (node.parentNode !== target || node.nextSibling !== null) {
            target.appendChild(node);
        }
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function insert_hydration(target, node, anchor) {
        if (is_hydrating && !anchor) {
            append_hydration(target, node);
        }
        else if (node.parentNode !== target || node.nextSibling != anchor) {
            target.insertBefore(node, anchor || null);
        }
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function element_is(name, is) {
        return document.createElement(name, { is });
    }
    function object_without_properties(obj, exclude) {
        const target = {};
        for (const k in obj) {
            if (has_prop(obj, k)
                // @ts-ignore
                && exclude.indexOf(k) === -1) {
                // @ts-ignore
                target[k] = obj[k];
            }
        }
        return target;
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function prevent_default(fn) {
        return function (event) {
            event.preventDefault();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function stop_propagation(fn) {
        return function (event) {
            event.stopPropagation();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function self(fn) {
        return function (event) {
            // @ts-ignore
            if (event.target === this)
                fn.call(this, event);
        };
    }
    function trusted(fn) {
        return function (event) {
            // @ts-ignore
            if (event.isTrusted)
                fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_attributes(node, attributes) {
        // @ts-ignore
        const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
        for (const key in attributes) {
            if (attributes[key] == null) {
                node.removeAttribute(key);
            }
            else if (key === 'style') {
                node.style.cssText = attributes[key];
            }
            else if (key === '__value') {
                node.value = node[key] = attributes[key];
            }
            else if (descriptors[key] && descriptors[key].set) {
                node[key] = attributes[key];
            }
            else {
                attr(node, key, attributes[key]);
            }
        }
    }
    function set_svg_attributes(node, attributes) {
        for (const key in attributes) {
            attr(node, key, attributes[key]);
        }
    }
    function set_custom_element_data(node, prop, value) {
        if (prop in node) {
            node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;
        }
        else {
            attr(node, prop, value);
        }
    }
    function xlink_attr(node, attribute, value) {
        node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);
    }
    function get_binding_group_value(group, __value, checked) {
        const value = new Set();
        for (let i = 0; i < group.length; i += 1) {
            if (group[i].checked)
                value.add(group[i].__value);
        }
        if (!checked) {
            value.delete(__value);
        }
        return Array.from(value);
    }
    function to_number(value) {
        return value === '' ? null : +value;
    }
    function time_ranges_to_array(ranges) {
        const array = [];
        for (let i = 0; i < ranges.length; i += 1) {
            array.push({ start: ranges.start(i), end: ranges.end(i) });
        }
        return array;
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function init_claim_info(nodes) {
        if (nodes.claim_info === undefined) {
            nodes.claim_info = { last_index: 0, total_claimed: 0 };
        }
    }
    function claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {
        // Try to find nodes in an order such that we lengthen the longest increasing subsequence
        init_claim_info(nodes);
        const resultNode = (() => {
            // We first try to find an element after the previous one
            for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {
                const node = nodes[i];
                if (predicate(node)) {
                    const replacement = processNode(node);
                    if (replacement === undefined) {
                        nodes.splice(i, 1);
                    }
                    else {
                        nodes[i] = replacement;
                    }
                    if (!dontUpdateLastIndex) {
                        nodes.claim_info.last_index = i;
                    }
                    return node;
                }
            }
            // Otherwise, we try to find one before
            // We iterate in reverse so that we don't go too far back
            for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {
                const node = nodes[i];
                if (predicate(node)) {
                    const replacement = processNode(node);
                    if (replacement === undefined) {
                        nodes.splice(i, 1);
                    }
                    else {
                        nodes[i] = replacement;
                    }
                    if (!dontUpdateLastIndex) {
                        nodes.claim_info.last_index = i;
                    }
                    else if (replacement === undefined) {
                        // Since we spliced before the last_index, we decrease it
                        nodes.claim_info.last_index--;
                    }
                    return node;
                }
            }
            // If we can't find any matching node, we create a new one
            return createNode();
        })();
        resultNode.claim_order = nodes.claim_info.total_claimed;
        nodes.claim_info.total_claimed += 1;
        return resultNode;
    }
    function claim_element_base(nodes, name, attributes, create_element) {
        return claim_node(nodes, (node) => node.nodeName === name, (node) => {
            const remove = [];
            for (let j = 0; j < node.attributes.length; j++) {
                const attribute = node.attributes[j];
                if (!attributes[attribute.name]) {
                    remove.push(attribute.name);
                }
            }
            remove.forEach(v => node.removeAttribute(v));
            return undefined;
        }, () => create_element(name));
    }
    function claim_element(nodes, name, attributes) {
        return claim_element_base(nodes, name, attributes, element);
    }
    function claim_svg_element(nodes, name, attributes) {
        return claim_element_base(nodes, name, attributes, svg_element);
    }
    function claim_text(nodes, data) {
        return claim_node(nodes, (node) => node.nodeType === 3, (node) => {
            const dataStr = '' + data;
            if (node.data.startsWith(dataStr)) {
                if (node.data.length !== dataStr.length) {
                    return node.splitText(dataStr.length);
                }
            }
            else {
                node.data = dataStr;
            }
        }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements
        );
    }
    function claim_space(nodes) {
        return claim_text(nodes, ' ');
    }
    function find_comment(nodes, text, start) {
        for (let i = start; i < nodes.length; i += 1) {
            const node = nodes[i];
            if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {
                return i;
            }
        }
        return nodes.length;
    }
    function claim_html_tag(nodes) {
        // find html opening tag
        const start_index = find_comment(nodes, 'HTML_TAG_START', 0);
        const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);
        if (start_index === end_index) {
            return new HtmlTagHydration();
        }
        init_claim_info(nodes);
        const html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);
        detach(html_tag_nodes[0]);
        detach(html_tag_nodes[html_tag_nodes.length - 1]);
        const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);
        for (const n of claimed_nodes) {
            n.claim_order = nodes.claim_info.total_claimed;
            nodes.claim_info.total_claimed += 1;
        }
        return new HtmlTagHydration(claimed_nodes);
    }
    function set_data(text, data) {
        data = '' + data;
        if (text.wholeText !== data)
            text.data = data;
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_input_type(input, type) {
        try {
            input.type = type;
        }
        catch (e) {
            // do nothing
        }
    }
    function set_style(node, key, value, important) {
        if (value === null) {
            node.style.removeProperty(key);
        }
        else {
            node.style.setProperty(key, value, important ? 'important' : '');
        }
    }
    function select_option(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            if (option.__value === value) {
                option.selected = true;
                return;
            }
        }
        select.selectedIndex = -1; // no option should be selected
    }
    function select_options(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            option.selected = ~value.indexOf(option.__value);
        }
    }
    function select_value(select) {
        const selected_option = select.querySelector(':checked') || select.options[0];
        return selected_option && selected_option.__value;
    }
    function select_multiple_value(select) {
        return [].map.call(select.querySelectorAll(':checked'), option => option.__value);
    }
    // unfortunately this can't be a constant as that wouldn't be tree-shakeable
    // so we cache the result instead
    let crossorigin;
    function is_crossorigin() {
        if (crossorigin === undefined) {
            crossorigin = false;
            try {
                if (typeof window !== 'undefined' && window.parent) {
                    void window.parent.document;
                }
            }
            catch (error) {
                crossorigin = true;
            }
        }
        return crossorigin;
    }
    function add_resize_listener(node, fn) {
        const computed_style = getComputedStyle(node);
        if (computed_style.position === 'static') {
            node.style.position = 'relative';
        }
        const iframe = element('iframe');
        iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +
            'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');
        iframe.setAttribute('aria-hidden', 'true');
        iframe.tabIndex = -1;
        const crossorigin = is_crossorigin();
        let unsubscribe;
        if (crossorigin) {
            iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>";
            unsubscribe = listen(window, 'message', (event) => {
                if (event.source === iframe.contentWindow)
                    fn();
            });
        }
        else {
            iframe.src = 'about:blank';
            iframe.onload = () => {
                unsubscribe = listen(iframe.contentWindow, 'resize', fn);
            };
        }
        append(node, iframe);
        return () => {
            if (crossorigin) {
                unsubscribe();
            }
            else if (unsubscribe && iframe.contentWindow) {
                unsubscribe();
            }
            detach(iframe);
        };
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail, bubbles = false) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, false, detail);
        return e;
    }
    function query_selector_all(selector, parent = document.body) {
        return Array.from(parent.querySelectorAll(selector));
    }
    class HtmlTag {
        constructor() {
            this.e = this.n = null;
        }
        c(html) {
            this.h(html);
        }
        m(html, target, anchor = null) {
            if (!this.e) {
                this.e = element(target.nodeName);
                this.t = target;
                this.c(html);
            }
            this.i(anchor);
        }
        h(html) {
            this.e.innerHTML = html;
            this.n = Array.from(this.e.childNodes);
        }
        i(anchor) {
            for (let i = 0; i < this.n.length; i += 1) {
                insert(this.t, this.n[i], anchor);
            }
        }
        p(html) {
            this.d();
            this.h(html);
            this.i(this.a);
        }
        d() {
            this.n.forEach(detach);
        }
    }
    class HtmlTagHydration extends HtmlTag {
        constructor(claimed_nodes) {
            super();
            this.e = this.n = null;
            this.l = claimed_nodes;
        }
        c(html) {
            if (this.l) {
                this.n = this.l;
            }
            else {
                super.c(html);
            }
        }
        i(anchor) {
            for (let i = 0; i < this.n.length; i += 1) {
                insert_hydration(this.t, this.n[i], anchor);
            }
        }
    }
    function attribute_to_object(attributes) {
        const result = {};
        for (const attribute of attributes) {
            result[attribute.name] = attribute.value;
        }
        return result;
    }
    function get_custom_elements_slots(element) {
        const result = {};
        element.childNodes.forEach((node) => {
            result[node.slot || 'default'] = true;
        });
        return result;
    }

    // we need to store the information for multiple documents because a Svelte application could also contain iframes
    // https://github.com/sveltejs/svelte/issues/3624
    const managed_styles = new Map();
    let active = 0;
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_style_information(doc, node) {
        const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
        managed_styles.set(doc, info);
        return info;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash(rule)}_${uid}`;
        const doc = get_root_for_style(node);
        const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
        if (!rules[name]) {
            rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
    }
    function delete_rule(node, name) {
        const previous = (node.style.animation || '').split(', ');
        const next = previous.filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
            node.style.animation = next.join(', ');
            active -= deleted;
            if (!active)
                clear_rules();
        }
    }
    function clear_rules() {
        exports.raf(() => {
            if (active)
                return;
            managed_styles.forEach(info => {
                const { stylesheet } = info;
                let i = stylesheet.cssRules.length;
                while (i--)
                    stylesheet.deleteRule(i);
                info.rules = {};
            });
            managed_styles.clear();
        });
    }

    function create_animation(node, from, fn, params) {
        if (!from)
            return noop;
        const to = node.getBoundingClientRect();
        if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)
            return noop;
        const { delay = 0, duration = 300, easing = identity, 
        // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?
        start: start_time = exports.now() + delay, 
        // @ts-ignore todo:
        end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);
        let running = true;
        let started = false;
        let name;
        function start() {
            if (css) {
                name = create_rule(node, 0, 1, duration, delay, easing, css);
            }
            if (!delay) {
                started = true;
            }
        }
        function stop() {
            if (css)
                delete_rule(node, name);
            running = false;
        }
        loop(now => {
            if (!started && now >= start_time) {
                started = true;
            }
            if (started && now >= end) {
                tick(1, 0);
                stop();
            }
            if (!running) {
                return false;
            }
            if (started) {
                const p = now - start_time;
                const t = 0 + 1 * easing(p / duration);
                tick(t, 1 - t);
            }
            return true;
        });
        start();
        tick(0, 1);
        return stop;
    }
    function fix_position(node) {
        const style = getComputedStyle(node);
        if (style.position !== 'absolute' && style.position !== 'fixed') {
            const { width, height } = style;
            const a = node.getBoundingClientRect();
            node.style.position = 'absolute';
            node.style.width = width;
            node.style.height = height;
            add_transform(node, a);
        }
    }
    function add_transform(node, a) {
        const b = node.getBoundingClientRect();
        if (a.left !== b.left || a.top !== b.top) {
            const style = getComputedStyle(node);
            const transform = style.transform === 'none' ? '' : style.transform;
            node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
        }
    }

    function set_current_component(component) {
        exports.current_component = component;
    }
    function get_current_component() {
        if (!exports.current_component)
            throw new Error('Function called outside component initialization');
        return exports.current_component;
    }
    function beforeUpdate(fn) {
        get_current_component().$$.before_update.push(fn);
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    function setContext(key, context) {
        get_current_component().$$.context.set(key, context);
    }
    function getContext(key) {
        return get_current_component().$$.context.get(key);
    }
    function getAllContexts() {
        return get_current_component().$$.context;
    }
    function hasContext(key) {
        return get_current_component().$$.context.has(key);
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            // @ts-ignore
            callbacks.slice().forEach(fn => fn.call(this, event));
        }
    }

    const dirty_components = [];
    const intros = { enabled: false };
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    // flush() calls callbacks in this order:
    // 1. All beforeUpdate callbacks, in order: parents before children
    // 2. All bind:this callbacks, in reverse order: children before parents.
    // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
    //    for afterUpdates called during the initial onMount, which are called in
    //    reverse order: children before parents.
    // Since callbacks might update component values, which could trigger another
    // call to flush(), the following steps guard against this:
    // 1. During beforeUpdate, any updated components will be added to the
    //    dirty_components array and will cause a reentrant call to flush(). Because
    //    the flush index is kept outside the function, the reentrant call will pick
    //    up where the earlier call left off and go through all dirty components. The
    //    current_component value is saved and restored so that the reentrant call will
    //    not interfere with the "parent" flush() call.
    // 2. bind:this callbacks cannot trigger new flush() calls.
    // 3. During afterUpdate, any updated components will NOT have their afterUpdate
    //    callback called a second time; the seen_callbacks set, outside the flush()
    //    function, guarantees this behavior.
    const seen_callbacks = new Set();
    let flushidx = 0; // Do *not* move this inside the flush() function
    function flush() {
        const saved_component = exports.current_component;
        do {
            // first, call beforeUpdate functions
            // and update components
            while (flushidx < dirty_components.length) {
                const component = dirty_components[flushidx];
                flushidx++;
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            flushidx = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        seen_callbacks.clear();
        set_current_component(saved_component);
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }
    const null_transition = { duration: 0 };
    function create_in_transition(node, fn, params) {
        let config = fn(node, params);
        let running = false;
        let animation_name;
        let task;
        let uid = 0;
        function cleanup() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
            tick(0, 1);
            const start_time = exports.now() + delay;
            const end_time = start_time + duration;
            if (task)
                task.abort();
            running = true;
            add_render_callback(() => dispatch(node, true, 'start'));
            task = loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(1, 0);
                        dispatch(node, true, 'end');
                        cleanup();
                        return running = false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(t, 1 - t);
                    }
                }
                return running;
            });
        }
        let started = false;
        return {
            start() {
                if (started)
                    return;
                started = true;
                delete_rule(node);
                if (is_function(config)) {
                    config = config();
                    wait().then(go);
                }
                else {
                    go();
                }
            },
            invalidate() {
                started = false;
            },
            end() {
                if (running) {
                    cleanup();
                    running = false;
                }
            }
        };
    }
    function create_out_transition(node, fn, params) {
        let config = fn(node, params);
        let running = true;
        let animation_name;
        const group = outros;
        group.r += 1;
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
            const start_time = exports.now() + delay;
            const end_time = start_time + duration;
            add_render_callback(() => dispatch(node, false, 'start'));
            loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(0, 1);
                        dispatch(node, false, 'end');
                        if (!--group.r) {
                            // this will result in `end()` being called,
                            // so we don't need to clean up here
                            run_all(group.c);
                        }
                        return false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(1 - t, t);
                    }
                }
                return running;
            });
        }
        if (is_function(config)) {
            wait().then(() => {
                // @ts-ignore
                config = config();
                go();
            });
        }
        else {
            go();
        }
        return {
            end(reset) {
                if (reset && config.tick) {
                    config.tick(1, 0);
                }
                if (running) {
                    if (animation_name)
                        delete_rule(node, animation_name);
                    running = false;
                }
            }
        };
    }
    function create_bidirectional_transition(node, fn, params, intro) {
        let config = fn(node, params);
        let t = intro ? 0 : 1;
        let running_program = null;
        let pending_program = null;
        let animation_name = null;
        function clear_animation() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function init(program, duration) {
            const d = (program.b - t);
            duration *= Math.abs(d);
            return {
                a: t,
                b: program.b,
                d,
                duration,
                start: program.start,
                end: program.start + duration,
                group: program.group
            };
        }
        function go(b) {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            const program = {
                start: exports.now() + delay,
                b
            };
            if (!b) {
                // @ts-ignore todo: improve typings
                program.group = outros;
                outros.r += 1;
            }
            if (running_program || pending_program) {
                pending_program = program;
            }
            else {
                // if this is an intro, and there's a delay, we need to do
                // an initial tick and/or apply CSS animation immediately
                if (css) {
                    clear_animation();
                    animation_name = create_rule(node, t, b, duration, delay, easing, css);
                }
                if (b)
                    tick(0, 1);
                running_program = init(program, duration);
                add_render_callback(() => dispatch(node, b, 'start'));
                loop(now => {
                    if (pending_program && now > pending_program.start) {
                        running_program = init(pending_program, duration);
                        pending_program = null;
                        dispatch(node, running_program.b, 'start');
                        if (css) {
                            clear_animation();
                            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                        }
                    }
                    if (running_program) {
                        if (now >= running_program.end) {
                            tick(t = running_program.b, 1 - t);
                            dispatch(node, running_program.b, 'end');
                            if (!pending_program) {
                                // we're done
                                if (running_program.b) {
                                    // intro — we can tidy up immediately
                                    clear_animation();
                                }
                                else {
                                    // outro — needs to be coordinated
                                    if (!--running_program.group.r)
                                        run_all(running_program.group.c);
                                }
                            }
                            running_program = null;
                        }
                        else if (now >= running_program.start) {
                            const p = now - running_program.start;
                            t = running_program.a + running_program.d * easing(p / running_program.duration);
                            tick(t, 1 - t);
                        }
                    }
                    return !!(running_program || pending_program);
                });
            }
        }
        return {
            run(b) {
                if (is_function(config)) {
                    wait().then(() => {
                        // @ts-ignore
                        config = config();
                        go(b);
                    });
                }
                else {
                    go(b);
                }
            },
            end() {
                clear_animation();
                running_program = pending_program = null;
            }
        };
    }

    function handle_promise(promise, info) {
        const token = info.token = {};
        function update(type, index, key, value) {
            if (info.token !== token)
                return;
            info.resolved = value;
            let child_ctx = info.ctx;
            if (key !== undefined) {
                child_ctx = child_ctx.slice();
                child_ctx[key] = value;
            }
            const block = type && (info.current = type)(child_ctx);
            let needs_flush = false;
            if (info.block) {
                if (info.blocks) {
                    info.blocks.forEach((block, i) => {
                        if (i !== index && block) {
                            group_outros();
                            transition_out(block, 1, 1, () => {
                                if (info.blocks[i] === block) {
                                    info.blocks[i] = null;
                                }
                            });
                            check_outros();
                        }
                    });
                }
                else {
                    info.block.d(1);
                }
                block.c();
                transition_in(block, 1);
                block.m(info.mount(), info.anchor);
                needs_flush = true;
            }
            info.block = block;
            if (info.blocks)
                info.blocks[index] = block;
            if (needs_flush) {
                flush();
            }
        }
        if (is_promise(promise)) {
            const current_component = get_current_component();
            promise.then(value => {
                set_current_component(current_component);
                update(info.then, 1, info.value, value);
                set_current_component(null);
            }, error => {
                set_current_component(current_component);
                update(info.catch, 2, info.error, error);
                set_current_component(null);
                if (!info.hasCatch) {
                    throw error;
                }
            });
            // if we previously had a then/catch block, destroy it
            if (info.current !== info.pending) {
                update(info.pending, 0);
                return true;
            }
        }
        else {
            if (info.current !== info.then) {
                update(info.then, 1, info.value, promise);
                return true;
            }
            info.resolved = promise;
        }
    }
    function update_await_block_branch(info, ctx, dirty) {
        const child_ctx = ctx.slice();
        const { resolved } = info;
        if (info.current === info.then) {
            child_ctx[info.value] = resolved;
        }
        if (info.current === info.catch) {
            child_ctx[info.error] = resolved;
        }
        info.block.p(child_ctx, dirty);
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : commonjsGlobal);

    function destroy_block(block, lookup) {
        block.d(1);
        lookup.delete(block.key);
    }
    function outro_and_destroy_block(block, lookup) {
        transition_out(block, 1, 1, () => {
            lookup.delete(block.key);
        });
    }
    function fix_and_destroy_block(block, lookup) {
        block.f();
        destroy_block(block, lookup);
    }
    function fix_and_outro_and_destroy_block(block, lookup) {
        block.f();
        outro_and_destroy_block(block, lookup);
    }
    function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
        let o = old_blocks.length;
        let n = list.length;
        let i = o;
        const old_indexes = {};
        while (i--)
            old_indexes[old_blocks[i].key] = i;
        const new_blocks = [];
        const new_lookup = new Map();
        const deltas = new Map();
        i = n;
        while (i--) {
            const child_ctx = get_context(ctx, list, i);
            const key = get_key(child_ctx);
            let block = lookup.get(key);
            if (!block) {
                block = create_each_block(key, child_ctx);
                block.c();
            }
            else if (dynamic) {
                block.p(child_ctx, dirty);
            }
            new_lookup.set(key, new_blocks[i] = block);
            if (key in old_indexes)
                deltas.set(key, Math.abs(i - old_indexes[key]));
        }
        const will_move = new Set();
        const did_move = new Set();
        function insert(block) {
            transition_in(block, 1);
            block.m(node, next);
            lookup.set(block.key, block);
            next = block.first;
            n--;
        }
        while (o && n) {
            const new_block = new_blocks[n - 1];
            const old_block = old_blocks[o - 1];
            const new_key = new_block.key;
            const old_key = old_block.key;
            if (new_block === old_block) {
                // do nothing
                next = new_block.first;
                o--;
                n--;
            }
            else if (!new_lookup.has(old_key)) {
                // remove old block
                destroy(old_block, lookup);
                o--;
            }
            else if (!lookup.has(new_key) || will_move.has(new_key)) {
                insert(new_block);
            }
            else if (did_move.has(old_key)) {
                o--;
            }
            else if (deltas.get(new_key) > deltas.get(old_key)) {
                did_move.add(new_key);
                insert(new_block);
            }
            else {
                will_move.add(old_key);
                o--;
            }
        }
        while (o--) {
            const old_block = old_blocks[o];
            if (!new_lookup.has(old_block.key))
                destroy(old_block, lookup);
        }
        while (n)
            insert(new_blocks[n - 1]);
        return new_blocks;
    }
    function validate_each_keys(ctx, list, get_context, get_key) {
        const keys = new Set();
        for (let i = 0; i < list.length; i++) {
            const key = get_key(get_context(ctx, list, i));
            if (keys.has(key)) {
                throw new Error('Cannot have duplicate keys in a keyed each');
            }
            keys.add(key);
        }
    }

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }

    // source: https://html.spec.whatwg.org/multipage/indices.html
    const boolean_attributes = new Set([
        'allowfullscreen',
        'allowpaymentrequest',
        'async',
        'autofocus',
        'autoplay',
        'checked',
        'controls',
        'default',
        'defer',
        'disabled',
        'formnovalidate',
        'hidden',
        'ismap',
        'loop',
        'multiple',
        'muted',
        'nomodule',
        'novalidate',
        'open',
        'playsinline',
        'readonly',
        'required',
        'reversed',
        'selected'
    ]);

    const invalid_attribute_name_character = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
    // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
    // https://infra.spec.whatwg.org/#noncharacter
    function spread(args, attrs_to_add) {
        const attributes = Object.assign({}, ...args);
        if (attrs_to_add) {
            const classes_to_add = attrs_to_add.classes;
            const styles_to_add = attrs_to_add.styles;
            if (classes_to_add) {
                if (attributes.class == null) {
                    attributes.class = classes_to_add;
                }
                else {
                    attributes.class += ' ' + classes_to_add;
                }
            }
            if (styles_to_add) {
                if (attributes.style == null) {
                    attributes.style = style_object_to_string(styles_to_add);
                }
                else {
                    attributes.style = style_object_to_string(merge_ssr_styles(attributes.style, styles_to_add));
                }
            }
        }
        let str = '';
        Object.keys(attributes).forEach(name => {
            if (invalid_attribute_name_character.test(name))
                return;
            const value = attributes[name];
            if (value === true)
                str += ' ' + name;
            else if (boolean_attributes.has(name.toLowerCase())) {
                if (value)
                    str += ' ' + name;
            }
            else if (value != null) {
                str += ` ${name}="${value}"`;
            }
        });
        return str;
    }
    function merge_ssr_styles(style_attribute, style_directive) {
        const style_object = {};
        for (const individual_style of style_attribute.split(';')) {
            const colon_index = individual_style.indexOf(':');
            const name = individual_style.slice(0, colon_index).trim();
            const value = individual_style.slice(colon_index + 1).trim();
            if (!name)
                continue;
            style_object[name] = value;
        }
        for (const name in style_directive) {
            const value = style_directive[name];
            if (value) {
                style_object[name] = value;
            }
            else {
                delete style_object[name];
            }
        }
        return style_object;
    }
    const escaped = {
        '"': '&quot;',
        "'": '&#39;',
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;'
    };
    function escape(html) {
        return String(html).replace(/["'&<>]/g, match => escaped[match]);
    }
    function escape_attribute_value(value) {
        return typeof value === 'string' ? escape(value) : value;
    }
    function escape_object(obj) {
        const result = {};
        for (const key in obj) {
            result[key] = escape_attribute_value(obj[key]);
        }
        return result;
    }
    function each(items, fn) {
        let str = '';
        for (let i = 0; i < items.length; i += 1) {
            str += fn(items[i], i);
        }
        return str;
    }
    const missing_component = {
        $$render: () => ''
    };
    function validate_component(component, name) {
        if (!component || !component.$$render) {
            if (name === 'svelte:component')
                name += ' this={...}';
            throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
        }
        return component;
    }
    function debug(file, line, column, values) {
        console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console
        console.log(values); // eslint-disable-line no-console
        return '';
    }
    let on_destroy;
    function create_ssr_component(fn) {
        function $$render(result, props, bindings, slots, context) {
            const parent_component = exports.current_component;
            const $$ = {
                on_destroy,
                context: new Map(context || (parent_component ? parent_component.$$.context : [])),
                // these will be immediately discarded
                on_mount: [],
                before_update: [],
                after_update: [],
                callbacks: blank_object()
            };
            set_current_component({ $$ });
            const html = fn(result, props, bindings, slots);
            set_current_component(parent_component);
            return html;
        }
        return {
            render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {
                on_destroy = [];
                const result = { title: '', head: '', css: new Set() };
                const html = $$render(result, props, {}, $$slots, context);
                run_all(on_destroy);
                return {
                    html,
                    css: {
                        code: Array.from(result.css).map(css => css.code).join('\n'),
                        map: null // TODO
                    },
                    head: result.title + result.head
                };
            },
            $$render
        };
    }
    function add_attribute(name, value, boolean) {
        if (value == null || (boolean && !value))
            return '';
        return ` ${name}${value === true && boolean_attributes.has(name) ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `"${value}"`}`}`;
    }
    function add_classes(classes) {
        return classes ? ` class="${classes}"` : '';
    }
    function style_object_to_string(style_object) {
        return Object.keys(style_object)
            .filter(key => style_object[key])
            .map(key => `${key}: ${style_object[key]};`)
            .join(' ');
    }
    function add_styles(style_object) {
        const styles = style_object_to_string(style_object);
        return styles ? ` style="${styles}"` : '';
    }

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function claim_component(block, parent_nodes) {
        block && block.l(parent_nodes);
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = exports.current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                start_hydrating();
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            end_hydrating();
            flush();
        }
        set_current_component(parent_component);
    }
    if (typeof HTMLElement === 'function') {
        exports.SvelteElement = class extends HTMLElement {
            constructor() {
                super();
                this.attachShadow({ mode: 'open' });
            }
            connectedCallback() {
                const { on_mount } = this.$$;
                this.$$.on_disconnect = on_mount.map(run).filter(is_function);
                // @ts-ignore todo: improve typings
                for (const key in this.$$.slotted) {
                    // @ts-ignore todo: improve typings
                    this.appendChild(this.$$.slotted[key]);
                }
            }
            attributeChangedCallback(attr, _oldValue, newValue) {
                this[attr] = newValue;
            }
            disconnectedCallback() {
                run_all(this.$$.on_disconnect);
            }
            $destroy() {
                destroy_component(this, 1);
                this.$destroy = noop;
            }
            $on(type, callback) {
                // TODO should this delegate to addEventListener?
                const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
                callbacks.push(callback);
                return () => {
                    const index = callbacks.indexOf(callback);
                    if (index !== -1)
                        callbacks.splice(index, 1);
                };
            }
            $set($$props) {
                if (this.$$set && !is_empty($$props)) {
                    this.$$.skip_bound = true;
                    this.$$set($$props);
                    this.$$.skip_bound = false;
                }
            }
        };
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.46.4' }, detail), true));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function append_hydration_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append_hydration(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function insert_hydration_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert_hydration(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function detach_between_dev(before, after) {
        while (before.nextSibling && before.nextSibling !== after) {
            detach_dev(before.nextSibling);
        }
    }
    function detach_before_dev(after) {
        while (after.previousSibling) {
            detach_dev(after.previousSibling);
        }
    }
    function detach_after_dev(before) {
        while (before.nextSibling) {
            detach_dev(before.nextSibling);
        }
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function dataset_dev(node, property, value) {
        node.dataset[property] = value;
        dispatch_dev('SvelteDOMSetDataset', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }
    /**
     * Base class to create strongly typed Svelte components.
     * This only exists for typing purposes and should be used in `.d.ts` files.
     *
     * ### Example:
     *
     * You have component library on npm called `component-library`, from which
     * you export a component called `MyComponent`. For Svelte+TypeScript users,
     * you want to provide typings. Therefore you create a `index.d.ts`:
     * ```ts
     * import { SvelteComponentTyped } from "svelte";
     * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}
     * ```
     * Typing this makes it possible for IDEs like VS Code with the Svelte extension
     * to provide intellisense and to use the component like this in a Svelte file
     * with TypeScript:
     * ```svelte
     * <script lang="ts">
     * 	import { MyComponent } from "component-library";
     * </script>
     * <MyComponent foo={'bar'} />
     * ```
     *
     * #### Why not make this part of `SvelteComponent(Dev)`?
     * Because
     * ```ts
     * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}
     * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;
     * ```
     * will throw a type error, so we need to separate the more strictly typed class.
     */
    class SvelteComponentTyped extends SvelteComponentDev {
        constructor(options) {
            super(options);
        }
    }
    function loop_guard(timeout) {
        const start = Date.now();
        return () => {
            if (Date.now() - start > timeout) {
                throw new Error('Infinite loop detected');
            }
        };
    }

    exports.HtmlTag = HtmlTag;
    exports.HtmlTagHydration = HtmlTagHydration;
    exports.SvelteComponent = SvelteComponent;
    exports.SvelteComponentDev = SvelteComponentDev;
    exports.SvelteComponentTyped = SvelteComponentTyped;
    exports.action_destroyer = action_destroyer;
    exports.add_attribute = add_attribute;
    exports.add_classes = add_classes;
    exports.add_flush_callback = add_flush_callback;
    exports.add_location = add_location;
    exports.add_render_callback = add_render_callback;
    exports.add_resize_listener = add_resize_listener;
    exports.add_styles = add_styles;
    exports.add_transform = add_transform;
    exports.afterUpdate = afterUpdate;
    exports.append = append;
    exports.append_dev = append_dev;
    exports.append_empty_stylesheet = append_empty_stylesheet;
    exports.append_hydration = append_hydration;
    exports.append_hydration_dev = append_hydration_dev;
    exports.append_styles = append_styles;
    exports.assign = assign;
    exports.attr = attr;
    exports.attr_dev = attr_dev;
    exports.attribute_to_object = attribute_to_object;
    exports.beforeUpdate = beforeUpdate;
    exports.bind = bind;
    exports.binding_callbacks = binding_callbacks;
    exports.blank_object = blank_object;
    exports.bubble = bubble;
    exports.check_outros = check_outros;
    exports.children = children;
    exports.claim_component = claim_component;
    exports.claim_element = claim_element;
    exports.claim_html_tag = claim_html_tag;
    exports.claim_space = claim_space;
    exports.claim_svg_element = claim_svg_element;
    exports.claim_text = claim_text;
    exports.clear_loops = clear_loops;
    exports.component_subscribe = component_subscribe;
    exports.compute_rest_props = compute_rest_props;
    exports.compute_slots = compute_slots;
    exports.createEventDispatcher = createEventDispatcher;
    exports.create_animation = create_animation;
    exports.create_bidirectional_transition = create_bidirectional_transition;
    exports.create_component = create_component;
    exports.create_in_transition = create_in_transition;
    exports.create_out_transition = create_out_transition;
    exports.create_slot = create_slot;
    exports.create_ssr_component = create_ssr_component;
    exports.custom_event = custom_event;
    exports.dataset_dev = dataset_dev;
    exports.debug = debug;
    exports.destroy_block = destroy_block;
    exports.destroy_component = destroy_component;
    exports.destroy_each = destroy_each;
    exports.detach = detach;
    exports.detach_after_dev = detach_after_dev;
    exports.detach_before_dev = detach_before_dev;
    exports.detach_between_dev = detach_between_dev;
    exports.detach_dev = detach_dev;
    exports.dirty_components = dirty_components;
    exports.dispatch_dev = dispatch_dev;
    exports.each = each;
    exports.element = element;
    exports.element_is = element_is;
    exports.empty = empty;
    exports.end_hydrating = end_hydrating;
    exports.escape = escape;
    exports.escape_attribute_value = escape_attribute_value;
    exports.escape_object = escape_object;
    exports.escaped = escaped;
    exports.exclude_internal_props = exclude_internal_props;
    exports.fix_and_destroy_block = fix_and_destroy_block;
    exports.fix_and_outro_and_destroy_block = fix_and_outro_and_destroy_block;
    exports.fix_position = fix_position;
    exports.flush = flush;
    exports.getAllContexts = getAllContexts;
    exports.getContext = getContext;
    exports.get_all_dirty_from_scope = get_all_dirty_from_scope;
    exports.get_binding_group_value = get_binding_group_value;
    exports.get_current_component = get_current_component;
    exports.get_custom_elements_slots = get_custom_elements_slots;
    exports.get_root_for_style = get_root_for_style;
    exports.get_slot_changes = get_slot_changes;
    exports.get_spread_object = get_spread_object;
    exports.get_spread_update = get_spread_update;
    exports.get_store_value = get_store_value;
    exports.globals = globals;
    exports.group_outros = group_outros;
    exports.handle_promise = handle_promise;
    exports.hasContext = hasContext;
    exports.has_prop = has_prop;
    exports.identity = identity;
    exports.init = init;
    exports.insert = insert;
    exports.insert_dev = insert_dev;
    exports.insert_hydration = insert_hydration;
    exports.insert_hydration_dev = insert_hydration_dev;
    exports.intros = intros;
    exports.invalid_attribute_name_character = invalid_attribute_name_character;
    exports.is_client = is_client;
    exports.is_crossorigin = is_crossorigin;
    exports.is_empty = is_empty;
    exports.is_function = is_function;
    exports.is_promise = is_promise;
    exports.listen = listen;
    exports.listen_dev = listen_dev;
    exports.loop = loop;
    exports.loop_guard = loop_guard;
    exports.merge_ssr_styles = merge_ssr_styles;
    exports.missing_component = missing_component;
    exports.mount_component = mount_component;
    exports.noop = noop;
    exports.not_equal = not_equal;
    exports.null_to_empty = null_to_empty;
    exports.object_without_properties = object_without_properties;
    exports.onDestroy = onDestroy;
    exports.onMount = onMount;
    exports.once = once;
    exports.outro_and_destroy_block = outro_and_destroy_block;
    exports.prevent_default = prevent_default;
    exports.prop_dev = prop_dev;
    exports.query_selector_all = query_selector_all;
    exports.run = run;
    exports.run_all = run_all;
    exports.safe_not_equal = safe_not_equal;
    exports.schedule_update = schedule_update;
    exports.select_multiple_value = select_multiple_value;
    exports.select_option = select_option;
    exports.select_options = select_options;
    exports.select_value = select_value;
    exports.self = self;
    exports.setContext = setContext;
    exports.set_attributes = set_attributes;
    exports.set_current_component = set_current_component;
    exports.set_custom_element_data = set_custom_element_data;
    exports.set_data = set_data;
    exports.set_data_dev = set_data_dev;
    exports.set_input_type = set_input_type;
    exports.set_input_value = set_input_value;
    exports.set_now = set_now;
    exports.set_raf = set_raf;
    exports.set_store_value = set_store_value;
    exports.set_style = set_style;
    exports.set_svg_attributes = set_svg_attributes;
    exports.space = space;
    exports.spread = spread;
    exports.src_url_equal = src_url_equal;
    exports.start_hydrating = start_hydrating;
    exports.stop_propagation = stop_propagation;
    exports.subscribe = subscribe;
    exports.svg_element = svg_element;
    exports.text = text;
    exports.tick = tick;
    exports.time_ranges_to_array = time_ranges_to_array;
    exports.to_number = to_number;
    exports.toggle_class = toggle_class;
    exports.transition_in = transition_in;
    exports.transition_out = transition_out;
    exports.trusted = trusted;
    exports.update_await_block_branch = update_await_block_branch;
    exports.update_keyed_each = update_keyed_each;
    exports.update_slot = update_slot;
    exports.update_slot_base = update_slot_base;
    exports.validate_component = validate_component;
    exports.validate_each_argument = validate_each_argument;
    exports.validate_each_keys = validate_each_keys;
    exports.validate_slots = validate_slots;
    exports.validate_store = validate_store;
    exports.xlink_attr = xlink_attr;
    }(internal));

    (function (exports) {

    Object.defineProperty(exports, '__esModule', { value: true });

    var internal$1 = internal;

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = internal$1.noop) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
            if (internal$1.safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (const subscriber of subscribers) {
                        subscriber[1]();
                        subscriber_queue.push(subscriber, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = internal$1.noop) {
            const subscriber = [run, invalidate];
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
                stop = start(set) || internal$1.noop;
            }
            run(value);
            return () => {
                subscribers.delete(subscriber);
                if (subscribers.size === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = internal$1.noop;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = internal$1.is_function(result) ? result : internal$1.noop;
                }
            };
            const unsubscribers = stores_array.map((store, i) => internal$1.subscribe(store, (value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                internal$1.run_all(unsubscribers);
                cleanup();
            };
        });
    }

    Object.defineProperty(exports, 'get', {
    	enumerable: true,
    	get: function () {
    		return internal$1.get_store_value;
    	}
    });
    exports.derived = derived;
    exports.readable = readable;
    exports.writable = writable;
    }(store));

    Object.defineProperty(tooltipStore, "__esModule", { value: true });
    var tooltipStore_1 = tooltipStore.tooltipStore = void 0;
    const store_1 = store;
    tooltipStore_1 = tooltipStore.tooltipStore = (0, store_1.writable)({});

    /* node_modules/@ekstra-bladet/designsystem/dist/components/tooltip/Tooltip.svelte generated by Svelte v3.46.4 */
    const file$1 = "node_modules/@ekstra-bladet/designsystem/dist/components/tooltip/Tooltip.svelte";

    // (38:2) {:else}
    function create_else_block(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*content*/ ctx[1]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*content*/ 2) set_data_dev(t, /*content*/ ctx[1]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(38:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (36:22) 
    function create_if_block_1(ctx) {
    	let html_tag;
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_tag = new HtmlTag();
    			html_anchor = empty();
    			html_tag.a = html_anchor;
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(/*content*/ ctx[1], target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*content*/ 2) html_tag.p(/*content*/ ctx[1]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(36:22) ",
    		ctx
    	});

    	return block;
    }

    // (34:2) {#if !textOnly}
    function create_if_block(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*props*/ ctx[2]];
    	var switch_value = /*content*/ ctx[1];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*props*/ 4)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*props*/ ctx[2])])
    			: {};

    			if (switch_value !== (switch_value = /*content*/ ctx[1])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(34:2) {#if !textOnly}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block, create_if_block_1, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (!/*textOnly*/ ctx[4]) return 0;
    		if (/*allowHTML*/ ctx[0]) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			toggle_class(div, "tooltip-textonly", /*textOnly*/ ctx[4]);
    			add_location(div, file$1, 32, 0, 1148);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			/*div_binding*/ ctx[7](div);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}

    			if (dirty & /*textOnly*/ 16) {
    				toggle_class(div, "tooltip-textonly", /*textOnly*/ ctx[4]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    			/*div_binding*/ ctx[7](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance_1($$self, $$props, $$invalidate) {
    	let textOnly;
    	let $tooltipStore;
    	validate_store(tooltipStore_1, 'tooltipStore');
    	component_subscribe($$self, tooltipStore_1, $$value => $$invalidate(9, $tooltipStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Tooltip', slots, []);
    	let { allowHTML = false } = $$props;
    	let { anchorNode } = $$props;
    	let { content } = $$props;
    	let { props = {} } = $$props;
    	let { tippyOptions = {} } = $$props;
    	let tooltipNode;
    	let instance = null;

    	onMount(() => {
    		instance = tooltipRender_2(anchorNode, tooltipNode, tippyOptions);

    		// Add to store for programmatic access, if anchor has unique id
    		if (anchorNode.hasAttribute('id')) {
    			const id = anchorNode.getAttribute('id');
    			set_store_value(tooltipStore_1, $tooltipStore[id] = instance, $tooltipStore);
    		}
    	});

    	afterUpdate(() => {
    		instance.setProps(tippyOptions);
    	});

    	onDestroy(() => {
    		// Remove tooltip instance and store entry
    		instance.destroy();

    		if (anchorNode.hasAttribute('id')) {
    			const id = anchorNode.getAttribute('id');
    			delete $tooltipStore[id];
    		}
    	});

    	const writable_props = ['allowHTML', 'anchorNode', 'content', 'props', 'tippyOptions'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Tooltip> was created with unknown prop '${key}'`);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			tooltipNode = $$value;
    			$$invalidate(3, tooltipNode);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('allowHTML' in $$props) $$invalidate(0, allowHTML = $$props.allowHTML);
    		if ('anchorNode' in $$props) $$invalidate(5, anchorNode = $$props.anchorNode);
    		if ('content' in $$props) $$invalidate(1, content = $$props.content);
    		if ('props' in $$props) $$invalidate(2, props = $$props.props);
    		if ('tippyOptions' in $$props) $$invalidate(6, tippyOptions = $$props.tippyOptions);
    	};

    	$$self.$capture_state = () => ({
    		afterUpdate,
    		onMount,
    		onDestroy,
    		SvelteComponent: SvelteComponentDev,
    		tooltipRender: tooltipRender_2,
    		tooltipStore: tooltipStore_1,
    		allowHTML,
    		anchorNode,
    		content,
    		props,
    		tippyOptions,
    		tooltipNode,
    		instance,
    		textOnly,
    		$tooltipStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('allowHTML' in $$props) $$invalidate(0, allowHTML = $$props.allowHTML);
    		if ('anchorNode' in $$props) $$invalidate(5, anchorNode = $$props.anchorNode);
    		if ('content' in $$props) $$invalidate(1, content = $$props.content);
    		if ('props' in $$props) $$invalidate(2, props = $$props.props);
    		if ('tippyOptions' in $$props) $$invalidate(6, tippyOptions = $$props.tippyOptions);
    		if ('tooltipNode' in $$props) $$invalidate(3, tooltipNode = $$props.tooltipNode);
    		if ('instance' in $$props) instance = $$props.instance;
    		if ('textOnly' in $$props) $$invalidate(4, textOnly = $$props.textOnly);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*content*/ 2) {
    			$$invalidate(4, textOnly = typeof content === 'string' || content instanceof String);
    		}
    	};

    	return [
    		allowHTML,
    		content,
    		props,
    		tooltipNode,
    		textOnly,
    		anchorNode,
    		tippyOptions,
    		div_binding
    	];
    }

    class Tooltip extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance_1, create_fragment$1, safe_not_equal, {
    			allowHTML: 0,
    			anchorNode: 5,
    			content: 1,
    			props: 2,
    			tippyOptions: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tooltip",
    			options,
    			id: create_fragment$1.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*anchorNode*/ ctx[5] === undefined && !('anchorNode' in props)) {
    			console.warn("<Tooltip> was created without expected prop 'anchorNode'");
    		}

    		if (/*content*/ ctx[1] === undefined && !('content' in props)) {
    			console.warn("<Tooltip> was created without expected prop 'content'");
    		}
    	}

    	get allowHTML() {
    		throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set allowHTML(value) {
    		throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get anchorNode() {
    		throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set anchorNode(value) {
    		throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get content() {
    		throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set content(value) {
    		throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get props() {
    		throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set props(value) {
    		throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tippyOptions() {
    		throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tippyOptions(value) {
    		throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Tooltip$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Tooltip
    });

    var require$$0$1 = /*@__PURE__*/getAugmentedNamespace(Tooltip$1);

    Object.defineProperty(tooltipAction, "__esModule", { value: true });
    // @ts-ignore
    const Tooltip_svelte_1 = require$$0$1;
    function default_1(anchorNode, options) {
        const target = document.createElement('div');
        const instance = new Tooltip_svelte_1.default({
            target,
            props: Object.assign({ anchorNode }, options),
        });
        return {
            update(newProps) {
                Object.assign(instance, newProps);
            },
            destroy() {
                instance.$destroy();
            },
        };
    }
    tooltipAction.default = default_1;

    var splitNfitTitle$1 = {};

    /**
     * fitty v2.3.6 - Snugly resizes text to fit its parent container
     * Copyright (c) 2022 Rik Schennink <rik@pqina.nl> (https://pqina.nl/)
     */

    var e=function(e){if(e){var t=function(e){return [].slice.call(e)},n=0,i=1,r=2,o=3,a=[],l=null,u="requestAnimationFrame"in e?function(){e.cancelAnimationFrame(l),l=e.requestAnimationFrame((function(){return s(a.filter((function(e){return e.dirty&&e.active})))}));}:function(){},c=function(e){return function(){a.forEach((function(t){return t.dirty=e})),u();}},s=function(e){e.filter((function(e){return !e.styleComputed})).forEach((function(e){e.styleComputed=m(e);})),e.filter(y).forEach(v);var t=e.filter(p);t.forEach(d),t.forEach((function(e){v(e),f(e);})),t.forEach(S);},f=function(e){return e.dirty=n},d=function(e){e.availableWidth=e.element.parentNode.clientWidth,e.currentWidth=e.element.scrollWidth,e.previousFontSize=e.currentFontSize,e.currentFontSize=Math.min(Math.max(e.minSize,e.availableWidth/e.currentWidth*e.previousFontSize),e.maxSize),e.whiteSpace=e.multiLine&&e.currentFontSize===e.minSize?"normal":"nowrap";},p=function(e){return e.dirty!==r||e.dirty===r&&e.element.parentNode.clientWidth!==e.availableWidth},m=function(t){var n=e.getComputedStyle(t.element,null);return t.currentFontSize=parseFloat(n.getPropertyValue("font-size")),t.display=n.getPropertyValue("display"),t.whiteSpace=n.getPropertyValue("white-space"),!0},y=function(e){var t=!1;return !e.preStyleTestCompleted&&(/inline-/.test(e.display)||(t=!0,e.display="inline-block"),"nowrap"!==e.whiteSpace&&(t=!0,e.whiteSpace="nowrap"),e.preStyleTestCompleted=!0,t)},v=function(e){e.element.style.whiteSpace=e.whiteSpace,e.element.style.display=e.display,e.element.style.fontSize=e.currentFontSize+"px";},S=function(e){e.element.dispatchEvent(new CustomEvent("fit",{detail:{oldValue:e.previousFontSize,newValue:e.currentFontSize,scaleFactor:e.currentFontSize/e.previousFontSize}}));},h=function(e,t){return function(){e.dirty=t,e.active&&u();}},w=function(e){return function(){a=a.filter((function(t){return t.element!==e.element})),e.observeMutations&&e.observer.disconnect(),e.element.style.whiteSpace=e.originalStyle.whiteSpace,e.element.style.display=e.originalStyle.display,e.element.style.fontSize=e.originalStyle.fontSize;}},b=function(e){return function(){e.active||(e.active=!0,u());}},z=function(e){return function(){return e.active=!1}},F=function(e){e.observeMutations&&(e.observer=new MutationObserver(h(e,i)),e.observer.observe(e.element,e.observeMutations));},g={minSize:16,maxSize:512,multiLine:!0,observeMutations:"MutationObserver"in e&&{subtree:!0,childList:!0,characterData:!0}},W=null,E=function(){e.clearTimeout(W),W=e.setTimeout(c(r),x.observeWindowDelay);},M=["resize","orientationchange"];return Object.defineProperty(x,"observeWindow",{set:function(t){var n="".concat(t?"add":"remove","EventListener");M.forEach((function(t){e[n](t,E);}));}}),x.observeWindow=!0,x.observeWindowDelay=100,x.fitAll=c(o),x}function C(e,t){var n=Object.assign({},g,t),i=e.map((function(e){var t=Object.assign({},n,{element:e,active:!0});return function(e){e.originalStyle={whiteSpace:e.element.style.whiteSpace,display:e.element.style.display,fontSize:e.element.style.fontSize},F(e),e.newbie=!0,e.dirty=!0,a.push(e);}(t),{element:e,fit:h(t,o),unfreeze:b(t),freeze:z(t),unsubscribe:w(t)}}));return u(),i}function x(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return "string"==typeof e?C(t(document.querySelectorAll(e)),n):C([e],n)[0]}}("undefined"==typeof window?null:window);

    var fitty_module = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': e
    });

    var require$$0 = /*@__PURE__*/getAugmentedNamespace(fitty_module);

    var splitTitle$1 = {};

    Object.defineProperty(splitTitle$1, "__esModule", { value: true });
    splitTitle$1.splitTitle = void 0;
    function splitTitle(input, minLines = 2, maxLines = 4) {
        // Split word in array
        const wordsArray = input.split(' ');
        const arrayOfLengths = wordsArray.map((x) => x.length);
        // Calculate optimal number of lines
        const numLines = Math.min(Math.max(Math.ceil(input.length / 20), minLines), maxLines);
        if (numLines <= 1)
            return [input];
        if (numLines >= arrayOfLengths.length)
            return wordsArray;
        const partition_between = Array.from({ length: numLines - 1 }).map((_x, i) => (i + 1) * Math.floor(arrayOfLengths.length / numLines));
        const average_height = arrayOfLengths.reduce((arr, cur) => {
            return arr + cur;
        }) / numLines;
        let bestScore = null;
        let bestPartitions = null;
        let count = 0;
        // Safelimit number of iterations to find optimal partion
        while (count < 20) {
            const starts = [0].concat(...partition_between);
            const ends = partition_between.concat(arrayOfLengths.length);
            const partitions = Array.from({ length: numLines }).map((_x, i) => arrayOfLengths.slice(starts[i], ends[i]));
            // Calculate the sum of wordlengths (heights)
            const heights = partitions.map((partition) => partition.reduce((arr, cur) => arr + cur, 0));
            const absHeightDiffs = heights.map((x) => Math.abs(average_height - x));
            const worstPartitionIndex = absHeightDiffs.indexOf(Math.max(...absHeightDiffs));
            const worstHeightDiff = average_height - heights[worstPartitionIndex];
            let noImprovementsCount;
            if (bestScore === null || Math.abs(worstHeightDiff) < bestScore) {
                bestScore = Math.abs(worstHeightDiff);
                bestPartitions = partitions;
                noImprovementsCount = 0;
            }
            else {
                noImprovementsCount += 1;
            }
            if (worstHeightDiff === 0 || noImprovementsCount > 5 || count > 5) {
                // We got the best partion!
                return bestPartitions.map((x) => x.map(() => wordsArray.shift()).join(' '));
            }
            count++;
            const move = worstHeightDiff < 0 ? -1 : 1;
            const boundToMove = worstPartitionIndex === 0
                ? 0
                : worstPartitionIndex === numLines - 1
                    ? numLines - 2
                    : worstHeightDiff < 0 !== heights[worstPartitionIndex - 1] > heights[worstPartitionIndex + 1]
                        ? worstPartitionIndex - 1
                        : worstPartitionIndex;
            const direction = boundToMove < worstPartitionIndex ? -1 : 1;
            partition_between[boundToMove] += move * direction;
        }
        return [input];
    }
    splitTitle$1.splitTitle = splitTitle;

    var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    Object.defineProperty(splitNfitTitle$1, "__esModule", { value: true });
    splitNfitTitle$1.splitNfitTitle = void 0;
    const fitty_1 = require$$0;
    const splitTitle_1 = splitTitle$1;
    function fit(titleParts, fittyOptions) {
        let cleanFittyOptions = Object.fromEntries(Object.entries(fittyOptions).filter(([_fittyOptionsKey, fittyOptionsVal]) => fittyOptionsVal != null));
        titleParts.forEach((titlePart) => {
            const fitEl = (0, fitty_1.default)(titlePart, cleanFittyOptions);
            fitEl.fit();
        });
    }
    function splitNfitTitle(title, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { maxLines = 10, maxSize, minLines = 1, minSize, multiLine, observeMutations, safe = false } = options;
            const titleSplit = (0, splitTitle_1.splitTitle)(title, minLines, maxLines);
            const titleFrag = document.createDocumentFragment();
            const titleSpans = [];
            titleSplit.forEach((txt) => {
                const titleSpan = document.createElement('span');
                titleSpan.classList.add('fitty-line');
                titleSpan.innerText = txt;
                titleFrag.appendChild(titleSpan);
                titleSpans.push(titleSpan);
            });
            if (safe) {
                fit(titleSpans, {
                    minSize,
                    maxSize,
                    multiLine,
                    observeMutations,
                });
            }
            else {
                yield document.fonts.ready.then(() => {
                    fit(titleSpans, {
                        minSize,
                        maxSize,
                        multiLine,
                        observeMutations,
                    });
                });
            }
            return titleFrag;
        });
    }
    splitNfitTitle$1.splitNfitTitle = splitNfitTitle;

    (function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tooltipStore = exports.tooltipRender = exports.throttle = exports.splitTitle = exports.splitNfitTitle = exports.parseDate = exports.tooltipAction = exports.Toggler = exports.TextInput = exports.TextArea = exports.Tabs = exports.TabList = exports.TabContent = exports.Tab = exports.Spinner = exports.Select = exports.Icon = exports.HorizontalScroll = exports.FormElement = exports.Checkbox = exports.Card = exports.ButtonGroup = exports.Button = exports.Badge = exports.ArticleList = exports.ArticleCard = exports.Accordion = void 0;
    // Components
    var Accordion_svelte_1 = require$$0$3;
    Object.defineProperty(exports, "Accordion", { enumerable: true, get: function () { return Accordion_svelte_1.default; } });
    var ArticleCard_svelte_1 = require$$1;
    Object.defineProperty(exports, "ArticleCard", { enumerable: true, get: function () { return ArticleCard_svelte_1.default; } });
    var ArticleList_svelte_1 = require$$2;
    Object.defineProperty(exports, "ArticleList", { enumerable: true, get: function () { return ArticleList_svelte_1.default; } });
    var Badge_svelte_1 = require$$3;
    Object.defineProperty(exports, "Badge", { enumerable: true, get: function () { return Badge_svelte_1.default; } });
    var Button_svelte_1 = require$$4;
    Object.defineProperty(exports, "Button", { enumerable: true, get: function () { return Button_svelte_1.default; } });
    var ButtonGroup_svelte_1 = require$$5;
    Object.defineProperty(exports, "ButtonGroup", { enumerable: true, get: function () { return ButtonGroup_svelte_1.default; } });
    var Card_svelte_1 = require$$6;
    Object.defineProperty(exports, "Card", { enumerable: true, get: function () { return Card_svelte_1.default; } });
    var Checkbox_svelte_1 = require$$7;
    Object.defineProperty(exports, "Checkbox", { enumerable: true, get: function () { return Checkbox_svelte_1.default; } });
    var FormElement_svelte_1 = require$$8;
    Object.defineProperty(exports, "FormElement", { enumerable: true, get: function () { return FormElement_svelte_1.default; } });
    var HorizontalScroll_svelte_1 = require$$9;
    Object.defineProperty(exports, "HorizontalScroll", { enumerable: true, get: function () { return HorizontalScroll_svelte_1.default; } });
    var Icon_svelte_1 = require$$10;
    Object.defineProperty(exports, "Icon", { enumerable: true, get: function () { return Icon_svelte_1.default; } });
    var Select_svelte_1 = require$$11;
    Object.defineProperty(exports, "Select", { enumerable: true, get: function () { return Select_svelte_1.default; } });
    var Spinner_svelte_1 = require$$12;
    Object.defineProperty(exports, "Spinner", { enumerable: true, get: function () { return Spinner_svelte_1.default; } });
    var Tab_svelte_1 = require$$13;
    Object.defineProperty(exports, "Tab", { enumerable: true, get: function () { return Tab_svelte_1.default; } });
    var TabContent_svelte_1 = require$$14;
    Object.defineProperty(exports, "TabContent", { enumerable: true, get: function () { return TabContent_svelte_1.default; } });
    var TabList_svelte_1 = require$$15;
    Object.defineProperty(exports, "TabList", { enumerable: true, get: function () { return TabList_svelte_1.default; } });
    var Tabs_svelte_1 = require$$16;
    Object.defineProperty(exports, "Tabs", { enumerable: true, get: function () { return Tabs_svelte_1.default; } });
    var TextArea_svelte_1 = require$$17;
    Object.defineProperty(exports, "TextArea", { enumerable: true, get: function () { return TextArea_svelte_1.default; } });
    var TextInput_svelte_1 = require$$18;
    Object.defineProperty(exports, "TextInput", { enumerable: true, get: function () { return TextInput_svelte_1.default; } });
    var Toggler_svelte_1 = require$$19;
    Object.defineProperty(exports, "Toggler", { enumerable: true, get: function () { return Toggler_svelte_1.default; } });
    // Functions
    var tooltipAction_1 = tooltipAction;
    Object.defineProperty(exports, "tooltipAction", { enumerable: true, get: function () { return tooltipAction_1.default; } });
    var parsedate_1 = parsedate;
    Object.defineProperty(exports, "parseDate", { enumerable: true, get: function () { return parsedate_1.parseDate; } });
    var splitNfitTitle_1 = splitNfitTitle$1;
    Object.defineProperty(exports, "splitNfitTitle", { enumerable: true, get: function () { return splitNfitTitle_1.splitNfitTitle; } });
    var splitTitle_1 = splitTitle$1;
    Object.defineProperty(exports, "splitTitle", { enumerable: true, get: function () { return splitTitle_1.splitTitle; } });
    var throttle_1 = throttle$1;
    Object.defineProperty(exports, "throttle", { enumerable: true, get: function () { return throttle_1.throttle; } });
    var tooltipRender_1 = tooltipRender$1;
    Object.defineProperty(exports, "tooltipRender", { enumerable: true, get: function () { return tooltipRender_1.tooltipRender; } });
    var tooltipStore_1 = tooltipStore;
    Object.defineProperty(exports, "tooltipStore", { enumerable: true, get: function () { return tooltipStore_1.tooltipStore; } });
    }(dist));

    /* src/App.svelte generated by Svelte v3.46.4 */
    const file = "src/App.svelte";

    function create_fragment(ctx) {
    	let div;
    	let main;
    	let h1;
    	let icon;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let p0;
    	let t4;
    	let a0;
    	let t6;
    	let t7;
    	let p1;
    	let t8;
    	let a1;
    	let t10;
    	let current;

    	icon = new dist.Icon({
    			props: { name: "ekstrabladet" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			main = element("main");
    			h1 = element("h1");
    			create_component(icon.$$.fragment);
    			t0 = text(" Hello ");
    			t1 = text(/*name*/ ctx[0]);
    			t2 = text("!");
    			t3 = space();
    			p0 = element("p");
    			t4 = text("Visit the ");
    			a0 = element("a");
    			a0.textContent = "Svelte tutorial";
    			t6 = text(" to learn how to build Svelte apps.");
    			t7 = space();
    			p1 = element("p");
    			t8 = text("And visit the ");
    			a1 = element("a");
    			a1.textContent = "Designsystem documentation";
    			t10 = text(" to\n      learn how the designsystem works");
    			add_location(h1, file, 8, 4, 322);
    			attr_dev(a0, "href", "https://svelte.dev/tutorial");
    			add_location(a0, file, 10, 16, 398);
    			add_location(p0, file, 9, 4, 378);
    			attr_dev(a1, "href", "https://ekstrabladetudvikling.github.io/eb-designsystem/");
    			add_location(a1, file, 13, 20, 528);
    			add_location(p1, file, 12, 4, 504);
    			attr_dev(main, "class", "grid-width--medium");
    			add_location(main, file, 7, 2, 284);
    			attr_dev(div, "class", "flex flex-justify--center");
    			add_location(div, file, 6, 0, 242);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, main);
    			append_dev(main, h1);
    			mount_component(icon, h1, null);
    			append_dev(h1, t0);
    			append_dev(h1, t1);
    			append_dev(h1, t2);
    			append_dev(main, t3);
    			append_dev(main, p0);
    			append_dev(p0, t4);
    			append_dev(p0, a0);
    			append_dev(p0, t6);
    			append_dev(main, t7);
    			append_dev(main, p1);
    			append_dev(p1, t8);
    			append_dev(p1, a1);
    			append_dev(p1, t10);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*name*/ 1) set_data_dev(t1, /*name*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, []);
    	let { name } = $$props;
    	const tabs = [{ content: 'flurps', title: 'Step 1' }];
    	const writable_props = ['name'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('name' in $$props) $$invalidate(0, name = $$props.name);
    	};

    	$$self.$capture_state = () => ({
    		Accordion: dist.Accordion,
    		Badge: dist.Badge,
    		Button: dist.Button,
    		Icon: dist.Icon,
    		name,
    		tabs
    	});

    	$$self.$inject_state = $$props => {
    		if ('name' in $$props) $$invalidate(0, name = $$props.name);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [name];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, { name: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*name*/ ctx[0] === undefined && !('name' in props)) {
    			console.warn("<App> was created without expected prop 'name'");
    		}
    	}

    	get name() {
    		throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const app = new App({
        props: {
            name: 'Ekstra Bladet',
        },
        target: document.body,
    });

    return app;

})();
//# sourceMappingURL=bundle.js.map
